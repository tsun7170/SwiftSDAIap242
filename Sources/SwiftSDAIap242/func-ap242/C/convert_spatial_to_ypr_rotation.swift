/* file: convert_spatial_to_ypr_rotation.swift 	 generated: Sun Oct 31 15:32:10 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION convert_spatial_to_ypr_rotation(
               pair : kinematic_pair;
               rotation : spatial_rotation
           ) : ypr_rotation;

    LOCAL
      axis       : direction;
      angle      : plane_angle_measure;
      conv_angle : plane_angle_measure;
      ya         : plane_angle_measure;
      pa         : plane_angle_measure;
      ra         : plane_angle_measure;
      ucf        : REAL;
      dx         : REAL;
      dy         : REAL;
      dz         : REAL;
      s_a        : REAL;
      c_a        : REAL;
      rotmat     : ARRAY [1 : 3] OF ARRAY [1 : 3] OF REAL;
      cm1        : REAL;
      s_y        : REAL;
      c_y        : REAL;
      s_r        : REAL;
      c_r        : REAL;
    END_LOCAL;
    IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.YPR_ROTATION' IN TYPEOF( rotation ) THEN
      RETURN( rotation );
    END_IF;
    axis := normalise( rotation\rotation_about_direction.direction_of_axis );
    angle := rotation\rotation_about_direction.rotation_angle;
    IF angle = 0 THEN
      RETURN( [0, 0, 0] );
    END_IF;
    dx := axis.direction_ratios[1];
    dy := axis.direction_ratios[2];
    dz := axis.direction_ratios[3];
    conv_angle := plane_angle_for_pair_in_radian( pair, angle );
    IF NOT ( 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF( conv_angle ) )
        THEN
      RETURN( ? );
    END_IF;
    ucf := angle / conv_angle;
    s_a := SIN( conv_angle );
    c_a := COS( conv_angle );
    IF ( dy = 0 ) AND ( ( dx * dz ) = 0 ) THEN
      REPEAT WHILE conv_angle <= ( -PI );
        conv_angle := conv_angle + ( 2 * PI );
      END_REPEAT;
      REPEAT WHILE conv_angle > PI;
        conv_angle := conv_angle - ( 2 * PI );
      END_REPEAT;
      ya := ucf * conv_angle;
      IF conv_angle <> PI THEN
        ra := -ya;
      ELSE
        ra := ya;
      END_IF;
      IF dx <> 0 THEN
        IF dx > 0 THEN
          RETURN( [0, 0, ya] );
        ELSE
          RETURN( [0, 0, ra] );
        END_IF;
      ELSE
        IF dz > 0 THEN
          RETURN( [ya, 0, 0] );
        ELSE
          RETURN( [ra, 0, 0] );
        END_IF;
      END_IF;
    END_IF;
    IF ( dy <> 0 ) AND ( dx = 0 ) AND ( dz = 0 ) THEN
      IF c_a >= 0 THEN
        ya := 0;
        ra := 0;
      ELSE
        ya := ucf * PI;
        ra := ya;
      END_IF;
      pa := ucf * ATAN( s_a, ABS( c_a ) );
      IF dy < 0 THEN
        pa := -pa;
      END_IF;
      RETURN( [ya, pa, ra] );
    END_IF;
    cm1 := 1 - c_a;
    rotmat := [[( dx * dx * cm1 ) + c_a, ( dx * dy * cm1 ) - ( dz * s_a ), ( dx * dz * cm1 ) + ( dy * s_a )], 
        [( dx * dy * cm1 ) + ( dz * s_a ), ( dy * dy * cm1 ) + c_a, ( dy * dz * cm1 ) - ( dx * s_a )], [( dx 
        * dz * cm1 ) - ( dy * s_a ), ( dy * dz * cm1 ) + ( dx * s_a ), ( dz * dz * cm1 ) + c_a]];
    IF ABS( rotmat[1][3] ) = 1 THEN

      BEGIN
        IF rotmat[1][3] = 1 THEN
          pa := 0.5 * PI;
        ELSE
          pa := ( -0.5 ) * PI;
        END_IF;
        ra := 0;
        ya := ATAN( rotmat[2][1], rotmat[2][2] );
        IF rotmat[2][2] < 0 THEN
          IF ya <= 0 THEN
            ya := ya + PI;
          ELSE
            ya := ya - PI;
          END_IF;
        END_IF;
      END;
    ELSE

      BEGIN
        ya := ATAN( -rotmat[1][2], rotmat[1][1] );
        IF rotmat[1][1] < 0 THEN
          IF ya <= 0 THEN
            ya := ya + PI;
          ELSE
            ya := ya - PI;
          END_IF;
        END_IF;
        ra := ATAN( -rotmat[2][3], rotmat[3][3] );
        IF rotmat[3][3] < 0 THEN
          IF ra <= 0 THEN
            ra := ra + PI;
          ELSE
            ra := ra - PI;
          END_IF;
        END_IF;
        s_y := SIN( ya );
        c_y := COS( ya );
        s_r := SIN( ra );
        c_r := COS( ra );
        IF ( ABS( s_y ) > ABS( c_y ) ) AND ( ABS( s_y ) > ABS( s_r ) ) AND ( ABS( s_y ) > ABS( c_r ) ) THEN
          cm1 := ( -rotmat[1][2] ) / s_y;
        ELSE
          IF ( ABS( c_y ) > ABS( s_r ) ) AND ( ABS( c_y ) > ABS( c_r ) ) THEN
            cm1 := rotmat[1][1] / c_y;
          ELSE
            IF ABS( s_r ) > ABS( c_r ) THEN
              cm1 := ( -rotmat[2][3] ) / s_r;
            ELSE
              cm1 := rotmat[3][3] / c_r;
            END_IF;
          END_IF;
        END_IF;
        pa := ATAN( rotmat[1][3], cm1 );
      END;
    END_IF;
    ya := ya * ucf;
    pa := pa * ucf;
    ra := ra * ucf;
    RETURN( [ya, pa, ra] );

  END_FUNCTION; -- convert_spatial_to_ypr_rotation (line:36947 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func CONVERT_SPATIAL_TO_YPR_ROTATION(
    PAIR: eKINEMATIC_PAIR? , ROTATION: sSPATIAL_ROTATION? ) 
    -> tYPR_ROTATION? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( PAIR, ROTATION )
    if case .available(let _cached_value) = _convert_spatial_to_ypr_rotation__cache.cachedValue(params: _params) {
      return _cached_value as? tYPR_ROTATION
    }

    var PAIR = PAIR; SDAI.TOUCH(var: &PAIR)
    var ROTATION = ROTATION; SDAI.TOUCH(var: &ROTATION)

    //LOCAL
    var AXIS: eDIRECTION? 
    var ANGLE: tPLANE_ANGLE_MEASURE? 
    var CONV_ANGLE: tPLANE_ANGLE_MEASURE? 
    var YA: tPLANE_ANGLE_MEASURE? 
    var PA: tPLANE_ANGLE_MEASURE? 
    var RA: tPLANE_ANGLE_MEASURE? 
    var UCF: SDAI.REAL? 
    var DX: SDAI.REAL? 
    var DY: SDAI.REAL? 
    var DZ: SDAI.REAL? 
    var S_A: SDAI.REAL? 
    var C_A: SDAI.REAL? 
    var ROTMAT: (SDAI.ARRAY<SDAI.ARRAY<SDAI.REAL>/*[1:3]*/ >/*[1:3]*/ )? 
    var CM1: SDAI.REAL? 
    var S_Y: SDAI.REAL? 
    var C_Y: SDAI.REAL? 
    var S_R: SDAI.REAL? 
    var C_R: SDAI.REAL? 
    //END_LOCAL

    
    let _TEMP1 = SDAI.TYPEOF(ROTATION, IS: tYPR_ROTATION.self)
    if SDAI.IS_TRUE( _TEMP1 ) {
      return _convert_spatial_to_ypr_rotation__cache.updateCache(params: _params, value: tYPR_ROTATION(/*
        sSPATIAL_ROTATION*/ROTATION))
    }
    
    let _TEMP2 = ROTATION?.GROUP_REF(eROTATION_ABOUT_DIRECTION.self)
    let _TEMP3 = _TEMP2?.DIRECTION_OF_AXIS
    let _TEMP4 = NORMALISE(sVECTOR_OR_DIRECTION(/*eDIRECTION*/_TEMP3))
    AXIS = eDIRECTION(/*sVECTOR_OR_DIRECTION*/_TEMP4)
    
    let _TEMP5 = ROTATION?.GROUP_REF(eROTATION_ABOUT_DIRECTION.self)
    let _TEMP6 = _TEMP5?.ROTATION_ANGLE
    ANGLE = _TEMP6
    
    let _TEMP7 = ANGLE .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    if SDAI.IS_TRUE( _TEMP7 ) {
      
      let _TEMP8 = tYPR_ROTATION(bound1: SDAI.UNWRAP(YPR_INDEX(YAW)), bound2: SDAI.UNWRAP(YPR_INDEX(
        ROLL)), ([SDAI.AIE(tPLANE_ANGLE_MEASURE(0)), 
        SDAI.AIE(tPLANE_ANGLE_MEASURE(0)), 
        SDAI.AIE(tPLANE_ANGLE_MEASURE(0))] as [SDAI.AggregationInitializerElement<tPLANE_ANGLE_MEASURE>]))
      return _convert_spatial_to_ypr_rotation__cache.updateCache(params: _params, value: _TEMP8)
    }
    
    let _TEMP9 = AXIS?.DIRECTION_RATIOS
    let _TEMP10 = _TEMP9?[1]
    DX = _TEMP10
    
    let _TEMP11 = AXIS?.DIRECTION_RATIOS
    let _TEMP12 = _TEMP11?[2]
    DY = _TEMP12
    
    let _TEMP13 = AXIS?.DIRECTION_RATIOS
    let _TEMP14 = _TEMP13?[3]
    DZ = _TEMP14
    
    let _TEMP15 = PLANE_ANGLE_FOR_PAIR_IN_RADIAN(
      PAIR: PAIR, ANGLE: ANGLE)
    CONV_ANGLE = _TEMP15
    
    let _TEMP16 = SDAI.TYPEOF(CONV_ANGLE, IS: tPLANE_ANGLE_MEASURE.self)
    let _TEMP17 =  !_TEMP16
    if SDAI.IS_TRUE( _TEMP17 ) {
      return _convert_spatial_to_ypr_rotation__cache.updateCache(params: _params, value: (nil as 
        tYPR_ROTATION?))
    }
    
    let _TEMP18 = ANGLE / CONV_ANGLE
    UCF = _TEMP18
    
    let _TEMP19 = SDAI.SIN(CONV_ANGLE)
    S_A = _TEMP19
    
    let _TEMP20 = SDAI.COS(CONV_ANGLE)
    C_A = _TEMP20
    
    let _TEMP21 = DY .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    let _TEMP22 = DX * DZ
    let _TEMP23 = _TEMP22 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    let _TEMP24 = _TEMP21 && _TEMP23
    if SDAI.IS_TRUE( _TEMP24 ) {
      while !SDAI.IS_TRUE(( CONV_ANGLE <= SDAI.FORCE_OPTIONAL(SDAI.REAL( -SDAI.PI)) )) {
        
        let _TEMP25 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP26 = CONV_ANGLE + SDAI.FORCE_OPTIONAL(_TEMP25)
        CONV_ANGLE = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP26)
      }
      while !SDAI.IS_TRUE(( CONV_ANGLE > SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI)) )) {
        
        let _TEMP27 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP28 = CONV_ANGLE - SDAI.FORCE_OPTIONAL(_TEMP27)
        CONV_ANGLE = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP28)
      }
      
      let _TEMP29 = UCF * CONV_ANGLE
      YA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP29)
      
      let _TEMP30 = CONV_ANGLE .!=. SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
      if SDAI.IS_TRUE( _TEMP30 ) {
        RA =  -YA
      }
      else {
        RA = YA
      }
      
      let _TEMP31 = DX .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP31 ) {
        
        let _TEMP32 = DX > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP32 ) {
          
          let _TEMP33 = tYPR_ROTATION(bound1: SDAI.UNWRAP(YPR_INDEX(YAW)), bound2: SDAI.UNWRAP(YPR_INDEX(
            ROLL)), ([SDAI.AIE(tPLANE_ANGLE_MEASURE(0)), 
            SDAI.AIE(tPLANE_ANGLE_MEASURE(0)), 
            SDAI.AIE(YA)] as [SDAI.AggregationInitializerElement<tPLANE_ANGLE_MEASURE>]))
          return _convert_spatial_to_ypr_rotation__cache.updateCache(params: _params, value: _TEMP33)
        }
        else {
          
          let _TEMP34 = tYPR_ROTATION(bound1: SDAI.UNWRAP(YPR_INDEX(YAW)), bound2: SDAI.UNWRAP(YPR_INDEX(
            ROLL)), ([SDAI.AIE(tPLANE_ANGLE_MEASURE(0)), 
            SDAI.AIE(tPLANE_ANGLE_MEASURE(0)), 
            SDAI.AIE(RA)] as [SDAI.AggregationInitializerElement<tPLANE_ANGLE_MEASURE>]))
          return _convert_spatial_to_ypr_rotation__cache.updateCache(params: _params, value: _TEMP34)
        }
      }
      else {
        
        let _TEMP35 = DZ > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP35 ) {
          
          let _TEMP36 = tYPR_ROTATION(bound1: SDAI.UNWRAP(YPR_INDEX(YAW)), bound2: SDAI.UNWRAP(YPR_INDEX(
            ROLL)), ([SDAI.AIE(YA), 
            SDAI.AIE(tPLANE_ANGLE_MEASURE(0)), 
            SDAI.AIE(tPLANE_ANGLE_MEASURE(0))] as [SDAI.AggregationInitializerElement<tPLANE_ANGLE_MEASURE>]))
          return _convert_spatial_to_ypr_rotation__cache.updateCache(params: _params, value: _TEMP36)
        }
        else {
          
          let _TEMP37 = tYPR_ROTATION(bound1: SDAI.UNWRAP(YPR_INDEX(YAW)), bound2: SDAI.UNWRAP(YPR_INDEX(
            ROLL)), ([SDAI.AIE(RA), 
            SDAI.AIE(tPLANE_ANGLE_MEASURE(0)), 
            SDAI.AIE(tPLANE_ANGLE_MEASURE(0))] as [SDAI.AggregationInitializerElement<tPLANE_ANGLE_MEASURE>]))
          return _convert_spatial_to_ypr_rotation__cache.updateCache(params: _params, value: _TEMP37)
        }
      }
    }
    
    let _TEMP38 = DY .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    let _TEMP39 = DX .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    let _TEMP40 = _TEMP38 && _TEMP39
    let _TEMP41 = DZ .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    let _TEMP42 = _TEMP40 && _TEMP41
    if SDAI.IS_TRUE( _TEMP42 ) {
      
      let _TEMP43 = C_A >= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP43 ) {
        YA = tPLANE_ANGLE_MEASURE(0)
        RA = tPLANE_ANGLE_MEASURE(0)
      }
      else {
        
        let _TEMP44 = UCF * SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
        YA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP44)
        RA = YA
      }
      
      let _TEMP45 = SDAI.ABS(C_A)
      let _TEMP46 = SDAI.ATAN(V1: S_A, 
                              V2: _TEMP45)
      let _TEMP47 = UCF * _TEMP46
      PA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP47)
      
      let _TEMP48 = DY < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP48 ) {
        PA =  -PA
      }
      
      let _TEMP49 = tYPR_ROTATION(bound1: SDAI.UNWRAP(YPR_INDEX(YAW)), bound2: SDAI.UNWRAP(YPR_INDEX(
        ROLL)), ([SDAI.AIE(YA), SDAI.AIE(PA), 
        SDAI.AIE(RA)] as [SDAI.AggregationInitializerElement<tPLANE_ANGLE_MEASURE>]))
      return _convert_spatial_to_ypr_rotation__cache.updateCache(params: _params, value: _TEMP49)
    }
    
    let _TEMP50 = SDAI.FORCE_OPTIONAL(SDAI.REAL(1.0000000000e+00)) - C_A
    CM1 = _TEMP50
    
    let _TEMP51 = DX * DX
    let _TEMP52 = _TEMP51 * CM1
    let _TEMP53 = _TEMP52 + C_A
    let _TEMP54 = DX * DY
    let _TEMP55 = _TEMP54 * CM1
    let _TEMP56 = DZ * S_A
    let _TEMP57 = _TEMP55 - _TEMP56
    let _TEMP58 = DX * DZ
    let _TEMP59 = _TEMP58 * CM1
    let _TEMP60 = DY * S_A
    let _TEMP61 = _TEMP59 + _TEMP60
    let _TEMP62 = SDAI.ARRAY<SDAI.REAL>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), bound2: SDAI.UNWRAP(SDAI.INTEGER(
      3)), ([SDAI.AIE(_TEMP53), SDAI.AIE(_TEMP57), 
      SDAI.AIE(_TEMP61)] as [SDAI.AggregationInitializerElement<SDAI.REAL>]))
    let _TEMP63 = DX * DY
    let _TEMP64 = _TEMP63 * CM1
    let _TEMP65 = DZ * S_A
    let _TEMP66 = _TEMP64 + _TEMP65
    let _TEMP67 = DY * DY
    let _TEMP68 = _TEMP67 * CM1
    let _TEMP69 = _TEMP68 + C_A
    let _TEMP70 = DY * DZ
    let _TEMP71 = _TEMP70 * CM1
    let _TEMP72 = DX * S_A
    let _TEMP73 = _TEMP71 - _TEMP72
    let _TEMP74 = SDAI.ARRAY<SDAI.REAL>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), bound2: SDAI.UNWRAP(SDAI.INTEGER(
      3)), ([SDAI.AIE(_TEMP66), SDAI.AIE(_TEMP69), 
      SDAI.AIE(_TEMP73)] as [SDAI.AggregationInitializerElement<SDAI.REAL>]))
    let _TEMP75 = DX * DZ
    let _TEMP76 = _TEMP75 * CM1
    let _TEMP77 = DY * S_A
    let _TEMP78 = _TEMP76 - _TEMP77
    let _TEMP79 = DY * DZ
    let _TEMP80 = _TEMP79 * CM1
    let _TEMP81 = DX * S_A
    let _TEMP82 = _TEMP80 + _TEMP81
    let _TEMP83 = DZ * DZ
    let _TEMP84 = _TEMP83 * CM1
    let _TEMP85 = _TEMP84 + C_A
    let _TEMP86 = SDAI.ARRAY<SDAI.REAL>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), bound2: SDAI.UNWRAP(SDAI.INTEGER(
      3)), ([SDAI.AIE(_TEMP78), SDAI.AIE(_TEMP82), 
      SDAI.AIE(_TEMP85)] as [SDAI.AggregationInitializerElement<SDAI.REAL>]))
    let _TEMP87 = SDAI.ARRAY<SDAI.ARRAY<SDAI.REAL>>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), 
      bound2: SDAI.UNWRAP(SDAI.INTEGER(3)), 
      ([SDAI.AIE(_TEMP62), SDAI.AIE(_TEMP74), 
      SDAI.AIE(_TEMP86)] as [SDAI.AggregationInitializerElement<SDAI.ARRAY<SDAI.REAL>>]))
    ROTMAT = _TEMP87
    
    let _TEMP88 = ROTMAT?[1]
    let _TEMP89 = _TEMP88?[3]
    let _TEMP90 = SDAI.ABS(_TEMP89)
    let _TEMP91 = _TEMP90 .==. SDAI.FORCE_OPTIONAL(SDAI.REAL(1.0000000000e+00))
    if SDAI.IS_TRUE( _TEMP91 ) {
      //BEGIN
      
      let _TEMP92 = ROTMAT?[1]
      let _TEMP93 = _TEMP92?[3]
      let _TEMP94 = _TEMP93 .==. SDAI.FORCE_OPTIONAL(SDAI.REAL(1.0000000000e+00))
      if SDAI.IS_TRUE( _TEMP94 ) {
        
        let _TEMP95 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
        PA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP95)
      }
      else {
        
        let _TEMP96 = SDAI.REAL( -5.0000000000e-01) * SDAI.REAL(SDAI.PI)
        PA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP96)
      }
      RA = tPLANE_ANGLE_MEASURE(0)
      
      let _TEMP97 = ROTMAT?[2]
      let _TEMP98 = _TEMP97?[1]
      let _TEMP99 = ROTMAT?[2]
      let _TEMP100 = _TEMP99?[2]
      let _TEMP101 = SDAI.ATAN(V1: _TEMP98, 
                               V2: _TEMP100)
      YA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP101)
      
      let _TEMP102 = ROTMAT?[2]
      let _TEMP103 = _TEMP102?[2]
      let _TEMP104 = _TEMP103 < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP104 ) {
        
        let _TEMP105 = YA <= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP105 ) {
          
          let _TEMP106 = YA + SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
          YA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP106)
        }
        else {
          
          let _TEMP107 = YA - SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
          YA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP107)
        }
      }
      //END
    }
    else {
      //BEGIN
      
      let _TEMP108 = ROTMAT?[1]
      let _TEMP109 = _TEMP108?[2]
      let _TEMP110 =  -_TEMP109
      let _TEMP111 = ROTMAT?[1]
      let _TEMP112 = _TEMP111?[1]
      let _TEMP113 = SDAI.ATAN(V1: _TEMP110, 
                               V2: _TEMP112)
      YA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP113)
      
      let _TEMP114 = ROTMAT?[1]
      let _TEMP115 = _TEMP114?[1]
      let _TEMP116 = _TEMP115 < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP116 ) {
        
        let _TEMP117 = YA <= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP117 ) {
          
          let _TEMP118 = YA + SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
          YA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP118)
        }
        else {
          
          let _TEMP119 = YA - SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
          YA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP119)
        }
      }
      
      let _TEMP120 = ROTMAT?[2]
      let _TEMP121 = _TEMP120?[3]
      let _TEMP122 =  -_TEMP121
      let _TEMP123 = ROTMAT?[3]
      let _TEMP124 = _TEMP123?[3]
      let _TEMP125 = SDAI.ATAN(V1: _TEMP122, 
                               V2: _TEMP124)
      RA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP125)
      
      let _TEMP126 = ROTMAT?[3]
      let _TEMP127 = _TEMP126?[3]
      let _TEMP128 = _TEMP127 < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP128 ) {
        
        let _TEMP129 = RA <= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP129 ) {
          
          let _TEMP130 = RA + SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
          RA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP130)
        }
        else {
          
          let _TEMP131 = RA - SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
          RA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP131)
        }
      }
      
      let _TEMP132 = SDAI.SIN(YA)
      S_Y = _TEMP132
      
      let _TEMP133 = SDAI.COS(YA)
      C_Y = _TEMP133
      
      let _TEMP134 = SDAI.SIN(RA)
      S_R = _TEMP134
      
      let _TEMP135 = SDAI.COS(RA)
      C_R = _TEMP135
      
      let _TEMP136 = SDAI.ABS(S_Y)
      let _TEMP137 = SDAI.ABS(C_Y)
      let _TEMP138 = _TEMP136 > _TEMP137
      let _TEMP139 = SDAI.ABS(S_Y)
      let _TEMP140 = SDAI.ABS(S_R)
      let _TEMP141 = _TEMP139 > _TEMP140
      let _TEMP142 = _TEMP138 && _TEMP141
      let _TEMP143 = SDAI.ABS(S_Y)
      let _TEMP144 = SDAI.ABS(C_R)
      let _TEMP145 = _TEMP143 > _TEMP144
      let _TEMP146 = _TEMP142 && _TEMP145
      if SDAI.IS_TRUE( _TEMP146 ) {
        
        let _TEMP147 = ROTMAT?[1]
        let _TEMP148 = _TEMP147?[2]
        let _TEMP149 =  -_TEMP148
        let _TEMP150 = _TEMP149 / S_Y
        CM1 = _TEMP150
      }
      else {
        
        let _TEMP151 = SDAI.ABS(C_Y)
        let _TEMP152 = SDAI.ABS(S_R)
        let _TEMP153 = _TEMP151 > _TEMP152
        let _TEMP154 = SDAI.ABS(C_Y)
        let _TEMP155 = SDAI.ABS(C_R)
        let _TEMP156 = _TEMP154 > _TEMP155
        let _TEMP157 = _TEMP153 && _TEMP156
        if SDAI.IS_TRUE( _TEMP157 ) {
          
          let _TEMP158 = ROTMAT?[1]
          let _TEMP159 = _TEMP158?[1]
          let _TEMP160 = _TEMP159 / C_Y
          CM1 = _TEMP160
        }
        else {
          
          let _TEMP161 = SDAI.ABS(S_R)
          let _TEMP162 = SDAI.ABS(C_R)
          let _TEMP163 = _TEMP161 > _TEMP162
          if SDAI.IS_TRUE( _TEMP163 ) {
            
            let _TEMP164 = ROTMAT?[2]
            let _TEMP165 = _TEMP164?[3]
            let _TEMP166 =  -_TEMP165
            let _TEMP167 = _TEMP166 / S_R
            CM1 = _TEMP167
          }
          else {
            
            let _TEMP168 = ROTMAT?[3]
            let _TEMP169 = _TEMP168?[3]
            let _TEMP170 = _TEMP169 / C_R
            CM1 = _TEMP170
          }
        }
      }
      
      let _TEMP171 = ROTMAT?[1]
      let _TEMP172 = _TEMP171?[3]
      let _TEMP173 = SDAI.ATAN(V1: _TEMP172, 
                               V2: CM1)
      PA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP173)
      //END
    }
    
    let _TEMP174 = YA * UCF
    YA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP174)
    
    let _TEMP175 = PA * UCF
    PA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP175)
    
    let _TEMP176 = RA * UCF
    RA = tPLANE_ANGLE_MEASURE(/*SDAI.REAL*/_TEMP176)
    
    let _TEMP177 = tYPR_ROTATION(bound1: SDAI.UNWRAP(YPR_INDEX(YAW)), bound2: SDAI.UNWRAP(YPR_INDEX(
      ROLL)), ([SDAI.AIE(YA), SDAI.AIE(PA), 
      SDAI.AIE(RA)] as [SDAI.AggregationInitializerElement<tPLANE_ANGLE_MEASURE>]))
    return _convert_spatial_to_ypr_rotation__cache.updateCache(params: _params, value: _TEMP177)
  }

}

//MARK: - function result cache
private var _convert_spatial_to_ypr_rotation__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

