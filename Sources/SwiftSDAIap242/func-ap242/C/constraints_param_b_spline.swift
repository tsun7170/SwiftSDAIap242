/* file: constraints_param_b_spline.swift 	 generated: Sun Oct 31 15:32:10 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION constraints_param_b_spline(
               degree : INTEGER;
               up_knots : INTEGER;
               up_cp : INTEGER;
               knot_mult : LIST [0 : ?] OF INTEGER;
               knots : LIST [0 : ?] OF parameter_value
           ) : BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
      k      : INTEGER;
      sum    : INTEGER;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF ( degree < 1 ) OR ( up_knots < 2 ) OR ( up_cp < degree ) OR ( sum <> ( degree + up_cp + 2 ) ) THEN
      result := FALSE;
      RETURN( result );
    END_IF;
    k := knot_mult[1];
    IF ( k < 1 ) OR ( k > ( degree + 1 ) ) THEN
      result := FALSE;
      RETURN( result );
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF ( knot_mult[i] < 1 ) OR ( knots[i] <= knots[i - 1] ) THEN
        result := FALSE;
        RETURN( result );
      END_IF;
      k := knot_mult[i];
      IF ( i < up_knots ) AND ( k > degree ) THEN
        result := FALSE;
        RETURN( result );
      END_IF;
      IF ( i = up_knots ) AND ( k > ( degree + 1 ) ) THEN
        result := FALSE;
        RETURN( result );
      END_IF;
    END_REPEAT;
    RETURN( result );

  END_FUNCTION; -- constraints_param_b_spline (line:36786 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func CONSTRAINTS_PARAM_B_SPLINE(DEGREE: SDAI.INTEGER? , UP_KNOTS: SDAI.INTEGER? , 
                                  UP_CP: SDAI.INTEGER? , KNOT_MULT: (SDAI.LIST<SDAI.INTEGER>/*[0:nil]*/ )? , 
                                  KNOTS: (SDAI.LIST<tPARAMETER_VALUE>/*[0:nil]*/ )? ) 
    -> SDAI.BOOLEAN? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( DEGREE, UP_KNOTS, UP_CP, KNOT_MULT, 
      KNOTS )
    if case .available(let _cached_value) = _constraints_param_b_spline__cache.cachedValue(params: _params) {
      return _cached_value as? SDAI.BOOLEAN
    }

    var DEGREE = DEGREE; SDAI.TOUCH(var: &DEGREE)
    var UP_KNOTS = UP_KNOTS; SDAI.TOUCH(var: &UP_KNOTS)
    var UP_CP = UP_CP; SDAI.TOUCH(var: &UP_CP)
    var KNOT_MULT = KNOT_MULT; SDAI.TOUCH(var: &KNOT_MULT)
    var KNOTS = KNOTS; SDAI.TOUCH(var: &KNOTS)

    //LOCAL
    var RESULT: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.TRUE); SDAI.TOUCH(var: &RESULT)
    var K: SDAI.INTEGER? 
    var SUM: SDAI.INTEGER? 
    //END_LOCAL

    
    let _TEMP1 = KNOT_MULT?[1]
    SUM = _TEMP1
    if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/2, TO:/*SDAI.INTEGER*/UP_KNOTS) {
      for I in incrementControl {
        
        let _TEMP2 = KNOT_MULT?[I]
        let _TEMP3 = SUM + _TEMP2
        SUM = _TEMP3
      }
    }
    
    let _TEMP4 = DEGREE < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    let _TEMP5 = UP_KNOTS < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
    let _TEMP6 = _TEMP4 || _TEMP5
    let _TEMP7 = UP_CP < DEGREE
    let _TEMP8 = _TEMP6 || _TEMP7
    let _TEMP9 = DEGREE + UP_CP
    let _TEMP10 = _TEMP9 + SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
    let _TEMP11 = SUM .!=. _TEMP10
    let _TEMP12 = _TEMP8 || _TEMP11
    if SDAI.IS_TRUE( _TEMP12 ) {
      RESULT = SDAI.BOOLEAN(SDAI.FALSE)
      return _constraints_param_b_spline__cache.updateCache(params: _params, value: RESULT)
    }
    
    let _TEMP13 = KNOT_MULT?[1]
    K = _TEMP13
    
    let _TEMP14 = K < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    let _TEMP15 = DEGREE + SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    let _TEMP16 = K > _TEMP15
    let _TEMP17 = _TEMP14 || _TEMP16
    if SDAI.IS_TRUE( _TEMP17 ) {
      RESULT = SDAI.BOOLEAN(SDAI.FALSE)
      return _constraints_param_b_spline__cache.updateCache(params: _params, value: RESULT)
    }
    if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/2, TO:/*SDAI.INTEGER*/UP_KNOTS) {
      for I in incrementControl {
        
        let _TEMP18 = KNOT_MULT?[I]
        let _TEMP19 = _TEMP18 < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
        let _TEMP20 = KNOTS?[I]
        let _TEMP21 = SDAI.FORCE_OPTIONAL(I) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
        let _TEMP22 = KNOTS?[_TEMP21]
        let _TEMP23 = _TEMP20 <= _TEMP22
        let _TEMP24 = _TEMP19 || _TEMP23
        if SDAI.IS_TRUE( _TEMP24 ) {
          RESULT = SDAI.BOOLEAN(SDAI.FALSE)
          return _constraints_param_b_spline__cache.updateCache(params: _params, value: RESULT)
        }
        
        let _TEMP25 = KNOT_MULT?[I]
        K = _TEMP25
        
        let _TEMP26 = SDAI.FORCE_OPTIONAL(I) < UP_KNOTS
        let _TEMP27 = K > DEGREE
        let _TEMP28 = _TEMP26 && _TEMP27
        if SDAI.IS_TRUE( _TEMP28 ) {
          RESULT = SDAI.BOOLEAN(SDAI.FALSE)
          return _constraints_param_b_spline__cache.updateCache(params: _params, value: RESULT)
        }
        
        let _TEMP29 = SDAI.FORCE_OPTIONAL(I) .==. UP_KNOTS
        let _TEMP30 = DEGREE + SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
        let _TEMP31 = K > _TEMP30
        let _TEMP32 = _TEMP29 && _TEMP31
        if SDAI.IS_TRUE( _TEMP32 ) {
          RESULT = SDAI.BOOLEAN(SDAI.FALSE)
          return _constraints_param_b_spline__cache.updateCache(params: _params, value: RESULT)
        }
      }
    }
    return _constraints_param_b_spline__cache.updateCache(params: _params, value: RESULT)
  }

}

//MARK: - function result cache
private var _constraints_param_b_spline__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

