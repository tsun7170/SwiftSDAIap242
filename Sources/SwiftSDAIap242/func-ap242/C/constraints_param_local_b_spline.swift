/* file: constraints_param_local_b_spline.swift 	 generated: Tue Nov 16 05:35:44 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION constraints_param_local_b_spline(
               degree : INTEGER;
               knot_mult : LIST OF INTEGER;
               knots : LIST OF INTEGER
           ) : BOOLEAN;

    LOCAL
      result   : BOOLEAN := TRUE;
      k        : INTEGER;
      up_knots : INTEGER;
      sum      : INTEGER;
    END_LOCAL;
    up_knots := SIZEOF( knots );
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF ( degree < 1 ) OR ( up_knots < 2 ) OR ( sum <> ( degree + 2 ) ) THEN
      result := FALSE;
      RETURN( result );
    END_IF;
    k := knot_mult[1];
    IF ( k < 1 ) OR ( k > ( degree + 1 ) ) THEN
      result := FALSE;
      RETURN( result );
    END_IF;
    IF knots[1] < 1 THEN
      result := FALSE;
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF ( knot_mult[i] < 1 ) OR ( knots[i] <= knots[i - 1] ) THEN
        result := FALSE;
        RETURN( result );
      END_IF;
      k := knot_mult[i];
      IF ( i < up_knots ) AND ( k > degree ) THEN
        result := FALSE;
        RETURN( result );
      END_IF;
      IF ( i = up_knots ) AND ( k > ( degree + 1 ) ) THEN
        result := FALSE;
        RETURN( result );
      END_IF;
    END_REPEAT;
    RETURN( result );

  END_FUNCTION; -- constraints_param_local_b_spline (line:36848 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func CONSTRAINTS_PARAM_LOCAL_B_SPLINE(
    DEGREE: SDAI.INTEGER? , KNOT_MULT: SDAI.LIST<SDAI.INTEGER>? , KNOTS: SDAI.LIST<SDAI.INTEGER>? ) 
    -> SDAI.BOOLEAN? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( DEGREE, KNOT_MULT, KNOTS )
    if case .available(let _cached_value) = _constraints_param_local_b_spline__cache.cachedValue(params: _params) {
      return _cached_value as? SDAI.BOOLEAN
    }

    var DEGREE = DEGREE; SDAI.TOUCH(var: &DEGREE)
    var KNOT_MULT = KNOT_MULT; SDAI.TOUCH(var: &KNOT_MULT)
    var KNOTS = KNOTS; SDAI.TOUCH(var: &KNOTS)

    //LOCAL
    var RESULT: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.TRUE); SDAI.TOUCH(var: &RESULT)
    var K: SDAI.INTEGER? 
    var UP_KNOTS: SDAI.INTEGER? 
    var SUM: SDAI.INTEGER? 
    //END_LOCAL

    
    let _TEMP1 = SDAI.SIZEOF(KNOTS)
    UP_KNOTS = _TEMP1
    
    let _TEMP2 = KNOT_MULT?[1]
    SUM = _TEMP2
    if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/2, TO:/*SDAI.INTEGER*/UP_KNOTS) {
      for I in incrementControl {
        
        let _TEMP3 = KNOT_MULT?[I]
        let _TEMP4 = SUM + _TEMP3
        SUM = _TEMP4
      }
    }
    
    let _TEMP5 = DEGREE < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    let _TEMP6 = UP_KNOTS < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
    let _TEMP7 = _TEMP5 || _TEMP6
    let _TEMP8 = DEGREE + SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
    let _TEMP9 = SUM .!=. _TEMP8
    let _TEMP10 = _TEMP7 || _TEMP9
    if SDAI.IS_TRUE( _TEMP10 ) {
      RESULT = SDAI.BOOLEAN(SDAI.FALSE)
      return _constraints_param_local_b_spline__cache.updateCache(params: _params, value: RESULT)
    }
    
    let _TEMP11 = KNOT_MULT?[1]
    K = _TEMP11
    
    let _TEMP12 = K < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    let _TEMP13 = DEGREE + SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    let _TEMP14 = K > _TEMP13
    let _TEMP15 = _TEMP12 || _TEMP14
    if SDAI.IS_TRUE( _TEMP15 ) {
      RESULT = SDAI.BOOLEAN(SDAI.FALSE)
      return _constraints_param_local_b_spline__cache.updateCache(params: _params, value: RESULT)
    }
    
    let _TEMP16 = KNOTS?[1]
    let _TEMP17 = _TEMP16 < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    if SDAI.IS_TRUE( _TEMP17 ) {
      RESULT = SDAI.BOOLEAN(SDAI.FALSE)
    }
    if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/2, TO:/*SDAI.INTEGER*/UP_KNOTS) {
      for I in incrementControl {
        
        let _TEMP18 = KNOT_MULT?[I]
        let _TEMP19 = _TEMP18 < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
        let _TEMP20 = KNOTS?[I]
        let _TEMP21 = SDAI.FORCE_OPTIONAL(I) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
        let _TEMP22 = KNOTS?[_TEMP21]
        let _TEMP23 = _TEMP20 <= _TEMP22
        let _TEMP24 = _TEMP19 || _TEMP23
        if SDAI.IS_TRUE( _TEMP24 ) {
          RESULT = SDAI.BOOLEAN(SDAI.FALSE)
          return _constraints_param_local_b_spline__cache.updateCache(params: _params, value: RESULT)
        }
        
        let _TEMP25 = KNOT_MULT?[I]
        K = _TEMP25
        
        let _TEMP26 = SDAI.FORCE_OPTIONAL(I) < UP_KNOTS
        let _TEMP27 = K > DEGREE
        let _TEMP28 = _TEMP26 && _TEMP27
        if SDAI.IS_TRUE( _TEMP28 ) {
          RESULT = SDAI.BOOLEAN(SDAI.FALSE)
          return _constraints_param_local_b_spline__cache.updateCache(params: _params, value: RESULT)
        }
        
        let _TEMP29 = SDAI.FORCE_OPTIONAL(I) .==. UP_KNOTS
        let _TEMP30 = DEGREE + SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
        let _TEMP31 = K > _TEMP30
        let _TEMP32 = _TEMP29 && _TEMP31
        if SDAI.IS_TRUE( _TEMP32 ) {
          RESULT = SDAI.BOOLEAN(SDAI.FALSE)
          return _constraints_param_local_b_spline__cache.updateCache(params: _params, value: RESULT)
        }
      }
    }
    return _constraints_param_local_b_spline__cache.updateCache(params: _params, value: RESULT)
  }

}

//MARK: - function result cache
private var _constraints_param_local_b_spline__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

