/* file: compatible_spaces.swift 	 generated: Sun Oct 31 15:32:10 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION compatible_spaces(
               sp1, sp2 : maths_space
           ) : BOOLEAN;

    LOCAL
      types1 : SET OF STRING := stripped_typeof( sp1 );
      types2 : SET OF STRING := stripped_typeof( sp2 );
      lgcl   : LOGICAL := UNKNOWN;
      m      : INTEGER;
      n      : INTEGER;
      s1     : maths_space;
      s2     : maths_space;
    END_LOCAL;
    IF 'FINITE_SPACE' IN types1 THEN
      REPEAT i := 1 TO SIZEOF( sp1\finite_space.members ) BY 1;
        lgcl := member_of( sp1\finite_space.members[i], sp2 );
        IF lgcl <> FALSE THEN
          RETURN( TRUE );
        END_IF;
      END_REPEAT;
      RETURN( FALSE );
    END_IF;
    IF 'FINITE_SPACE' IN types2 THEN
      REPEAT i := 1 TO SIZEOF( sp2\finite_space.members ) BY 1;
        lgcl := member_of( sp2\finite_space.members[i], sp1 );
        IF lgcl <> FALSE THEN
          RETURN( TRUE );
        END_IF;
      END_REPEAT;
      RETURN( FALSE );
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types1 THEN
      IF sp1\elementary_space.space_id = es_generics THEN
        RETURN( TRUE );
      END_IF;
      IF 'ELEMENTARY_SPACE' IN types2 THEN
        RETURN( compatible_es_values( sp1\elementary_space.space_id, sp2\elementary_space.space_id ) );
      END_IF;
      IF ( 'FINITE_INTEGER_INTERVAL' IN types2 ) OR ( 'INTEGER_INTERVAL_FROM_MIN' IN types2 ) OR ( 
          'INTEGER_INTERVAL_TO_MAX'  IN types2 ) THEN
        RETURN( compatible_es_values( sp1\elementary_space.space_id, es_integers ) );
      END_IF;
      IF ( 'FINITE_REAL_INTERVAL' IN types2 ) OR ( 'REAL_INTERVAL_FROM_MIN' IN types2 ) OR ( 
          'REAL_INTERVAL_TO_MAX'  IN types2 ) THEN
        RETURN( compatible_es_values( sp1\elementary_space.space_id, es_reals ) );
      END_IF;
      IF ( 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 ) OR ( 'POLAR_COMPLEX_NUMBER_REGION' IN types2 ) THEN
        RETURN( compatible_es_values( sp1\elementary_space.space_id, es_complex_numbers ) );
      END_IF;
      IF 'TUPLE_SPACE' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      IF 'FUNCTION_SPACE' IN types2 THEN
        RETURN( bool( sp1\elementary_space.space_id = es_maths_functions ) );
      END_IF;
      RETURN( TRUE );
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      IF sp2\elementary_space.space_id = es_generics THEN
        RETURN( TRUE );
      END_IF;
      IF ( 'FINITE_INTEGER_INTERVAL' IN types1 ) OR ( 'INTEGER_INTERVAL_FROM_MIN' IN types1 ) OR ( 
          'INTEGER_INTERVAL_TO_MAX'  IN types1 ) THEN
        RETURN( compatible_es_values( sp2\elementary_space.space_id, es_integers ) );
      END_IF;
      IF ( 'FINITE_REAL_INTERVAL' IN types1 ) OR ( 'REAL_INTERVAL_FROM_MIN' IN types1 ) OR ( 
          'REAL_INTERVAL_TO_MAX'  IN types1 ) THEN
        RETURN( compatible_es_values( sp2\elementary_space.space_id, es_reals ) );
      END_IF;
      IF ( 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 ) OR ( 'POLAR_COMPLEX_NUMBER_REGION' IN types1 ) THEN
        RETURN( compatible_es_values( sp2\elementary_space.space_id, es_complex_numbers ) );
      END_IF;
      IF 'TUPLE_SPACE' IN types1 THEN
        RETURN( FALSE );
      END_IF;
      IF 'FUNCTION_SPACE' IN types1 THEN
        RETURN( bool( sp2\elementary_space.space_id = es_maths_functions ) );
      END_IF;
      RETURN( TRUE );
    END_IF;
    IF subspace_of_es( sp1, es_integers ) THEN
      IF subspace_of_es( sp2, es_integers ) THEN
        RETURN( compatible_intervals( sp1, sp2 ) );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF subspace_of_es( sp2, es_integers ) THEN
      RETURN( FALSE );
    END_IF;
    IF subspace_of_es( sp1, es_reals ) THEN
      IF subspace_of_es( sp2, es_reals ) THEN
        RETURN( compatible_intervals( sp1, sp2 ) );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF subspace_of_es( sp2, es_reals ) THEN
      RETURN( FALSE );
    END_IF;
    IF subspace_of_es( sp1, es_complex_numbers ) THEN
      IF subspace_of_es( sp2, es_complex_numbers ) THEN
        RETURN( compatible_complex_number_regions( sp1, sp2 ) );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF subspace_of_es( sp2, es_complex_numbers ) THEN
      RETURN( FALSE );
    END_IF;
    IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
      IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
        IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent THEN
          RETURN( FALSE );
        END_IF;
        RETURN( compatible_spaces( sp1\uniform_product_space.base, sp2\uniform_product_space.base ) );
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
        n := SIZEOF( sp2\listed_product_space.factors );
        IF sp1\uniform_product_space.exponent <> n THEN
          RETURN( FALSE );
        END_IF;
        REPEAT i := 1 TO n BY 1;
          IF NOT compatible_spaces( sp1\uniform_product_space.base, sp2\listed_product_space.factors[i] )
              THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        RETURN( TRUE );
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
        m := sp1\uniform_product_space.exponent;
        n := space_dimension( sp2\extended_tuple_space.base );
        IF m < n THEN
          RETURN( FALSE );
        END_IF;
        IF m = n THEN
          RETURN( compatible_spaces( sp1, sp2\extended_tuple_space.base ) );
        END_IF;
        RETURN( compatible_spaces( sp1, assoc_product_space( sp2\extended_tuple_space.base, 
            make_uniform_product_space( sp2\extended_tuple_space.extender, m - n ) ) ) );
      END_IF;
      IF 'FUNCTION_SPACE' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      RETURN( TRUE );
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
      n := SIZEOF( sp1\listed_product_space.factors );
      IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
        IF n <> sp2\uniform_product_space.exponent THEN
          RETURN( FALSE );
        END_IF;
        REPEAT i := 1 TO n BY 1;
          IF NOT compatible_spaces( sp2\uniform_product_space.base, sp1\listed_product_space.factors[i] )
              THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        RETURN( TRUE );
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
        IF n <> SIZEOF( sp2\listed_product_space.factors ) THEN
          RETURN( FALSE );
        END_IF;
        REPEAT i := 1 TO n BY 1;
          IF NOT compatible_spaces( sp1\listed_product_space.factors[i], sp2\listed_product_space.factors[i] )
              THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        RETURN( TRUE );
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
        m := space_dimension( sp2\extended_tuple_space.base );
        IF n < m THEN
          RETURN( FALSE );
        END_IF;
        IF n = m THEN
          RETURN( compatible_spaces( sp1, sp2\extended_tuple_space.base ) );
        END_IF;
        RETURN( compatible_spaces( sp1, assoc_product_space( sp2\extended_tuple_space.base, 
            make_uniform_product_space( sp2\extended_tuple_space.extender, n - m ) ) ) );
      END_IF;
      IF ( schema_prefix + 'FUNCTION_SPACE' ) IN types2 THEN
        RETURN( FALSE );
      END_IF;
      RETURN( TRUE );
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
      IF ( 'UNIFORM_PRODUCT_SPACE' IN types2 ) OR ( 'LISTED_PRODUCT_SPACE' IN types2 ) THEN
        RETURN( compatible_spaces( sp2, sp1 ) );
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
        IF NOT compatible_spaces( sp1\extended_tuple_space.extender, sp2\extended_tuple_space.extender )
            THEN
          RETURN( FALSE );
        END_IF;
        n := space_dimension( sp1\extended_tuple_space.base );
        m := space_dimension( sp2\extended_tuple_space.base );
        IF n < m THEN
          RETURN( compatible_spaces( assoc_product_space( sp1\extended_tuple_space.base, 
              make_uniform_product_space( sp1\extended_tuple_space.extender, m - n ) ), sp2\
              extended_tuple_space.base ) );
        END_IF;
        IF n = m THEN
          RETURN( compatible_spaces( sp1\extended_tuple_space.base, sp2\extended_tuple_space.base ) );
        END_IF;
        IF n > m THEN
          RETURN( compatible_spaces( sp1\extended_tuple_space.base, assoc_product_space( sp2\
              extended_tuple_space.base, make_uniform_product_space( sp2\extended_tuple_space.extender, n - m ) ) ) );
        END_IF;
      END_IF;
      IF 'FUNCTION_SPACE' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      RETURN( TRUE );
    END_IF;
    IF 'FUNCTION_SPACE' IN types1 THEN
      IF 'FUNCTION_SPACE' IN types2 THEN
        s1 := sp1\function_space.domain_argument;
        s2 := sp2\function_space.domain_argument;
        CASE sp1\function_space.domain_constraint OF
          sc_equal                  : 
            BEGIN
              CASE sp2\function_space.domain_constraint OF
                sc_equal                  :                   lgcl := subspace_of( s1, s2 ) AND subspace_of( 
                      s2, s1 );
                sc_subspace               :                   lgcl := subspace_of( s1, s2 );
                sc_member                 :                   lgcl := member_of( s1, s2 );
              END_CASE;
            END;
          sc_subspace               : 
            BEGIN
              CASE sp2\function_space.domain_constraint OF
                sc_equal                  :                   lgcl := subspace_of( s2, s1 );
                sc_subspace               :                   lgcl := compatible_spaces( s1, s2 );
                sc_member                 :                   lgcl := UNKNOWN;
              END_CASE;
            END;
          sc_member                 : 
            BEGIN
              CASE sp2\function_space.domain_constraint OF
                sc_equal                  :                   lgcl := member_of( s2, s1 );
                sc_subspace               :                   lgcl := UNKNOWN;
                sc_member                 :                   lgcl := compatible_spaces( s1, s2 );
              END_CASE;
            END;
        END_CASE;
        IF lgcl = FALSE THEN
          RETURN( FALSE );
        END_IF;
        s1 := sp1\function_space.range_argument;
        s2 := sp2\function_space.range_argument;
        CASE sp1\function_space.range_constraint OF
          sc_equal                  : 
            BEGIN
              CASE sp2\function_space.range_constraint OF
                sc_equal                  :                   lgcl := subspace_of( s1, s2 ) AND subspace_of( 
                      s2, s1 );
                sc_subspace               :                   lgcl := subspace_of( s1, s2 );
                sc_member                 :                   lgcl := member_of( s1, s2 );
              END_CASE;
            END;
          sc_subspace               : 
            BEGIN
              CASE sp2\function_space.range_constraint OF
                sc_equal                  :                   lgcl := subspace_of( s2, s1 );
                sc_subspace               :                   lgcl := compatible_spaces( s1, s2 );
                sc_member                 :                   lgcl := UNKNOWN;
              END_CASE;
            END;
          sc_member                 : 
            BEGIN
              CASE sp2\function_space.range_constraint OF
                sc_equal                  :                   lgcl := member_of( s2, s1 );
                sc_subspace               :                   lgcl := UNKNOWN;
                sc_member                 :                   lgcl := compatible_spaces( s1, s2 );
              END_CASE;
            END;
        END_CASE;
        IF lgcl = FALSE THEN
          RETURN( FALSE );
        END_IF;
        RETURN( TRUE );
      END_IF;
      RETURN( TRUE );
    END_IF;
    RETURN( TRUE );

  END_FUNCTION; -- compatible_spaces (line:36340 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func COMPATIBLE_SPACES(SP1: eMATHS_SPACE? , SP2: eMATHS_SPACE? ) 
    -> SDAI.BOOLEAN? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( SP1, SP2 )
    if case .available(let _cached_value) = _compatible_spaces__cache.cachedValue(params: _params) {
      return _cached_value as? SDAI.BOOLEAN
    }

    var SP1 = SP1; SDAI.TOUCH(var: &SP1)
    var SP2 = SP2; SDAI.TOUCH(var: &SP2)

    //LOCAL
    var TYPES1: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(SP1); SDAI.TOUCH(var: &TYPES1)
    var TYPES2: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(SP2); SDAI.TOUCH(var: &TYPES2)
    var LGCL: SDAI.LOGICAL = SDAI.LOGICAL(SDAI.UNKNOWN); SDAI.TOUCH(var: &LGCL)
    var M: SDAI.INTEGER? 
    var N: SDAI.INTEGER? 
    var S1: eMATHS_SPACE? 
    var S2: eMATHS_SPACE? 
    //END_LOCAL

    
    let _TEMP1 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("FINITE_SPACE"))
    if SDAI.IS_TRUE( _TEMP1 ) {
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        SP1?.GROUP_REF(eFINITE_SPACE.self)?.MEMBERS)) {
        for I in incrementControl {
          
          let _TEMP2 = SP1?.GROUP_REF(eFINITE_SPACE.self)
          let _TEMP3 = _TEMP2?.MEMBERS
          let _TEMP4 = _TEMP3?[I]
          let _TEMP5 = MEMBER_OF(VAL: _TEMP4, 
                                 SPC: SP2)
          LGCL = SDAI.UNWRAP(_TEMP5)
          
          let _TEMP6 = SDAI.FORCE_OPTIONAL(LGCL) .!=. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
          if SDAI.IS_TRUE( _TEMP6 ) {
            return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
          }
        }
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP7 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("FINITE_SPACE"))
    if SDAI.IS_TRUE( _TEMP7 ) {
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        SP2?.GROUP_REF(eFINITE_SPACE.self)?.MEMBERS)) {
        for I in incrementControl {
          
          let _TEMP8 = SP2?.GROUP_REF(eFINITE_SPACE.self)
          let _TEMP9 = _TEMP8?.MEMBERS
          let _TEMP10 = _TEMP9?[I]
          let _TEMP11 = MEMBER_OF(VAL: _TEMP10, 
                                  SPC: SP1)
          LGCL = SDAI.UNWRAP(_TEMP11)
          
          let _TEMP12 = SDAI.FORCE_OPTIONAL(LGCL) .!=. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
          if SDAI.IS_TRUE( _TEMP12 ) {
            return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
          }
        }
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP13 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("ELEMENTARY_SPACE"))
    if SDAI.IS_TRUE( _TEMP13 ) {
      
      let _TEMP14 = SP1?.GROUP_REF(eELEMENTARY_SPACE.self)
      let _TEMP15 = _TEMP14?.SPACE_ID
      let _TEMP16 = _TEMP15 .==. SDAI.FORCE_OPTIONAL(ES_GENERICS)
      if SDAI.IS_TRUE( _TEMP16 ) {
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
      }
      
      let _TEMP17 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      if SDAI.IS_TRUE( _TEMP17 ) {
        
        let _TEMP18 = SP1?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP19 = _TEMP18?.SPACE_ID
        let _TEMP20 = SP2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP21 = _TEMP20?.SPACE_ID
        let _TEMP22 = COMPATIBLE_ES_VALUES(
          ESVAL1: _TEMP19, ESVAL2: _TEMP21)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP22)
      }
      
      let _TEMP23 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("FINITE_INTEGER_INTERVAL"))
      let _TEMP24 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("INTEGER_INTERVAL_FROM_MIN"))
      let _TEMP25 = _TEMP23 || _TEMP24
      let _TEMP26 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("INTEGER_INTERVAL_TO_MAX"))
      let _TEMP27 = _TEMP25 || _TEMP26
      if SDAI.IS_TRUE( _TEMP27 ) {
        
        let _TEMP28 = SP1?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP29 = _TEMP28?.SPACE_ID
        let _TEMP30 = COMPATIBLE_ES_VALUES(
          ESVAL1: _TEMP29, ESVAL2: ES_INTEGERS)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP30)
      }
      
      let _TEMP31 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("FINITE_REAL_INTERVAL"))
      let _TEMP32 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("REAL_INTERVAL_FROM_MIN"))
      let _TEMP33 = _TEMP31 || _TEMP32
      let _TEMP34 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("REAL_INTERVAL_TO_MAX"))
      let _TEMP35 = _TEMP33 || _TEMP34
      if SDAI.IS_TRUE( _TEMP35 ) {
        
        let _TEMP36 = SP1?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP37 = _TEMP36?.SPACE_ID
        let _TEMP38 = COMPATIBLE_ES_VALUES(
          ESVAL1: _TEMP37, ESVAL2: ES_REALS)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP38)
      }
      
      let _TEMP39 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("CARTESIAN_COMPLEX_NUMBER_REGION"))
      let _TEMP40 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("POLAR_COMPLEX_NUMBER_REGION"))
      let _TEMP41 = _TEMP39 || _TEMP40
      if SDAI.IS_TRUE( _TEMP41 ) {
        
        let _TEMP42 = SP1?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP43 = _TEMP42?.SPACE_ID
        let _TEMP44 = COMPATIBLE_ES_VALUES(
          ESVAL1: _TEMP43, ESVAL2: ES_COMPLEX_NUMBERS)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP44)
      }
      
      let _TEMP45 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("TUPLE_SPACE"))
      if SDAI.IS_TRUE( _TEMP45 ) {
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
      }
      
      let _TEMP46 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("FUNCTION_SPACE"))
      if SDAI.IS_TRUE( _TEMP46 ) {
        
        let _TEMP47 = SP1?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP48 = _TEMP47?.SPACE_ID
        let _TEMP49 = _TEMP48 .==. SDAI.FORCE_OPTIONAL(ES_MATHS_FUNCTIONS)
        let _TEMP50 = BOOL(SDAI.LOGICAL(_TEMP49))
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP50)
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
    }
    
    let _TEMP51 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
    if SDAI.IS_TRUE( _TEMP51 ) {
      
      let _TEMP52 = SP2?.GROUP_REF(eELEMENTARY_SPACE.self)
      let _TEMP53 = _TEMP52?.SPACE_ID
      let _TEMP54 = _TEMP53 .==. SDAI.FORCE_OPTIONAL(ES_GENERICS)
      if SDAI.IS_TRUE( _TEMP54 ) {
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
      }
      
      let _TEMP55 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("FINITE_INTEGER_INTERVAL"))
      let _TEMP56 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("INTEGER_INTERVAL_FROM_MIN"))
      let _TEMP57 = _TEMP55 || _TEMP56
      let _TEMP58 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("INTEGER_INTERVAL_TO_MAX"))
      let _TEMP59 = _TEMP57 || _TEMP58
      if SDAI.IS_TRUE( _TEMP59 ) {
        
        let _TEMP60 = SP2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP61 = _TEMP60?.SPACE_ID
        let _TEMP62 = COMPATIBLE_ES_VALUES(
          ESVAL1: _TEMP61, ESVAL2: ES_INTEGERS)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP62)
      }
      
      let _TEMP63 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("FINITE_REAL_INTERVAL"))
      let _TEMP64 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("REAL_INTERVAL_FROM_MIN"))
      let _TEMP65 = _TEMP63 || _TEMP64
      let _TEMP66 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("REAL_INTERVAL_TO_MAX"))
      let _TEMP67 = _TEMP65 || _TEMP66
      if SDAI.IS_TRUE( _TEMP67 ) {
        
        let _TEMP68 = SP2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP69 = _TEMP68?.SPACE_ID
        let _TEMP70 = COMPATIBLE_ES_VALUES(
          ESVAL1: _TEMP69, ESVAL2: ES_REALS)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP70)
      }
      
      let _TEMP71 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("CARTESIAN_COMPLEX_NUMBER_REGION"))
      let _TEMP72 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("POLAR_COMPLEX_NUMBER_REGION"))
      let _TEMP73 = _TEMP71 || _TEMP72
      if SDAI.IS_TRUE( _TEMP73 ) {
        
        let _TEMP74 = SP2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP75 = _TEMP74?.SPACE_ID
        let _TEMP76 = COMPATIBLE_ES_VALUES(
          ESVAL1: _TEMP75, ESVAL2: ES_COMPLEX_NUMBERS)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP76)
      }
      
      let _TEMP77 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("TUPLE_SPACE"))
      if SDAI.IS_TRUE( _TEMP77 ) {
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
      }
      
      let _TEMP78 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("FUNCTION_SPACE"))
      if SDAI.IS_TRUE( _TEMP78 ) {
        
        let _TEMP79 = SP2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP80 = _TEMP79?.SPACE_ID
        let _TEMP81 = _TEMP80 .==. SDAI.FORCE_OPTIONAL(ES_MATHS_FUNCTIONS)
        let _TEMP82 = BOOL(SDAI.LOGICAL(_TEMP81))
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP82)
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
    }
    
    let _TEMP83 = SUBSPACE_OF_ES(SPC: SP1, 
                                 ES: ES_INTEGERS)
    if SDAI.IS_TRUE( _TEMP83 ) {
      
      let _TEMP84 = SUBSPACE_OF_ES(SPC: SP2, 
                                   ES: ES_INTEGERS)
      if SDAI.IS_TRUE( _TEMP84 ) {
        
        let _TEMP85 = COMPATIBLE_INTERVALS(
          SP1: SP1, SP2: SP2)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP85)
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP86 = SUBSPACE_OF_ES(SPC: SP2, 
                                 ES: ES_INTEGERS)
    if SDAI.IS_TRUE( _TEMP86 ) {
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP87 = SUBSPACE_OF_ES(SPC: SP1, 
                                 ES: ES_REALS)
    if SDAI.IS_TRUE( _TEMP87 ) {
      
      let _TEMP88 = SUBSPACE_OF_ES(SPC: SP2, 
                                   ES: ES_REALS)
      if SDAI.IS_TRUE( _TEMP88 ) {
        
        let _TEMP89 = COMPATIBLE_INTERVALS(
          SP1: SP1, SP2: SP2)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP89)
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP90 = SUBSPACE_OF_ES(SPC: SP2, 
                                 ES: ES_REALS)
    if SDAI.IS_TRUE( _TEMP90 ) {
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP91 = SUBSPACE_OF_ES(SPC: SP1, 
                                 ES: ES_COMPLEX_NUMBERS)
    if SDAI.IS_TRUE( _TEMP91 ) {
      
      let _TEMP92 = SUBSPACE_OF_ES(SPC: SP2, 
                                   ES: ES_COMPLEX_NUMBERS)
      if SDAI.IS_TRUE( _TEMP92 ) {
        
        let _TEMP93 = COMPATIBLE_COMPLEX_NUMBER_REGIONS(
          SP1: SP1, SP2: SP2)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP93)
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP94 = SUBSPACE_OF_ES(SPC: SP2, 
                                 ES: ES_COMPLEX_NUMBERS)
    if SDAI.IS_TRUE( _TEMP94 ) {
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP95 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("UNIFORM_PRODUCT_SPACE"))
    if SDAI.IS_TRUE( _TEMP95 ) {
      
      let _TEMP96 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("UNIFORM_PRODUCT_SPACE"))
      if SDAI.IS_TRUE( _TEMP96 ) {
        
        let _TEMP97 = SP1?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP98 = _TEMP97?.EXPONENT
        let _TEMP99 = SP2?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP100 = _TEMP99?.EXPONENT
        let _TEMP101 = _TEMP98 .!=. _TEMP100
        if SDAI.IS_TRUE( _TEMP101 ) {
          return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
        
        let _TEMP102 = SP1?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP103 = _TEMP102?.BASE
        let _TEMP104 = SP2?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP105 = _TEMP104?.BASE
        let _TEMP106 = COMPATIBLE_SPACES(
          SP1: _TEMP103, SP2: _TEMP105)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP106)
      }
      
      let _TEMP107 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("LISTED_PRODUCT_SPACE"))
      if SDAI.IS_TRUE( _TEMP107 ) {
        
        let _TEMP108 = SP2?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
        let _TEMP109 = _TEMP108?.FACTORS
        let _TEMP110 = SDAI.SIZEOF(_TEMP109)
        N = _TEMP110
        
        let _TEMP111 = SP1?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP112 = _TEMP111?.EXPONENT
        let _TEMP113 = _TEMP112 .!=. N
        if SDAI.IS_TRUE( _TEMP113 ) {
          return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/N) {
          for I in incrementControl {
            
            let _TEMP114 = SP1?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
            let _TEMP115 = _TEMP114?.BASE
            let _TEMP116 = SP2?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
            let _TEMP117 = _TEMP116?.FACTORS
            let _TEMP118 = _TEMP117?[I]
            let _TEMP119 = COMPATIBLE_SPACES(
              SP1: _TEMP115, SP2: _TEMP118)
            let _TEMP120 =  !_TEMP119
            if SDAI.IS_TRUE( _TEMP120 ) {
              return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
            }
          }
        }
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
      }
      
      let _TEMP121 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("EXTENDED_TUPLE_SPACE"))
      if SDAI.IS_TRUE( _TEMP121 ) {
        
        let _TEMP122 = SP1?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP123 = _TEMP122?.EXPONENT
        M = SDAI.INTEGER(/*tPOSITIVE_INTEGER*/_TEMP123)
        
        let _TEMP124 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP125 = _TEMP124?.BASE
        let _TEMP126 = SPACE_DIMENSION(_TEMP125)
        N = SDAI.INTEGER(/*tNONNEGATIVE_INTEGER*/_TEMP126)
        
        let _TEMP127 = M < N
        if SDAI.IS_TRUE( _TEMP127 ) {
          return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
        
        let _TEMP128 = M .==. N
        if SDAI.IS_TRUE( _TEMP128 ) {
          
          let _TEMP129 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP130 = _TEMP129?.BASE
          let _TEMP131 = COMPATIBLE_SPACES(
            SP1: SP1, SP2: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP130))
          return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP131)
        }
        
        let _TEMP132 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP133 = _TEMP132?.BASE
        let _TEMP134 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP135 = _TEMP134?.EXTENDER
        let _TEMP136 = M - N
        let _TEMP137 = MAKE_UNIFORM_PRODUCT_SPACE(
          BASE: _TEMP135, EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/_TEMP136))
        let _TEMP138 = ASSOC_PRODUCT_SPACE(
          TS1: _TEMP133, TS2: sTUPLE_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP137))
        let _TEMP139 = COMPATIBLE_SPACES(
          SP1: SP1, SP2: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP138))
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP139)
      }
      
      let _TEMP140 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("FUNCTION_SPACE"))
      if SDAI.IS_TRUE( _TEMP140 ) {
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
    }
    
    let _TEMP141 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("LISTED_PRODUCT_SPACE"))
    if SDAI.IS_TRUE( _TEMP141 ) {
      
      let _TEMP142 = SP1?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
      let _TEMP143 = _TEMP142?.FACTORS
      let _TEMP144 = SDAI.SIZEOF(_TEMP143)
      N = _TEMP144
      
      let _TEMP145 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("UNIFORM_PRODUCT_SPACE"))
      if SDAI.IS_TRUE( _TEMP145 ) {
        
        let _TEMP146 = SP2?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP147 = _TEMP146?.EXPONENT
        let _TEMP148 = N .!=. _TEMP147
        if SDAI.IS_TRUE( _TEMP148 ) {
          return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/N) {
          for I in incrementControl {
            
            let _TEMP149 = SP2?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
            let _TEMP150 = _TEMP149?.BASE
            let _TEMP151 = SP1?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
            let _TEMP152 = _TEMP151?.FACTORS
            let _TEMP153 = _TEMP152?[I]
            let _TEMP154 = COMPATIBLE_SPACES(
              SP1: _TEMP150, SP2: _TEMP153)
            let _TEMP155 =  !_TEMP154
            if SDAI.IS_TRUE( _TEMP155 ) {
              return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
            }
          }
        }
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
      }
      
      let _TEMP156 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("LISTED_PRODUCT_SPACE"))
      if SDAI.IS_TRUE( _TEMP156 ) {
        
        let _TEMP157 = SP2?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
        let _TEMP158 = _TEMP157?.FACTORS
        let _TEMP159 = SDAI.SIZEOF(_TEMP158)
        let _TEMP160 = N .!=. _TEMP159
        if SDAI.IS_TRUE( _TEMP160 ) {
          return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/N) {
          for I in incrementControl {
            
            let _TEMP161 = SP1?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
            let _TEMP162 = _TEMP161?.FACTORS
            let _TEMP163 = _TEMP162?[I]
            let _TEMP164 = SP2?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
            let _TEMP165 = _TEMP164?.FACTORS
            let _TEMP166 = _TEMP165?[I]
            let _TEMP167 = COMPATIBLE_SPACES(
              SP1: _TEMP163, SP2: _TEMP166)
            let _TEMP168 =  !_TEMP167
            if SDAI.IS_TRUE( _TEMP168 ) {
              return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
            }
          }
        }
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
      }
      
      let _TEMP169 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("EXTENDED_TUPLE_SPACE"))
      if SDAI.IS_TRUE( _TEMP169 ) {
        
        let _TEMP170 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP171 = _TEMP170?.BASE
        let _TEMP172 = SPACE_DIMENSION(_TEMP171)
        M = SDAI.INTEGER(/*tNONNEGATIVE_INTEGER*/_TEMP172)
        
        let _TEMP173 = N < M
        if SDAI.IS_TRUE( _TEMP173 ) {
          return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
        
        let _TEMP174 = N .==. M
        if SDAI.IS_TRUE( _TEMP174 ) {
          
          let _TEMP175 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP176 = _TEMP175?.BASE
          let _TEMP177 = COMPATIBLE_SPACES(
            SP1: SP1, SP2: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP176))
          return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP177)
        }
        
        let _TEMP178 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP179 = _TEMP178?.BASE
        let _TEMP180 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP181 = _TEMP180?.EXTENDER
        let _TEMP182 = N - M
        let _TEMP183 = MAKE_UNIFORM_PRODUCT_SPACE(
          BASE: _TEMP181, EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/_TEMP182))
        let _TEMP184 = ASSOC_PRODUCT_SPACE(
          TS1: _TEMP179, TS2: sTUPLE_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP183))
        let _TEMP185 = COMPATIBLE_SPACES(
          SP1: SP1, SP2: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP184))
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP185)
      }
      
      let _TEMP186 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("FUNCTION_SPACE"))
      let _TEMP187 = SDAI.aggregate(TYPES2, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP186))
      if SDAI.IS_TRUE( _TEMP187 ) {
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
    }
    
    let _TEMP188 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("EXTENDED_TUPLE_SPACE"))
    if SDAI.IS_TRUE( _TEMP188 ) {
      
      let _TEMP189 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("UNIFORM_PRODUCT_SPACE"))
      let _TEMP190 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("LISTED_PRODUCT_SPACE"))
      let _TEMP191 = _TEMP189 || _TEMP190
      if SDAI.IS_TRUE( _TEMP191 ) {
        
        let _TEMP192 = COMPATIBLE_SPACES(
          SP1: SP2, SP2: SP1)
        return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP192)
      }
      
      let _TEMP193 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("EXTENDED_TUPLE_SPACE"))
      if SDAI.IS_TRUE( _TEMP193 ) {
        
        let _TEMP194 = SP1?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP195 = _TEMP194?.EXTENDER
        let _TEMP196 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP197 = _TEMP196?.EXTENDER
        let _TEMP198 = COMPATIBLE_SPACES(
          SP1: _TEMP195, SP2: _TEMP197)
        let _TEMP199 =  !_TEMP198
        if SDAI.IS_TRUE( _TEMP199 ) {
          return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
        
        let _TEMP200 = SP1?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP201 = _TEMP200?.BASE
        let _TEMP202 = SPACE_DIMENSION(_TEMP201)
        N = SDAI.INTEGER(/*tNONNEGATIVE_INTEGER*/_TEMP202)
        
        let _TEMP203 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
        let _TEMP204 = _TEMP203?.BASE
        let _TEMP205 = SPACE_DIMENSION(_TEMP204)
        M = SDAI.INTEGER(/*tNONNEGATIVE_INTEGER*/_TEMP205)
        
        let _TEMP206 = N < M
        if SDAI.IS_TRUE( _TEMP206 ) {
          
          let _TEMP207 = SP1?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP208 = _TEMP207?.BASE
          let _TEMP209 = SP1?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP210 = _TEMP209?.EXTENDER
          let _TEMP211 = M - N
          let _TEMP212 = MAKE_UNIFORM_PRODUCT_SPACE(
            BASE: _TEMP210, EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/_TEMP211))
          let _TEMP213 = ASSOC_PRODUCT_SPACE(
            TS1: _TEMP208, TS2: sTUPLE_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP212))
          let _TEMP214 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP215 = _TEMP214?.BASE
          let _TEMP216 = COMPATIBLE_SPACES(
            SP1: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP213), 
            SP2: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP215))
          return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP216)
        }
        
        let _TEMP217 = N .==. M
        if SDAI.IS_TRUE( _TEMP217 ) {
          
          let _TEMP218 = SP1?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP219 = _TEMP218?.BASE
          let _TEMP220 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP221 = _TEMP220?.BASE
          let _TEMP222 = COMPATIBLE_SPACES(
            SP1: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP219), 
            SP2: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP221))
          return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP222)
        }
        
        let _TEMP223 = N > M
        if SDAI.IS_TRUE( _TEMP223 ) {
          
          let _TEMP224 = SP1?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP225 = _TEMP224?.BASE
          let _TEMP226 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP227 = _TEMP226?.BASE
          let _TEMP228 = SP2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
          let _TEMP229 = _TEMP228?.EXTENDER
          let _TEMP230 = N - M
          let _TEMP231 = MAKE_UNIFORM_PRODUCT_SPACE(
            BASE: _TEMP229, EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/_TEMP230))
          let _TEMP232 = ASSOC_PRODUCT_SPACE(
            TS1: _TEMP227, TS2: sTUPLE_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP231))
          let _TEMP233 = COMPATIBLE_SPACES(
            SP1: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP225), 
            SP2: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP232))
          return _compatible_spaces__cache.updateCache(params: _params, value: _TEMP233)
        }
      }
      
      let _TEMP234 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("FUNCTION_SPACE"))
      if SDAI.IS_TRUE( _TEMP234 ) {
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
    }
    
    let _TEMP235 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("FUNCTION_SPACE"))
    if SDAI.IS_TRUE( _TEMP235 ) {
      
      let _TEMP236 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("FUNCTION_SPACE"))
      if SDAI.IS_TRUE( _TEMP236 ) {
        
        let _TEMP237 = SP1?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP238 = _TEMP237?.DOMAIN_ARGUMENT
        S1 = _TEMP238
        
        let _TEMP239 = SP2?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP240 = _TEMP239?.DOMAIN_ARGUMENT
        S2 = _TEMP240
        
        let _TEMP241 = SP1?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP242 = _TEMP241?.DOMAIN_CONSTRAINT
        if let selector = _TEMP242 {
          switch selector {
          case SC_EQUAL:
            //BEGIN
            
            let _TEMP243 = SP2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP244 = _TEMP243?.DOMAIN_CONSTRAINT
            if let selector = _TEMP244 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP245 = SUBSPACE_OF(
                  SPACE1: S1, SPACE2: S2)
                let _TEMP246 = SUBSPACE_OF(
                  SPACE1: S2, SPACE2: S1)
                let _TEMP247 = _TEMP245 && _TEMP246
                LGCL = SDAI.UNWRAP(_TEMP247)

              case SC_SUBSPACE:
                
                let _TEMP248 = SUBSPACE_OF(
                  SPACE1: S1, SPACE2: S2)
                LGCL = SDAI.UNWRAP(_TEMP248)

              case SC_MEMBER:
                
                let _TEMP249 = MEMBER_OF(
                  VAL: S1, SPC: S2)
                LGCL = SDAI.UNWRAP(_TEMP249)

              default: break
              } //end switch
            }
            //END

          case SC_SUBSPACE:
            //BEGIN
            
            let _TEMP250 = SP2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP251 = _TEMP250?.DOMAIN_CONSTRAINT
            if let selector = _TEMP251 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP252 = SUBSPACE_OF(
                  SPACE1: S2, SPACE2: S1)
                LGCL = SDAI.UNWRAP(_TEMP252)

              case SC_SUBSPACE:
                
                let _TEMP253 = COMPATIBLE_SPACES(
                  SP1: S1, SP2: S2)
                LGCL = SDAI.UNWRAP(SDAI.LOGICAL(/*SDAI.BOOLEAN*/_TEMP253))

              case SC_MEMBER:
                LGCL = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN))

              default: break
              } //end switch
            }
            //END

          case SC_MEMBER:
            //BEGIN
            
            let _TEMP254 = SP2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP255 = _TEMP254?.DOMAIN_CONSTRAINT
            if let selector = _TEMP255 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP256 = MEMBER_OF(
                  VAL: S2, SPC: S1)
                LGCL = SDAI.UNWRAP(_TEMP256)

              case SC_SUBSPACE:
                LGCL = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN))

              case SC_MEMBER:
                
                let _TEMP257 = COMPATIBLE_SPACES(
                  SP1: S1, SP2: S2)
                LGCL = SDAI.UNWRAP(SDAI.LOGICAL(/*SDAI.BOOLEAN*/_TEMP257))

              default: break
              } //end switch
            }
            //END

          default: break
          } //end switch
        }
        
        let _TEMP258 = SDAI.FORCE_OPTIONAL(LGCL) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
        if SDAI.IS_TRUE( _TEMP258 ) {
          return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
        
        let _TEMP259 = SP1?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP260 = _TEMP259?.RANGE_ARGUMENT
        S1 = _TEMP260
        
        let _TEMP261 = SP2?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP262 = _TEMP261?.RANGE_ARGUMENT
        S2 = _TEMP262
        
        let _TEMP263 = SP1?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP264 = _TEMP263?.RANGE_CONSTRAINT
        if let selector = _TEMP264 {
          switch selector {
          case SC_EQUAL:
            //BEGIN
            
            let _TEMP265 = SP2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP266 = _TEMP265?.RANGE_CONSTRAINT
            if let selector = _TEMP266 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP267 = SUBSPACE_OF(
                  SPACE1: S1, SPACE2: S2)
                let _TEMP268 = SUBSPACE_OF(
                  SPACE1: S2, SPACE2: S1)
                let _TEMP269 = _TEMP267 && _TEMP268
                LGCL = SDAI.UNWRAP(_TEMP269)

              case SC_SUBSPACE:
                
                let _TEMP270 = SUBSPACE_OF(
                  SPACE1: S1, SPACE2: S2)
                LGCL = SDAI.UNWRAP(_TEMP270)

              case SC_MEMBER:
                
                let _TEMP271 = MEMBER_OF(
                  VAL: S1, SPC: S2)
                LGCL = SDAI.UNWRAP(_TEMP271)

              default: break
              } //end switch
            }
            //END

          case SC_SUBSPACE:
            //BEGIN
            
            let _TEMP272 = SP2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP273 = _TEMP272?.RANGE_CONSTRAINT
            if let selector = _TEMP273 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP274 = SUBSPACE_OF(
                  SPACE1: S2, SPACE2: S1)
                LGCL = SDAI.UNWRAP(_TEMP274)

              case SC_SUBSPACE:
                
                let _TEMP275 = COMPATIBLE_SPACES(
                  SP1: S1, SP2: S2)
                LGCL = SDAI.UNWRAP(SDAI.LOGICAL(/*SDAI.BOOLEAN*/_TEMP275))

              case SC_MEMBER:
                LGCL = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN))

              default: break
              } //end switch
            }
            //END

          case SC_MEMBER:
            //BEGIN
            
            let _TEMP276 = SP2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP277 = _TEMP276?.RANGE_CONSTRAINT
            if let selector = _TEMP277 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP278 = MEMBER_OF(
                  VAL: S2, SPC: S1)
                LGCL = SDAI.UNWRAP(_TEMP278)

              case SC_SUBSPACE:
                LGCL = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN))

              case SC_MEMBER:
                
                let _TEMP279 = COMPATIBLE_SPACES(
                  SP1: S1, SP2: S2)
                LGCL = SDAI.UNWRAP(SDAI.LOGICAL(/*SDAI.BOOLEAN*/_TEMP279))

              default: break
              } //end switch
            }
            //END

          default: break
          } //end switch
        }
        
        let _TEMP280 = SDAI.FORCE_OPTIONAL(LGCL) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
        if SDAI.IS_TRUE( _TEMP280 ) {
          return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
        return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
      }
      return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
    }
    return _compatible_spaces__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
  }

}

//MARK: - function result cache
private var _compatible_spaces__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

