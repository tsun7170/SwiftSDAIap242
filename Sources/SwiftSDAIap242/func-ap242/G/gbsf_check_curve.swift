/* file: gbsf_check_curve.swift 	 generated: Tue Nov 16 05:35:44 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION gbsf_check_curve(
               cv : representation_item
           ) : BOOLEAN;
    IF SIZEOF( [ 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.BOUNDED_CURVE', 
        'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.CONIC' , 
        'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.CURVE_REPLICA' , 
        'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.LINE' , 
        'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.OFFSET_CURVE_3D' ] * TYPEOF( cv ) ) > 1 THEN
      RETURN( FALSE );
    END_IF;
    IF SIZEOF( [ 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.CIRCLE', 
        'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.ELLIPSE' , 
        'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.TRIMMED_CURVE' ] * TYPEOF( cv ) ) = 1 THEN
      RETURN( TRUE );
    ELSE
      IF ( ( 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.B_SPLINE_CURVE' IN TYPEOF( cv ) ) AND ( cv\
          b_spline_curve.self_intersect = FALSE ) ) OR ( cv\b_spline_curve.self_intersect = UNKNOWN ) THEN
        RETURN( TRUE );
      ELSE
        IF ( ( 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.COMPOSITE_CURVE' IN TYPEOF( cv ) ) AND ( cv\
            composite_curve.self_intersect = FALSE ) ) OR ( cv\composite_curve.self_intersect = UNKNOWN )
            THEN
          RETURN( SIZEOF( QUERY ( seg <* cv\composite_curve.segments | ( NOT gbsf_check_curve( seg.
              parent_curve ) ) ) ) = 0 );
        ELSE
          IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.CURVE_REPLICA' IN TYPEOF( cv ) THEN
            RETURN( gbsf_check_curve( cv\curve_replica.parent_curve ) );
          ELSE
            IF ( 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF( cv ) ) AND ( ( 
                cv\offset_curve_3d.self_intersect = FALSE ) OR ( cv\offset_curve_3d.self_intersect = UNKNOWN ) ) 
                AND ( NOT ( 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.POLYLINE' IN TYPEOF( cv\
                offset_curve_3d.basis_curve ) ) ) THEN
              RETURN( gbsf_check_curve( cv\offset_curve_3d.basis_curve ) );
            ELSE
              IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.PCURVE' IN TYPEOF( cv ) THEN
                RETURN( gbsf_check_curve( cv\pcurve.reference_to_curve\representation.items[1] ) AND 
                    gbsf_check_surface( cv\pcurve.basis_surface ) );
              ELSE
                IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.POLYLINE' IN TYPEOF( cv ) THEN
                  IF SIZEOF( cv\polyline.points ) >= 3 THEN
                    RETURN( TRUE );
                  END_IF;
                ELSE
                  IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.SURFACE_CURVE' IN TYPEOF( cv ) THEN
                    IF gbsf_check_curve( cv\surface_curve.curve_3d ) THEN
                      REPEAT i := 1 TO SIZEOF( cv\surface_curve.associated_geometry ) BY 1;
                        IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.SURFACE' IN TYPEOF( cv\
                            surface_curve.associated_geometry[i] ) THEN
                          IF NOT gbsf_check_surface( cv\surface_curve.associated_geometry[i] ) THEN
                            RETURN( FALSE );
                          END_IF;
                        ELSE
                          IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.PCURVE' IN TYPEOF( cv\
                              surface_curve.associated_geometry[i] ) THEN
                            IF NOT gbsf_check_curve( cv\surface_curve.associated_geometry[i] ) THEN
                              RETURN( FALSE );
                            END_IF;
                          END_IF;
                        END_IF;
                      END_REPEAT;
                      RETURN( TRUE );
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN( FALSE );

  END_FUNCTION; -- gbsf_check_curve (line:41230 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func GBSF_CHECK_CURVE(_ CV: eREPRESENTATION_ITEM? ) 
    -> SDAI.BOOLEAN? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( CV )
    if case .available(let _cached_value) = _gbsf_check_curve__cache.cachedValue(params: _params) {
      return _cached_value as? SDAI.BOOLEAN
    }

    var CV = CV; SDAI.TOUCH(var: &CV)

    
    let _TEMP1 = ([SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.BOUNDED_CURVE")), 
      SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.CONIC")), 
      SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.CURVE_REPLICA")), 
      SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.LINE")), 
      SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.OFFSET_CURVE_3D"))] 
      as [SDAI.AggregationInitializerElement<SDAI.STRING>])
    let _TEMP2 = SDAI.TYPEOF(CV)
    let _TEMP3 = SDAI.FORCE_OPTIONAL(_TEMP1) * SDAI.FORCE_OPTIONAL(_TEMP2)
    let _TEMP4 = SDAI.SIZEOF(_TEMP3)
    let _TEMP5 = _TEMP4 > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    if SDAI.IS_TRUE( _TEMP5 ) {
      return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP6 = ([SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.CIRCLE")), 
      SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.ELLIPSE")), 
      SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.TRIMMED_CURVE"))] 
      as [SDAI.AggregationInitializerElement<SDAI.STRING>])
    let _TEMP7 = SDAI.TYPEOF(CV)
    let _TEMP8 = SDAI.FORCE_OPTIONAL(_TEMP6) * SDAI.FORCE_OPTIONAL(_TEMP7)
    let _TEMP9 = SDAI.SIZEOF(_TEMP8)
    let _TEMP10 = _TEMP9 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    if SDAI.IS_TRUE( _TEMP10 ) {
      return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
    }
    else {
      
      let _TEMP11 = SDAI.TYPEOF(CV, IS: eB_SPLINE_CURVE.self)
      let _TEMP12 = CV?.GROUP_REF(eB_SPLINE_CURVE.self)
      let _TEMP13 = _TEMP12?.SELF_INTERSECT
      let _TEMP14 = _TEMP13 .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
      let _TEMP15 = _TEMP11 && _TEMP14
      let _TEMP16 = CV?.GROUP_REF(eB_SPLINE_CURVE.self)
      let _TEMP17 = _TEMP16?.SELF_INTERSECT
      let _TEMP18 = _TEMP17 .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.UNKNOWN))
      let _TEMP19 = _TEMP15 || _TEMP18
      if SDAI.IS_TRUE( _TEMP19 ) {
        return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
      }
      else {
        
        let _TEMP20 = SDAI.TYPEOF(CV, IS: eCOMPOSITE_CURVE.self)
        let _TEMP21 = CV?.GROUP_REF(eCOMPOSITE_CURVE.self)
        let _TEMP22 = _TEMP21?.SELF_INTERSECT
        let _TEMP23 = _TEMP22 .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
        let _TEMP24 = _TEMP20 && _TEMP23
        let _TEMP25 = CV?.GROUP_REF(eCOMPOSITE_CURVE.self)
        let _TEMP26 = _TEMP25?.SELF_INTERSECT
        let _TEMP27 = _TEMP26 .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.UNKNOWN))
        let _TEMP28 = _TEMP24 || _TEMP27
        if SDAI.IS_TRUE( _TEMP28 ) {
          
          let _TEMP29 = CV?.GROUP_REF(eCOMPOSITE_CURVE.self)
          let _TEMP30 = _TEMP29?.SEGMENTS
          let _TEMP31 = _TEMP30?.QUERY{ SEG in 

              let _TEMP1 = SEG.PARENT_CURVE
              let _TEMP2 = GBSF_CHECK_CURVE(eREPRESENTATION_ITEM(/*eCURVE*/_TEMP1))
              let _TEMP3 =  !_TEMP2
              return _TEMP3 }
          let _TEMP32 = SDAI.SIZEOF(_TEMP31)
          let _TEMP33 = _TEMP32 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(/*SDAI.LOGICAL*/
            _TEMP33))
        }
        else {
          
          let _TEMP34 = SDAI.TYPEOF(CV, IS: eCURVE_REPLICA.self)
          if SDAI.IS_TRUE( _TEMP34 ) {
            
            let _TEMP35 = CV?.GROUP_REF(eCURVE_REPLICA.self)
            let _TEMP36 = _TEMP35?.PARENT_CURVE
            let _TEMP37 = GBSF_CHECK_CURVE(eREPRESENTATION_ITEM(/*eCURVE*/_TEMP36))
            return _gbsf_check_curve__cache.updateCache(params: _params, value: _TEMP37)
          }
          else {
            
            let _TEMP38 = SDAI.TYPEOF(CV, IS: eOFFSET_CURVE_3D.self)
            let _TEMP39 = CV?.GROUP_REF(eOFFSET_CURVE_3D.self)
            let _TEMP40 = _TEMP39?.SELF_INTERSECT
            let _TEMP41 = _TEMP40 .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
            let _TEMP42 = CV?.GROUP_REF(eOFFSET_CURVE_3D.self)
            let _TEMP43 = _TEMP42?.SELF_INTERSECT
            let _TEMP44 = _TEMP43 .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.UNKNOWN))
            let _TEMP45 = _TEMP41 || _TEMP44
            let _TEMP46 = _TEMP38 && _TEMP45
            let _TEMP47 = SDAI.TYPEOF(CV?.GROUP_REF(eOFFSET_CURVE_3D.self)?.BASIS_CURVE, IS: ePOLYLINE.self)
            let _TEMP48 =  !_TEMP47
            let _TEMP49 = _TEMP46 && _TEMP48
            if SDAI.IS_TRUE( _TEMP49 ) {
              
              let _TEMP50 = CV?.GROUP_REF(eOFFSET_CURVE_3D.self)
              let _TEMP51 = _TEMP50?.BASIS_CURVE
              let _TEMP52 = GBSF_CHECK_CURVE(eREPRESENTATION_ITEM(/*eCURVE*/_TEMP51))
              return _gbsf_check_curve__cache.updateCache(params: _params, value: _TEMP52)
            }
            else {
              
              let _TEMP53 = SDAI.TYPEOF(CV, IS: ePCURVE.self)
              if SDAI.IS_TRUE( _TEMP53 ) {
                
                let _TEMP54 = CV?.GROUP_REF(ePCURVE.self)
                let _TEMP55 = _TEMP54?.REFERENCE_TO_CURVE
                let _TEMP56 = _TEMP55?.GROUP_REF(eREPRESENTATION.self)
                let _TEMP57 = _TEMP56?.ITEMS
                let _TEMP58 = _TEMP57?[1]
                let _TEMP59 = GBSF_CHECK_CURVE(_TEMP58)
                let _TEMP60 = CV?.GROUP_REF(ePCURVE.self)
                let _TEMP61 = _TEMP60?.BASIS_SURFACE
                let _TEMP62 = GBSF_CHECK_SURFACE(_TEMP61)
                let _TEMP63 = _TEMP59 && _TEMP62
                return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(/*SDAI.LOGICAL*/
                  _TEMP63))
              }
              else {
                
                let _TEMP64 = SDAI.TYPEOF(CV, IS: ePOLYLINE.self)
                if SDAI.IS_TRUE( _TEMP64 ) {
                  
                  let _TEMP65 = CV?.GROUP_REF(ePOLYLINE.self)
                  let _TEMP66 = _TEMP65?.POINTS
                  let _TEMP67 = SDAI.SIZEOF(_TEMP66)
                  let _TEMP68 = _TEMP67 >= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(3))
                  if SDAI.IS_TRUE( _TEMP68 ) {
                    return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(
                      SDAI.TRUE))
                  }
                }
                else {
                  
                  let _TEMP69 = SDAI.TYPEOF(CV, IS: eSURFACE_CURVE.self)
                  if SDAI.IS_TRUE( _TEMP69 ) {
                    
                    let _TEMP70 = CV?.GROUP_REF(eSURFACE_CURVE.self)
                    let _TEMP71 = _TEMP70?.CURVE_3D
                    let _TEMP72 = GBSF_CHECK_CURVE(eREPRESENTATION_ITEM(/*eCURVE*/_TEMP71))
                    if SDAI.IS_TRUE( _TEMP72 ) {
                      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
                        SDAI.SIZEOF(CV?.GROUP_REF(eSURFACE_CURVE.self)?.ASSOCIATED_GEOMETRY)) {
                        for I in incrementControl {
                          
                          let _TEMP73 = SDAI.TYPEOF(CV?.GROUP_REF(eSURFACE_CURVE.self)?.ASSOCIATED_GEOMETRY[I], 
                            IS: eSURFACE.self)
                          if SDAI.IS_TRUE( _TEMP73 ) {
                            
                            let _TEMP74 = CV?.GROUP_REF(eSURFACE_CURVE.self)
                            let _TEMP75 = _TEMP74?.ASSOCIATED_GEOMETRY
                            let _TEMP76 = _TEMP75?[I]
                            let _TEMP77 = GBSF_CHECK_SURFACE(eSURFACE(/*sPCURVE_OR_SURFACE*/_TEMP76))
                            let _TEMP78 =  !_TEMP77
                            if SDAI.IS_TRUE( _TEMP78 ) {
                              return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(
                                SDAI.FALSE))
                            }
                          }
                          else {
                            
                            let _TEMP79 = SDAI.TYPEOF(CV?.GROUP_REF(eSURFACE_CURVE.self)?.ASSOCIATED_GEOMETRY[
                              I], IS: ePCURVE.self)
                            if SDAI.IS_TRUE( _TEMP79 ) {
                              
                              let _TEMP80 = CV?.GROUP_REF(eSURFACE_CURVE.self)
                              let _TEMP81 = _TEMP80?.ASSOCIATED_GEOMETRY
                              let _TEMP82 = _TEMP81?[I]
                              let _TEMP83 = GBSF_CHECK_CURVE(eREPRESENTATION_ITEM(/*sPCURVE_OR_SURFACE*/
                                _TEMP82))
                              let _TEMP84 =  !_TEMP83
                              if SDAI.IS_TRUE( _TEMP84 ) {
                                return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(
                                  SDAI.FALSE))
                              }
                            }
                          }
                        }
                      }
                      return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(
                        SDAI.TRUE))
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return _gbsf_check_curve__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
  }

}

//MARK: - function result cache
private var _gbsf_check_curve__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

