/* file: md_valid_content_in_geometric_set_for_placeholder.swift 	 generated: Sat Aug 14 13:46:02 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION md_valid_content_in_geometric_set_for_placeholder(
               input : geometric_set
           ) : BOOLEAN;

    LOCAL
      pass       : BOOLEAN := TRUE;
      boxes      : BAG OF planar_box := [];
      texts      : BAG OF annotation_text := [];
      placements : BAG OF placement := [];
      points     : BAG OF point := [];
      p_bx       : planar_box;
      a_tx       : annotation_text;
      pl         : placement;
      pt         : point;
    END_LOCAL;
    REPEAT i := LOINDEX( input\geometric_set.elements ) TO HIINDEX( input\geometric_set.elements ) BY 1;
      IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.POINT' IN TYPEOF( input\geometric_set.elements[i] )
          THEN
        IF NOT ( SIZEOF( [ 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.CARTESIAN_POINT', 
            'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.POINT_ON_CURVE' , 
            'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.POINT_ON_SURFACE' ] * TYPEOF( input\
            geometric_set.elements[i] ) ) = 1 ) THEN
          pass := FALSE;
        ELSE
          pt := input\geometric_set.elements[i];
          points := points + pt;
        END_IF;
      END_IF;
      IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.PLANAR_BOX' IN TYPEOF( input\geometric_set.elements
          [i] ) THEN
        p_bx := input\geometric_set.elements[i];
        boxes := boxes + p_bx;
      END_IF;
      IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.ANNOTATION_TEXT' IN TYPEOF( input\geometric_set.
          elements[i] ) THEN
        a_tx := input\geometric_set.elements[i];
        texts := texts + a_tx;
      END_IF;
      IF 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.PLACEMENT' IN TYPEOF( input\geometric_set.elements[
          i] ) THEN
        pl := input\geometric_set.elements[i];
        placements := placements + pl;
      END_IF;
    END_REPEAT;
    IF SIZEOF( boxes ) > 1 THEN
      pass := FALSE;
    END_IF;
    IF SIZEOF( texts ) > 1 THEN
      pass := FALSE;
    END_IF;
    IF SIZEOF( points ) < 1 THEN
      pass := FALSE;
    END_IF;
    IF SIZEOF( placements ) <> 1 THEN
      pass := FALSE;
    END_IF;
    RETURN( pass );

  END_FUNCTION; -- md_valid_content_in_geometric_set_for_placeholder (line:42911 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func MD_VALID_CONTENT_IN_GEOMETRIC_SET_FOR_PLACEHOLDER(
    _ INPUT: eGEOMETRIC_SET? ) -> SDAI.BOOLEAN? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( INPUT )
    if case .available(let _cached_value) = _md_valid_content_in_geometric_set_for_placeholder__cache.cachedValue(params: _params) {
      return _cached_value as? SDAI.BOOLEAN
    }

    var INPUT = INPUT; SDAI.TOUCH(var: &INPUT)

    //LOCAL
    var PASS: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.TRUE); SDAI.TOUCH(var: &PASS)
    var BOXES: SDAI.BAG<ePLANAR_BOX>?  = SDAI.BAG<ePLANAR_BOX>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &BOXES)
    var TEXTS: SDAI.BAG<eANNOTATION_TEXT>?  = SDAI.BAG<eANNOTATION_TEXT>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &TEXTS)
    var PLACEMENTS: SDAI.BAG<ePLACEMENT>?  = SDAI.BAG<ePLACEMENT>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &PLACEMENTS)
    var POINTS: SDAI.BAG<ePOINT>?  = SDAI.BAG<ePOINT>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &POINTS)
    var P_BX: ePLANAR_BOX? 
    var A_TX: eANNOTATION_TEXT? 
    var PL: ePLACEMENT? 
    var PT: ePOINT? 
    //END_LOCAL

    if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.LOINDEX(
      INPUT?.GROUP_REF(eGEOMETRIC_SET.self)?.ELEMENTS), TO:/*SDAI.INTEGER*/SDAI.HIINDEX(
      INPUT?.GROUP_REF(eGEOMETRIC_SET.self)?.ELEMENTS)) {
      for I in incrementControl {
        
        let _TEMP1 = SDAI.TYPEOF(INPUT?.GROUP_REF(eGEOMETRIC_SET.self)?.ELEMENTS[I], IS: ePOINT.self)
        if SDAI.IS_TRUE( _TEMP1 ) {
          
          let _TEMP2 = ([SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.CARTESIAN_POINT")), 
            SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.POINT_ON_CURVE")), 
            SDAI.AIE(SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.POINT_ON_SURFACE"))] 
            as [SDAI.AggregationInitializerElement<SDAI.STRING>])
          let _TEMP3 = INPUT?.GROUP_REF(eGEOMETRIC_SET.self)
          let _TEMP4 = _TEMP3?.ELEMENTS
          let _TEMP5 = _TEMP4?[I]
          let _TEMP6 = SDAI.TYPEOF(_TEMP5)
          let _TEMP7 = SDAI.FORCE_OPTIONAL(_TEMP2) * _TEMP6
          let _TEMP8 = SDAI.SIZEOF(_TEMP7)
          let _TEMP9 = _TEMP8 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          let _TEMP10 =  !_TEMP9
          if SDAI.IS_TRUE( _TEMP10 ) {
            PASS = SDAI.BOOLEAN(SDAI.FALSE)
          }
          else {
            
            let _TEMP11 = INPUT?.GROUP_REF(eGEOMETRIC_SET.self)
            let _TEMP12 = _TEMP11?.ELEMENTS
            let _TEMP13 = _TEMP12?[I]
            PT = ePOINT(/*sGEOMETRIC_SET_SELECT*/_TEMP13)
            
            let _TEMP14 = POINTS + PT
            POINTS = _TEMP14
          }
        }
        
        let _TEMP15 = SDAI.TYPEOF(INPUT?.GROUP_REF(eGEOMETRIC_SET.self)?.ELEMENTS[I], IS: ePLANAR_BOX.self)
        if SDAI.IS_TRUE( _TEMP15 ) {
          
          let _TEMP16 = INPUT?.GROUP_REF(eGEOMETRIC_SET.self)
          let _TEMP17 = _TEMP16?.ELEMENTS
          let _TEMP18 = _TEMP17?[I]
          P_BX = ePLANAR_BOX(/*sGEOMETRIC_SET_SELECT*/_TEMP18)
          
          let _TEMP19 = BOXES + P_BX
          BOXES = _TEMP19
        }
        
        let _TEMP20 = SDAI.TYPEOF(INPUT?.GROUP_REF(eGEOMETRIC_SET.self)?.ELEMENTS[I], 
          IS: eANNOTATION_TEXT.self)
        if SDAI.IS_TRUE( _TEMP20 ) {
          
          let _TEMP21 = INPUT?.GROUP_REF(eGEOMETRIC_SET.self)
          let _TEMP22 = _TEMP21?.ELEMENTS
          let _TEMP23 = _TEMP22?[I]
          A_TX = eANNOTATION_TEXT(/*sGEOMETRIC_SET_SELECT*/_TEMP23)
          
          let _TEMP24 = TEXTS + A_TX
          TEXTS = _TEMP24
        }
        
        let _TEMP25 = SDAI.TYPEOF(INPUT?.GROUP_REF(eGEOMETRIC_SET.self)?.ELEMENTS[I], IS: ePLACEMENT.self)
        if SDAI.IS_TRUE( _TEMP25 ) {
          
          let _TEMP26 = INPUT?.GROUP_REF(eGEOMETRIC_SET.self)
          let _TEMP27 = _TEMP26?.ELEMENTS
          let _TEMP28 = _TEMP27?[I]
          PL = ePLACEMENT(/*sGEOMETRIC_SET_SELECT*/_TEMP28)
          
          let _TEMP29 = PLACEMENTS + PL
          PLACEMENTS = _TEMP29
        }
      }
    }
    
    let _TEMP30 = SDAI.SIZEOF(BOXES)
    let _TEMP31 = _TEMP30 > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    if SDAI.IS_TRUE( _TEMP31 ) {
      PASS = SDAI.BOOLEAN(SDAI.FALSE)
    }
    
    let _TEMP32 = SDAI.SIZEOF(TEXTS)
    let _TEMP33 = _TEMP32 > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    if SDAI.IS_TRUE( _TEMP33 ) {
      PASS = SDAI.BOOLEAN(SDAI.FALSE)
    }
    
    let _TEMP34 = SDAI.SIZEOF(POINTS)
    let _TEMP35 = _TEMP34 < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    if SDAI.IS_TRUE( _TEMP35 ) {
      PASS = SDAI.BOOLEAN(SDAI.FALSE)
    }
    
    let _TEMP36 = SDAI.SIZEOF(PLACEMENTS)
    let _TEMP37 = _TEMP36 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    if SDAI.IS_TRUE( _TEMP37 ) {
      PASS = SDAI.BOOLEAN(SDAI.FALSE)
    }
    return _md_valid_content_in_geometric_set_for_placeholder__cache.updateCache(params: _params, value: PASS)
  }

}

//MARK: - function result cache
private var _md_valid_content_in_geometric_set_for_placeholder__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

