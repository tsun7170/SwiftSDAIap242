/* file: first_proj_axis.swift 	 generated: Mon Jan  3 16:32:52 2022 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.1, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION first_proj_axis(
               z_axis, arg : direction
           ) : direction;

    LOCAL
      x_axis : direction;
      v      : direction;
      z      : direction;
      x_vec  : vector;
    END_LOCAL;
    IF NOT EXISTS( z_axis ) THEN
      RETURN( ? );
    ELSE
      z := normalise( z_axis );
      IF NOT EXISTS( arg ) THEN
        IF ( z.direction_ratios <> [1, 0, 0] ) AND ( z.direction_ratios <> [-1, 0, 0] ) THEN
          v := dummy_gri || direction( [1, 0, 0] );
        ELSE
          v := dummy_gri || direction( [0, 1, 0] );
        END_IF;
      ELSE
        IF arg.dim <> 3 THEN
          RETURN( ? );
        END_IF;
        IF cross_product( arg, z ).magnitude = 0 THEN
          RETURN( ? );
        ELSE
          v := normalise( arg );
        END_IF;
      END_IF;
      x_vec := scalar_times_vector( dot_product( v, z ), z );
      x_axis := vector_difference( v, x_vec ).orientation;
      x_axis := normalise( x_axis );
    END_IF;
    RETURN( x_axis );

  END_FUNCTION; -- first_proj_axis (line:40936 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func FIRST_PROJ_AXIS(Z_AXIS: eDIRECTION? , ARG: eDIRECTION? ) 
    -> eDIRECTION? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( Z_AXIS, ARG )
    if case .available(let _cached_value) = _first_proj_axis__cache.cachedValue(params: _params) {
      return _cached_value as? eDIRECTION
    }

    var Z_AXIS = Z_AXIS; SDAI.TOUCH(var: &Z_AXIS)
    var ARG = ARG; SDAI.TOUCH(var: &ARG)

    //LOCAL
    var X_AXIS: eDIRECTION? 
    var V: eDIRECTION? 
    var Z: eDIRECTION? 
    var X_VEC: eVECTOR? 
    //END_LOCAL

    
    let _TEMP1 = SDAI.EXISTS(Z_AXIS)
    let _TEMP2 =  !_TEMP1
    if SDAI.IS_TRUE( _TEMP2 ) {
      return _first_proj_axis__cache.updateCache(params: _params, value: (nil as eDIRECTION?))
    }
    else {
      
      let _TEMP3 = NORMALISE(sVECTOR_OR_DIRECTION(/*eDIRECTION*/Z_AXIS))
      Z = eDIRECTION(/*sVECTOR_OR_DIRECTION*/_TEMP3)
      
      let _TEMP4 = SDAI.EXISTS(ARG)
      let _TEMP5 =  !_TEMP4
      if SDAI.IS_TRUE( _TEMP5 ) {
        
        let _TEMP6 = Z?.DIRECTION_RATIOS
        let _TEMP7 = ([SDAI.AIE(SDAI.REAL(1.0000000000e+00)), 
          SDAI.AIE(SDAI.REAL(0)), SDAI.AIE(SDAI.REAL(0))] as [SDAI.AggregationInitializerElement<SDAI.REAL>])
        let _TEMP8 = _TEMP6 .!=. SDAI.FORCE_OPTIONAL(_TEMP7)
        let _TEMP9 = Z?.DIRECTION_RATIOS
        let _TEMP10 = ([SDAI.AIE(SDAI.REAL( -1.0000000000e+00)), 
          SDAI.AIE(SDAI.REAL(0)), SDAI.AIE(SDAI.REAL(0))] as [SDAI.AggregationInitializerElement<SDAI.REAL>])
        let _TEMP11 = _TEMP9 .!=. SDAI.FORCE_OPTIONAL(_TEMP10)
        let _TEMP12 = _TEMP8 && _TEMP11
        if SDAI.IS_TRUE( _TEMP12 ) {
          
          let _TEMP13 = SDAI.LIST<SDAI.REAL>(bound1: SDAI.UNWRAP(SDAI.INTEGER(2)), bound2: SDAI.INTEGER(3), 
            ([SDAI.AIE(SDAI.REAL(1.0000000000e+00)), 
            SDAI.AIE(SDAI.REAL(0)), 
            SDAI.AIE(SDAI.REAL(0))] as [SDAI.AggregationInitializerElement<SDAI.REAL>]))
          let _TEMP14 = _direction(DIRECTION_RATIOS: SDAI.UNWRAP(_TEMP13))
          let _TEMP15 = DUMMY_GRI .||. _TEMP14
          V = eDIRECTION(/*SDAI.GENERIC_ENTITY*/_TEMP15)
        }
        else {
          
          let _TEMP16 = SDAI.LIST<SDAI.REAL>(bound1: SDAI.UNWRAP(SDAI.INTEGER(2)), bound2: SDAI.INTEGER(3), 
            ([SDAI.AIE(SDAI.REAL(0)), 
            SDAI.AIE(SDAI.REAL(1.0000000000e+00)), 
            SDAI.AIE(SDAI.REAL(0))] as [SDAI.AggregationInitializerElement<SDAI.REAL>]))
          let _TEMP17 = _direction(DIRECTION_RATIOS: SDAI.UNWRAP(_TEMP16))
          let _TEMP18 = DUMMY_GRI .||. _TEMP17
          V = eDIRECTION(/*SDAI.GENERIC_ENTITY*/_TEMP18)
        }
      }
      else {
        
        let _TEMP19 = ARG?.DIM
        let _TEMP20 = _TEMP19 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(3))
        if SDAI.IS_TRUE( _TEMP20 ) {
          return _first_proj_axis__cache.updateCache(params: _params, value: (nil as eDIRECTION?))
        }
        
        let _TEMP21 = CROSS_PRODUCT(
          ARG1: ARG, ARG2: Z)
        let _TEMP22 = _TEMP21?.MAGNITUDE
        let _TEMP23 = _TEMP22 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP23 ) {
          return _first_proj_axis__cache.updateCache(params: _params, value: (nil as eDIRECTION?))
        }
        else {
          
          let _TEMP24 = NORMALISE(sVECTOR_OR_DIRECTION(/*eDIRECTION*/ARG))
          V = eDIRECTION(/*sVECTOR_OR_DIRECTION*/_TEMP24)
        }
      }
      
      let _TEMP25 = DOT_PRODUCT(ARG1: V, 
                                ARG2: Z)
      let _TEMP26 = SCALAR_TIMES_VECTOR(
        SCALAR: _TEMP25, VEC: sVECTOR_OR_DIRECTION(/*eDIRECTION*/Z))
      X_VEC = _TEMP26
      
      let _TEMP27 = VECTOR_DIFFERENCE(
        ARG1: sVECTOR_OR_DIRECTION(/*eDIRECTION*/V), 
        ARG2: sVECTOR_OR_DIRECTION(/*eVECTOR*/X_VEC))
      let _TEMP28 = _TEMP27?.ORIENTATION
      X_AXIS = _TEMP28
      
      let _TEMP29 = NORMALISE(sVECTOR_OR_DIRECTION(/*eDIRECTION*/X_AXIS))
      X_AXIS = eDIRECTION(/*sVECTOR_OR_DIRECTION*/_TEMP29)
    }
    return _first_proj_axis__cache.updateCache(params: _params, value: X_AXIS)
  }

}

//MARK: - function result cache
private var _first_proj_axis__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

