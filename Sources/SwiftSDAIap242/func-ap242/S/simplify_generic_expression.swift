/* file: simplify_generic_expression.swift 	 generated: Sun Oct 31 15:32:10 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION simplify_generic_expression(
               expr : generic_expression
           ) : maths_value;

    FUNCTION make_number_literal(
                 nmb : NUMBER
             ) : generic_literal;
      IF 'INTEGER' IN TYPEOF( nmb ) THEN
        RETURN( make_int_literal( nmb ) );
      END_IF;
      RETURN( make_real_literal( nmb ) );

    END_FUNCTION; -- make_number_literal (line:45774 file:ap242ed2_mim_lf_v1.101.TY.exp)

    FUNCTION restore_binary(
                 expr : binary_generic_expression;
                 opd1, opd2 : generic_expression
             ) : generic_expression;
      expr.operands[1] := opd1;
      expr.operands[2] := opd2;
      RETURN( expr );

    END_FUNCTION; -- restore_binary (line:45762 file:ap242ed2_mim_lf_v1.101.TY.exp)

    FUNCTION restore_mulary(
                 expr : multiple_arity_generic_expression;
                 ops : LIST OF generic_expression
             ) : generic_expression;
      expr.operands := ops;
      RETURN( expr );

    END_FUNCTION; -- restore_mulary (line:45769 file:ap242ed2_mim_lf_v1.101.TY.exp)

    FUNCTION restore_unary(
                 expr : unary_generic_expression;
                 opnd : generic_expression
             ) : generic_expression;
      expr.operand := opnd;
      RETURN( expr );

    END_FUNCTION; -- restore_unary (line:45757 file:ap242ed2_mim_lf_v1.101.TY.exp)

    LOCAL
      types     : SET OF STRING := stripped_typeof( expr );
      v1        : maths_value;
      v2        : maths_value;
      vlist     : LIST OF maths_value := [];
      op1       : generic_expression;
      op2       : generic_expression;
      oplist    : LIST OF generic_expression := [];
      opnds     : LIST [2 : ?] OF generic_expression;
      n         : INTEGER;
      m         : INTEGER;
      finfun    : maths_function_select;
      boo       : BOOLEAN;
      str       : STRING;
      nmb       : NUMBER;
      v1_string : STRING;
      v2_string : STRING;
      v1_number : NUMBER;
      v2_number : NUMBER;
    END_LOCAL;
    IF 'INT_LITERAL' IN types THEN
      RETURN( convert_to_maths_value( expr\int_literal.the_value ) );
    END_IF;
    IF 'REAL_LITERAL' IN types THEN
      RETURN( convert_to_maths_value( expr\real_literal.the_value ) );
    END_IF;
    IF 'BOOLEAN_LITERAL' IN types THEN
      RETURN( convert_to_maths_value( expr\boolean_literal.the_value ) );
    END_IF;
    IF 'STRING_LITERAL' IN types THEN
      RETURN( convert_to_maths_value( expr\string_literal.the_value ) );
    END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types THEN
      RETURN( expr );
    END_IF;
    IF 'LOGICAL_LITERAL' IN types THEN
      RETURN( convert_to_maths_value( expr\logical_literal.lit_value ) );
    END_IF;
    IF 'BINARY_LITERAL' IN types THEN
      RETURN( convert_to_maths_value( expr\binary_literal.lit_value ) );
    END_IF;
    IF 'MATHS_ENUM_LITERAL' IN types THEN
      RETURN( expr\maths_enum_literal.lit_value );
    END_IF;
    IF 'REAL_TUPLE_LITERAL' IN types THEN
      RETURN( convert_to_maths_value( expr\real_tuple_literal.lit_value ) );
    END_IF;
    IF 'INTEGER_TUPLE_LITERAL' IN types THEN
      RETURN( convert_to_maths_value( expr\integer_tuple_literal.lit_value ) );
    END_IF;
    IF 'ATOM_BASED_LITERAL' IN types THEN
      RETURN( expr\atom_based_literal.lit_value );
    END_IF;
    IF 'MATHS_TUPLE_LITERAL' IN types THEN
      RETURN( convert_to_maths_value( expr\maths_tuple_literal.lit_value ) );
    END_IF;
    IF 'MATHS_SPACE' IN types THEN
      RETURN( simplify_maths_space( expr ) );
    END_IF;
    IF 'FUNCTION_APPLICATION' IN types THEN
      RETURN( simplify_function_application( expr ) );
    END_IF;
    IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
      v1 := simplify_generic_expression( expr\unary_generic_expression.operand );
      op1 := convert_to_operand( v1 );
    END_IF;
    IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
      v1 := simplify_generic_expression( expr\binary_generic_expression.operands[1] );
      op1 := convert_to_operand( v1 );
      v2 := simplify_generic_expression( expr\binary_generic_expression.operands[2] );
      op2 := convert_to_operand( v2 );
    END_IF;
    IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
      opnds := expr\multiple_arity_generic_expression.operands;
      REPEAT i := 1 TO SIZEOF( opnds ) BY 1;
        v1 := simplify_generic_expression( opnds[i] );
        INSERT( vlist, v1, i - 1 );
        INSERT( oplist, convert_to_operand( v1 ), i - 1 );
      END_REPEAT;
    END_IF;
    IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
      v1 := vlist[1];
      n := SIZEOF( vlist );
      finfun := vlist[n];
      REMOVE( vlist, n );
      REMOVE( vlist, 1 );
      RETURN( make_parallel_composed_function( v1, vlist, finfun ) );
    END_IF;
    IF ( 'ABS_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( ABS( v1 ) ) );
    END_IF;
    IF ( 'ACOS_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( ACOS( v1 ) ) );
    END_IF;
    IF 'AND_EXPRESSION' IN types THEN
      REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
        IF 'BOOLEAN' IN TYPEOF( vlist[i] ) THEN
          boo := vlist[i];
          IF NOT boo THEN
            RETURN( convert_to_maths_value( FALSE ) );
          END_IF;
          REMOVE( oplist, i );
        END_IF;
      END_REPEAT;
      IF SIZEOF( oplist ) = 0 THEN
        RETURN( convert_to_maths_value( TRUE ) );
      END_IF;
      IF SIZEOF( oplist ) = 1 THEN
        RETURN( oplist[1] );
      END_IF;
    END_IF;
    IF ( 'ASIN_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( ASIN( v1 ) ) );
    END_IF;
    IF ( 'ATAN_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) AND ( 'NUMBER' IN TYPEOF( v2 ) ) THEN
      RETURN( convert_to_maths_value( ATAN( v1, v2 ) ) );
    END_IF;
    IF ( 'COMPARISON_EXPRESSION' IN types ) AND ( ( ( 'NUMBER' IN TYPEOF( v1 ) ) AND ( 'NUMBER' IN TYPEOF( v2 ) ) ) 
        OR ( ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) ) ) OR ( ( 'BOOLEAN' IN TYPEOF( v1 ) ) 
        AND ( 'BOOLEAN' IN TYPEOF( v2 ) ) ) ) THEN
      IF 'COMPARISON_EQUAL' IN types THEN
        boo := bool( v1 = v2 );
      ELSE
        IF 'COMPARISON_GREATER' IN types THEN
          boo := bool( v1 > v2 );
        ELSE
          IF 'COMPARISON_GREATER_EQUAL' IN types THEN
            boo := bool( v1 >= v2 );
          ELSE
            IF 'COMPARISON_LESS' IN types THEN
              boo := bool( v1 < v2 );
            ELSE
              IF 'COMPARISON_LESS_EQUAL' IN types THEN
                boo := bool( v1 <= v2 );
              ELSE
                IF 'COMPARISON_NOT_EQUAL' IN types THEN
                  boo := bool( v1 <> v2 );
                ELSE
                  IF 'LIKE_EXPRESSION' IN types THEN
                    v1_string := v1;
                    v2_string := v2;
                    boo := bool( v1_string LIKE v2_string );
                  ELSE
                    RETURN( ? );
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
      RETURN( convert_to_maths_value( boo ) );
    END_IF;
    IF 'CONCAT_EXPRESSION' IN types THEN
      str := '';
      REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
        IF 'STRING' IN TYPEOF( vlist[i] ) THEN
          str := vlist[i] + str;
          REMOVE( oplist, i );
        ELSE
          IF LENGTH( str ) > 0 THEN
            INSERT( oplist, make_string_literal( str ), i );
            str := '';
          END_IF;
        END_IF;
      END_REPEAT;
      IF SIZEOF( oplist ) = 0 THEN
        RETURN( convert_to_maths_value( str ) );
      END_IF;
      IF LENGTH( str ) > 0 THEN
        INSERT( oplist, make_string_literal( str ), 0 );
      END_IF;
      IF SIZEOF( oplist ) = 1 THEN
        RETURN( oplist[1] );
      END_IF;
    END_IF;
    IF ( 'COS_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( COS( v1 ) ) );
    END_IF;
    IF ( 'DIV_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) AND ( 'NUMBER' IN TYPEOF( v2 ) ) THEN
      v1_number := v1;
      v2_number := v2;
      RETURN( convert_to_maths_value( v1_number DIV v2_number ) );
    END_IF;
    IF 'EQUALS_EXPRESSION' IN types THEN
      opnds := expr\binary_generic_expression.operands;
      RETURN( convert_to_maths_value( opnds[1] :=: opnds[2] ) );
    END_IF;
    IF ( 'EXP_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( EXP( v1 ) ) );
    END_IF;
    IF ( 'FORMAT_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) )
        THEN
      RETURN( convert_to_maths_value( FORMAT( v1, v2 ) ) );
    END_IF;
    IF ( 'INDEX_EXPRESSION' IN types ) AND ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'NUMBER' IN TYPEOF( v2 ) )
        THEN
      str := v1;
      n := v2;
      RETURN( convert_to_maths_value( str[n] ) );
    END_IF;
    IF ( 'INT_VALUE_EXPRESSION' IN types ) AND ( 'STRING' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( VALUE( v1 ) ) );
    END_IF;
    IF 'INTERVAL_EXPRESSION' IN types THEN
      str := '';
      IF 'NUMBER' IN TYPEOF( vlist[1] ) THEN
        str := 'NUMBER';
      END_IF;
      IF 'STRING' IN TYPEOF( vlist[1] ) THEN
        str := 'STRING';
      END_IF;
      IF 'BOOLEAN' IN TYPEOF( vlist[1] ) THEN
        str := 'BOOLEAN';
      END_IF;
      IF ( LENGTH( str ) > 0 ) AND ( str IN TYPEOF( vlist[2] ) ) AND ( str IN TYPEOF( vlist[3] ) ) THEN
        RETURN( convert_to_maths_value( ( vlist[1] <= vlist[2] ) AND ( vlist[2] <= vlist[3] ) ) );
      END_IF;
    END_IF;
    IF ( 'LENGTH_EXPRESSION' IN types ) AND ( 'STRING' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( LENGTH( v1 ) ) );
    END_IF;
    IF ( 'LOG_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( LOG( v1 ) ) );
    END_IF;
    IF ( 'LOG10_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( LOG10( v1 ) ) );
    END_IF;
    IF ( 'LOG2_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( LOG2( v1 ) ) );
    END_IF;
    IF 'MAXIMUM_EXPRESSION' IN types THEN
      boo := FALSE;
      REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
        IF 'NUMBER' IN TYPEOF( vlist[i] ) THEN
          IF boo THEN
            IF nmb < vlist[i] THEN
              nmb := vlist[i];
            END_IF;
          ELSE
            nmb := vlist[i];
            boo := TRUE;
          END_IF;
          REMOVE( oplist, i );
        END_IF;
      END_REPEAT;
      IF SIZEOF( oplist ) = 0 THEN
        RETURN( convert_to_maths_value( nmb ) );
      END_IF;
      IF boo THEN
        INSERT( oplist, make_number_literal( nmb ), 0 );
      END_IF;
    END_IF;
    IF 'MINIMUM_EXPRESSION' IN types THEN
      boo := FALSE;
      REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
        IF 'NUMBER' IN TYPEOF( vlist[i] ) THEN
          IF boo THEN
            IF nmb > vlist[i] THEN
              nmb := vlist[i];
            END_IF;
          ELSE
            nmb := vlist[i];
            boo := TRUE;
          END_IF;
          REMOVE( oplist, i );
        END_IF;
      END_REPEAT;
      IF SIZEOF( oplist ) = 0 THEN
        RETURN( convert_to_maths_value( nmb ) );
      END_IF;
      IF boo THEN
        INSERT( oplist, make_number_literal( nmb ), 0 );
      END_IF;
    END_IF;
    IF ( 'MINUS_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) AND ( 'NUMBER' IN TYPEOF( v2 ) )
        THEN
      v1_number := v1;
      v2_number := v2;
      RETURN( convert_to_maths_value( v1_number - v2_number ) );
    END_IF;
    IF ( 'MOD_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) AND ( 'NUMBER' IN TYPEOF( v2 ) ) THEN
      v1_number := v1;
      v2_number := v2;
      RETURN( convert_to_maths_value( v1_number MOD v2_number ) );
    END_IF;
    IF 'MULT_EXPRESSION' IN types THEN
      nmb := 1;
      REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
        IF 'NUMBER' IN TYPEOF( vlist[i] ) THEN
          nmb := nmb * vlist[i];
          REMOVE( oplist, i );
        END_IF;
      END_REPEAT;
      IF SIZEOF( oplist ) = 0 THEN
        RETURN( convert_to_maths_value( nmb ) );
      END_IF;
      IF nmb <> 1 THEN
        INSERT( oplist, make_number_literal( nmb ), 0 );
      END_IF;
      IF SIZEOF( oplist ) = 1 THEN
        RETURN( oplist[1] );
      END_IF;
    END_IF;
    IF ( 'NOT_EXPRESSION' IN types ) AND ( 'BOOLEAN' IN TYPEOF( v1 ) ) THEN
      boo := v1;
      RETURN( convert_to_maths_value( NOT boo ) );
    END_IF;
    IF ( 'ODD_EXPRESSION' IN types ) AND ( 'INTEGER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( ODD( v1 ) ) );
    END_IF;
    IF 'OR_EXPRESSION' IN types THEN
      REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
        IF 'BOOLEAN' IN TYPEOF( vlist[i] ) THEN
          boo := vlist[i];
          IF boo THEN
            RETURN( convert_to_maths_value( TRUE ) );
          END_IF;
          REMOVE( oplist, i );
        END_IF;
      END_REPEAT;
      IF SIZEOF( oplist ) = 0 THEN
        RETURN( convert_to_maths_value( FALSE ) );
      END_IF;
      IF SIZEOF( oplist ) = 1 THEN
        RETURN( oplist[1] );
      END_IF;
    END_IF;
    IF 'PLUS_EXPRESSION' IN types THEN
      nmb := 0;
      REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
        IF 'NUMBER' IN TYPEOF( vlist[i] ) THEN
          nmb := nmb + vlist[i];
          REMOVE( oplist, i );
        END_IF;
      END_REPEAT;
      IF SIZEOF( oplist ) = 0 THEN
        RETURN( convert_to_maths_value( nmb ) );
      END_IF;
      IF nmb <> 0 THEN
        INSERT( oplist, make_number_literal( nmb ), 0 );
      END_IF;
      IF SIZEOF( oplist ) = 1 THEN
        RETURN( oplist[1] );
      END_IF;
    END_IF;
    IF ( 'POWER_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) AND ( 'NUMBER' IN TYPEOF( v2 ) )
        THEN
      v1_number := v1;
      v2_number := v2;
      RETURN( convert_to_maths_value( v1_number ** v2_number ) );
    END_IF;
    IF ( 'SIN_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( SIN( v1 ) ) );
    END_IF;
    IF ( 'SLASH_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) AND ( 'NUMBER' IN TYPEOF( v2 ) )
        THEN
      v1_number := v1;
      v2_number := v2;
      RETURN( convert_to_maths_value( v1_number / v2_number ) );
    END_IF;
    IF ( 'SQUARE_ROOT_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( SQRT( v1 ) ) );
    END_IF;
    IF ( 'SUBSTRING_EXPRESSION' IN types ) AND ( 'STRING' IN TYPEOF( vlist[1] ) ) AND ( 'NUMBER' IN TYPEOF( 
        vlist[2] ) ) AND ( 'NUMBER' IN TYPEOF( vlist[3] ) ) THEN
      str := vlist[1];
      n := vlist[2];
      m := vlist[3];
      RETURN( convert_to_maths_value( str[n : m] ) );
    END_IF;
    IF ( 'TAN_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( TAN( v1 ) ) );
    END_IF;
    IF ( 'UNARY_MINUS_EXPRESSION' IN types ) AND ( 'NUMBER' IN TYPEOF( v1 ) ) THEN
      nmb := v1;
      RETURN( convert_to_maths_value( -nmb ) );
    END_IF;
    IF ( 'VALUE_EXPRESSION' IN types ) AND ( 'STRING' IN TYPEOF( v1 ) ) THEN
      RETURN( convert_to_maths_value( VALUE( v1 ) ) );
    END_IF;
    IF ( 'XOR_EXPRESSION' IN types ) AND ( 'BOOLEAN' IN TYPEOF( v1 ) ) AND ( 'BOOLEAN' IN TYPEOF( v2 ) )
        THEN
      RETURN( convert_to_maths_value( v1 XOR v2 ) );
    END_IF;
    IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
      RETURN( restore_unary( expr, op1 ) );
    END_IF;
    IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
      RETURN( restore_binary( expr, op1, op2 ) );
    END_IF;
    IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
      RETURN( restore_mulary( expr, oplist ) );
    END_IF;
    RETURN( expr );

  END_FUNCTION; -- simplify_generic_expression (line:45756 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func SIMPLIFY_GENERIC_EXPRESSION(_ EXPR: eGENERIC_EXPRESSION? ) 
    -> sMATHS_VALUE? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( EXPR )
    if case .available(let _cached_value) = _simplify_generic_expression__cache.cachedValue(params: _params) {
      return _cached_value as? sMATHS_VALUE
    }

    var EXPR = EXPR; SDAI.TOUCH(var: &EXPR)

    //NESTED FUNCTION
    func MAKE_NUMBER_LITERAL(_ NMB: SDAI.NUMBER? ) 
      -> eGENERIC_LITERAL? {

      var NMB = NMB; SDAI.TOUCH(var: &NMB)

      
      let _TEMP1 = SDAI.TYPEOF(NMB, IS: SDAI.INTEGER.self)
      if SDAI.IS_TRUE( _TEMP1 ) {
        
        let _TEMP2 = MAKE_INT_LITERAL(SDAI.INTEGER(/*SDAI.NUMBER*/NMB))
        return eGENERIC_LITERAL(/*eINT_LITERAL*/_TEMP2)
      }
      
      let _TEMP3 = MAKE_REAL_LITERAL(SDAI.REAL(/*SDAI.NUMBER*/NMB))
      return eGENERIC_LITERAL(/*eREAL_LITERAL*/_TEMP3)
    } //END FUNCTION MAKE_NUMBER_LITERAL

    //NESTED FUNCTION
    func RESTORE_MULARY(EXPR: eMULTIPLE_ARITY_GENERIC_EXPRESSION? , OPS: SDAI.LIST<eGENERIC_EXPRESSION>? ) 
      -> eGENERIC_EXPRESSION? {

      var EXPR = EXPR; SDAI.TOUCH(var: &EXPR)
      var OPS = OPS; SDAI.TOUCH(var: &OPS)

      EXPR?.OPERANDS = SDAI.UNWRAP(SDAI.LIST<eGENERIC_EXPRESSION>(bound1: SDAI.UNWRAP(SDAI.INTEGER(2)), 
        bound2: (nil as SDAI.INTEGER?), 
        /*SDAI.LIST<eGENERIC_EXPRESSION>*/OPS))
      return eGENERIC_EXPRESSION(/*eMULTIPLE_ARITY_GENERIC_EXPRESSION*/EXPR)
    } //END FUNCTION RESTORE_MULARY

    //NESTED FUNCTION
    func RESTORE_BINARY(EXPR: eBINARY_GENERIC_EXPRESSION? , OPD1: eGENERIC_EXPRESSION? , 
                        OPD2: eGENERIC_EXPRESSION? ) 
      -> eGENERIC_EXPRESSION? {

      var EXPR = EXPR; SDAI.TOUCH(var: &EXPR)
      var OPD1 = OPD1; SDAI.TOUCH(var: &OPD1)
      var OPD2 = OPD2; SDAI.TOUCH(var: &OPD2)

      EXPR?.OPERANDS[1] = OPD1
      EXPR?.OPERANDS[2] = OPD2
      return eGENERIC_EXPRESSION(/*eBINARY_GENERIC_EXPRESSION*/EXPR)
    } //END FUNCTION RESTORE_BINARY

    //NESTED FUNCTION
    func RESTORE_UNARY(EXPR: eUNARY_GENERIC_EXPRESSION? , OPND: eGENERIC_EXPRESSION? ) 
      -> eGENERIC_EXPRESSION? {

      var EXPR = EXPR; SDAI.TOUCH(var: &EXPR)
      var OPND = OPND; SDAI.TOUCH(var: &OPND)

      EXPR?.OPERAND = SDAI.UNWRAP(OPND)
      return eGENERIC_EXPRESSION(/*eUNARY_GENERIC_EXPRESSION*/EXPR)
    } //END FUNCTION RESTORE_UNARY

    //LOCAL
    var TYPES: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(EXPR); SDAI.TOUCH(var: &TYPES)
    var V1: sMATHS_VALUE? 
    var V2: sMATHS_VALUE? 
    var VLIST: SDAI.LIST<sMATHS_VALUE>?  = SDAI.LIST<sMATHS_VALUE>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &VLIST)
    var OP1: eGENERIC_EXPRESSION? 
    var OP2: eGENERIC_EXPRESSION? 
    var OPLIST: SDAI.LIST<eGENERIC_EXPRESSION>?  = SDAI.LIST<eGENERIC_EXPRESSION>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &OPLIST)
    var OPNDS: (SDAI.LIST<eGENERIC_EXPRESSION>/*[2:nil]*/ )? 
    var N: SDAI.INTEGER? 
    var M: SDAI.INTEGER? 
    var FINFUN: sMATHS_FUNCTION_SELECT? 
    var BOO: SDAI.BOOLEAN? 
    var STR: SDAI.STRING? 
    var NMB: SDAI.NUMBER? 
    var V1_STRING: SDAI.STRING? 
    var V2_STRING: SDAI.STRING? 
    var V1_NUMBER: SDAI.NUMBER? 
    var V2_NUMBER: SDAI.NUMBER? 
    //END_LOCAL

    
    let _TEMP1 = SDAI.aggregate(TYPES, contains: SDAI.STRING("INT_LITERAL"))
    if SDAI.IS_TRUE( _TEMP1 ) {
      
      let _TEMP2 = EXPR?.GROUP_REF(eINT_LITERAL.self)
      let _TEMP3 = _TEMP2?.THE_VALUE
      let _TEMP4 = CONVERT_TO_MATHS_VALUE(_TEMP3)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP4)
    }
    
    let _TEMP5 = SDAI.aggregate(TYPES, contains: SDAI.STRING("REAL_LITERAL"))
    if SDAI.IS_TRUE( _TEMP5 ) {
      
      let _TEMP6 = EXPR?.GROUP_REF(eREAL_LITERAL.self)
      let _TEMP7 = _TEMP6?.THE_VALUE
      let _TEMP8 = CONVERT_TO_MATHS_VALUE(_TEMP7)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP8)
    }
    
    let _TEMP9 = SDAI.aggregate(TYPES, contains: SDAI.STRING("BOOLEAN_LITERAL"))
    if SDAI.IS_TRUE( _TEMP9 ) {
      
      let _TEMP10 = EXPR?.GROUP_REF(eBOOLEAN_LITERAL.self)
      let _TEMP11 = _TEMP10?.THE_VALUE
      let _TEMP12 = CONVERT_TO_MATHS_VALUE(_TEMP11)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP12)
    }
    
    let _TEMP13 = SDAI.aggregate(TYPES, contains: SDAI.STRING("STRING_LITERAL"))
    if SDAI.IS_TRUE( _TEMP13 ) {
      
      let _TEMP14 = EXPR?.GROUP_REF(eSTRING_LITERAL.self)
      let _TEMP15 = _TEMP14?.THE_VALUE
      let _TEMP16 = CONVERT_TO_MATHS_VALUE(_TEMP15)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP16)
    }
    
    let _TEMP17 = SDAI.aggregate(TYPES, contains: SDAI.STRING("COMPLEX_NUMBER_LITERAL"))
    if SDAI.IS_TRUE( _TEMP17 ) {
      return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        eGENERIC_EXPRESSION*/EXPR))
    }
    
    let _TEMP18 = SDAI.aggregate(TYPES, contains: SDAI.STRING("LOGICAL_LITERAL"))
    if SDAI.IS_TRUE( _TEMP18 ) {
      
      let _TEMP19 = EXPR?.GROUP_REF(eLOGICAL_LITERAL.self)
      let _TEMP20 = _TEMP19?.LIT_VALUE
      let _TEMP21 = CONVERT_TO_MATHS_VALUE(_TEMP20)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP21)
    }
    
    let _TEMP22 = SDAI.aggregate(TYPES, contains: SDAI.STRING("BINARY_LITERAL"))
    if SDAI.IS_TRUE( _TEMP22 ) {
      
      let _TEMP23 = EXPR?.GROUP_REF(eBINARY_LITERAL.self)
      let _TEMP24 = _TEMP23?.LIT_VALUE
      let _TEMP25 = CONVERT_TO_MATHS_VALUE(_TEMP24)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP25)
    }
    
    let _TEMP26 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MATHS_ENUM_LITERAL"))
    if SDAI.IS_TRUE( _TEMP26 ) {
      
      let _TEMP27 = EXPR?.GROUP_REF(eMATHS_ENUM_LITERAL.self)
      let _TEMP28 = _TEMP27?.LIT_VALUE
      return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        sMATHS_ENUM_ATOM*/_TEMP28))
    }
    
    let _TEMP29 = SDAI.aggregate(TYPES, contains: SDAI.STRING("REAL_TUPLE_LITERAL"))
    if SDAI.IS_TRUE( _TEMP29 ) {
      
      let _TEMP30 = EXPR?.GROUP_REF(eREAL_TUPLE_LITERAL.self)
      let _TEMP31 = _TEMP30?.LIT_VALUE
      let _TEMP32 = CONVERT_TO_MATHS_VALUE(_TEMP31)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP32)
    }
    
    let _TEMP33 = SDAI.aggregate(TYPES, contains: SDAI.STRING("INTEGER_TUPLE_LITERAL"))
    if SDAI.IS_TRUE( _TEMP33 ) {
      
      let _TEMP34 = EXPR?.GROUP_REF(eINTEGER_TUPLE_LITERAL.self)
      let _TEMP35 = _TEMP34?.LIT_VALUE
      let _TEMP36 = CONVERT_TO_MATHS_VALUE(_TEMP35)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP36)
    }
    
    let _TEMP37 = SDAI.aggregate(TYPES, contains: SDAI.STRING("ATOM_BASED_LITERAL"))
    if SDAI.IS_TRUE( _TEMP37 ) {
      
      let _TEMP38 = EXPR?.GROUP_REF(eATOM_BASED_LITERAL.self)
      let _TEMP39 = _TEMP38?.LIT_VALUE
      return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        sATOM_BASED_VALUE*/_TEMP39))
    }
    
    let _TEMP40 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MATHS_TUPLE_LITERAL"))
    if SDAI.IS_TRUE( _TEMP40 ) {
      
      let _TEMP41 = EXPR?.GROUP_REF(eMATHS_TUPLE_LITERAL.self)
      let _TEMP42 = _TEMP41?.LIT_VALUE
      let _TEMP43 = CONVERT_TO_MATHS_VALUE(_TEMP42)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP43)
    }
    
    let _TEMP44 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MATHS_SPACE"))
    if SDAI.IS_TRUE( _TEMP44 ) {
      
      let _TEMP45 = SIMPLIFY_MATHS_SPACE(eMATHS_SPACE(/*eGENERIC_EXPRESSION*/EXPR))
      return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        eMATHS_SPACE*/_TEMP45))
    }
    
    let _TEMP46 = SDAI.aggregate(TYPES, contains: SDAI.STRING("FUNCTION_APPLICATION"))
    if SDAI.IS_TRUE( _TEMP46 ) {
      
      let _TEMP47 = SIMPLIFY_FUNCTION_APPLICATION(eFUNCTION_APPLICATION(/*eGENERIC_EXPRESSION*/EXPR))
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP47)
    }
    
    let _TEMP48 = SDAI.aggregate(TYPES, contains: SDAI.STRING("UNARY_GENERIC_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP48 ) {
      
      let _TEMP49 = EXPR?.GROUP_REF(eUNARY_GENERIC_EXPRESSION.self)
      let _TEMP50 = _TEMP49?.OPERAND
      let _TEMP51 = SIMPLIFY_GENERIC_EXPRESSION(_TEMP50)
      V1 = _TEMP51
      
      let _TEMP52 = CONVERT_TO_OPERAND(V1)
      OP1 = _TEMP52
    }
    
    let _TEMP53 = SDAI.aggregate(TYPES, contains: SDAI.STRING("BINARY_GENERIC_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP53 ) {
      
      let _TEMP54 = EXPR?.GROUP_REF(eBINARY_GENERIC_EXPRESSION.self)
      let _TEMP55 = _TEMP54?.OPERANDS
      let _TEMP56 = _TEMP55?[1]
      let _TEMP57 = SIMPLIFY_GENERIC_EXPRESSION(_TEMP56)
      V1 = _TEMP57
      
      let _TEMP58 = CONVERT_TO_OPERAND(V1)
      OP1 = _TEMP58
      
      let _TEMP59 = EXPR?.GROUP_REF(eBINARY_GENERIC_EXPRESSION.self)
      let _TEMP60 = _TEMP59?.OPERANDS
      let _TEMP61 = _TEMP60?[2]
      let _TEMP62 = SIMPLIFY_GENERIC_EXPRESSION(_TEMP61)
      V2 = _TEMP62
      
      let _TEMP63 = CONVERT_TO_OPERAND(V2)
      OP2 = _TEMP63
    }
    
    let _TEMP64 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MULTIPLE_ARITY_GENERIC_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP64 ) {
      
      let _TEMP65 = EXPR?.GROUP_REF(eMULTIPLE_ARITY_GENERIC_EXPRESSION.self)
      let _TEMP66 = _TEMP65?.OPERANDS
      OPNDS = _TEMP66
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        OPNDS)) {
        for I in incrementControl {
          
          let _TEMP67 = OPNDS?[I]
          let _TEMP68 = SIMPLIFY_GENERIC_EXPRESSION(_TEMP67)
          V1 = _TEMP68
          SDAI.INSERT( L: &VLIST, E: V1, P: SDAI.FORCE_OPTIONAL(I) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) )
          SDAI.INSERT( L: &OPLIST, E: CONVERT_TO_OPERAND(V1), P: SDAI.FORCE_OPTIONAL(I) - SDAI.FORCE_OPTIONAL(
            SDAI.INTEGER(1)) )
        }
      }
    }
    
    let _TEMP69 = SDAI.aggregate(TYPES, contains: SDAI.STRING("PARALLEL_COMPOSED_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP69 ) {
      
      let _TEMP70 = VLIST?[1]
      V1 = _TEMP70
      
      let _TEMP71 = SDAI.SIZEOF(VLIST)
      N = _TEMP71
      
      let _TEMP72 = VLIST?[N]
      FINFUN = sMATHS_FUNCTION_SELECT(/*sMATHS_VALUE*/_TEMP72)
      SDAI.REMOVE( L: &VLIST, P: N )
      SDAI.REMOVE( L: &VLIST, P: 1 )
      
      let _TEMP73 = MAKE_PARALLEL_COMPOSED_FUNCTION(
        SRCDOM: sMATHS_SPACE_OR_FUNCTION(/*sMATHS_VALUE*/V1), 
        PREPFUNCS: SDAI.LIST<eMATHS_FUNCTION>(bound1: SDAI.UNWRAP(SDAI.INTEGER(2)), bound2: (nil as SDAI.INTEGER?), 
        /*SDAI.LIST<sMATHS_VALUE>*/VLIST), 
        FINFUNC: FINFUN)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        ePARALLEL_COMPOSED_FUNCTION*/_TEMP73))
    }
    
    let _TEMP74 = SDAI.aggregate(TYPES, contains: SDAI.STRING("ABS_EXPRESSION"))
    let _TEMP75 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP76 = _TEMP74 && _TEMP75
    if SDAI.IS_TRUE( _TEMP76 ) {
      
      let _TEMP77 = SDAI.ABS(V1)
      let _TEMP78 = CONVERT_TO_MATHS_VALUE(_TEMP77)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP78)
    }
    
    let _TEMP79 = SDAI.aggregate(TYPES, contains: SDAI.STRING("ACOS_EXPRESSION"))
    let _TEMP80 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP81 = _TEMP79 && _TEMP80
    if SDAI.IS_TRUE( _TEMP81 ) {
      
      let _TEMP82 = SDAI.ACOS(V1)
      let _TEMP83 = CONVERT_TO_MATHS_VALUE(_TEMP82)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP83)
    }
    
    let _TEMP84 = SDAI.aggregate(TYPES, contains: SDAI.STRING("AND_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP84 ) {
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
        VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
        for I in incrementControl {
          
          let _TEMP85 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.BOOLEAN.self)
          if SDAI.IS_TRUE( _TEMP85 ) {
            
            let _TEMP86 = VLIST?[I]
            BOO = SDAI.BOOLEAN(/*sMATHS_VALUE*/_TEMP86)
            if SDAI.IS_TRUE( (  !BOO ) ) {
              
              let _TEMP87 = CONVERT_TO_MATHS_VALUE(SDAI.FALSE)
              return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP87)
            }
            SDAI.REMOVE( L: &OPLIST, P: I )
          }
        }
      }
      
      let _TEMP88 = SDAI.SIZEOF(OPLIST)
      let _TEMP89 = _TEMP88 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP89 ) {
        
        let _TEMP90 = CONVERT_TO_MATHS_VALUE(SDAI.TRUE)
        return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP90)
      }
      
      let _TEMP91 = SDAI.SIZEOF(OPLIST)
      let _TEMP92 = _TEMP91 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      if SDAI.IS_TRUE( _TEMP92 ) {
        
        let _TEMP93 = OPLIST?[1]
        return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
          eGENERIC_EXPRESSION*/_TEMP93))
      }
    }
    
    let _TEMP94 = SDAI.aggregate(TYPES, contains: SDAI.STRING("ASIN_EXPRESSION"))
    let _TEMP95 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP96 = _TEMP94 && _TEMP95
    if SDAI.IS_TRUE( _TEMP96 ) {
      
      let _TEMP97 = SDAI.ASIN(V1)
      let _TEMP98 = CONVERT_TO_MATHS_VALUE(_TEMP97)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP98)
    }
    
    let _TEMP99 = SDAI.aggregate(TYPES, contains: SDAI.STRING("ATAN_EXPRESSION"))
    let _TEMP100 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP101 = _TEMP99 && _TEMP100
    let _TEMP102 = SDAI.TYPEOF(V2, IS: SDAI.NUMBER.self)
    let _TEMP103 = _TEMP101 && _TEMP102
    if SDAI.IS_TRUE( _TEMP103 ) {
      
      let _TEMP104 = SDAI.ATAN(V1: V1, 
                               V2: V2)
      let _TEMP105 = CONVERT_TO_MATHS_VALUE(_TEMP104)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP105)
    }
    
    let _TEMP106 = SDAI.aggregate(TYPES, contains: SDAI.STRING("COMPARISON_EXPRESSION"))
    let _TEMP107 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP108 = SDAI.TYPEOF(V2, IS: SDAI.NUMBER.self)
    let _TEMP109 = _TEMP107 && _TEMP108
    let _TEMP110 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
    let _TEMP111 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
    let _TEMP112 = _TEMP110 && _TEMP111
    let _TEMP113 = _TEMP109 || _TEMP112
    let _TEMP114 = SDAI.TYPEOF(V1, IS: SDAI.BOOLEAN.self)
    let _TEMP115 = SDAI.TYPEOF(V2, IS: SDAI.BOOLEAN.self)
    let _TEMP116 = _TEMP114 && _TEMP115
    let _TEMP117 = _TEMP113 || _TEMP116
    let _TEMP118 = _TEMP106 && _TEMP117
    if SDAI.IS_TRUE( _TEMP118 ) {
      
      let _TEMP119 = SDAI.aggregate(TYPES, contains: SDAI.STRING("COMPARISON_EQUAL"))
      if SDAI.IS_TRUE( _TEMP119 ) {
        
        let _TEMP120 = V1 .==. V2
        let _TEMP121 = BOOL(SDAI.LOGICAL(_TEMP120))
        BOO = _TEMP121
      }
      else {
        
        let _TEMP122 = SDAI.aggregate(TYPES, contains: SDAI.STRING("COMPARISON_GREATER"))
        if SDAI.IS_TRUE( _TEMP122 ) {
          
          let _TEMP123 = V1 > V2
          let _TEMP124 = BOOL(SDAI.LOGICAL(_TEMP123))
          BOO = _TEMP124
        }
        else {
          
          let _TEMP125 = SDAI.aggregate(TYPES, contains: SDAI.STRING("COMPARISON_GREATER_EQUAL"))
          if SDAI.IS_TRUE( _TEMP125 ) {
            
            let _TEMP126 = V1 >= V2
            let _TEMP127 = BOOL(SDAI.LOGICAL(_TEMP126))
            BOO = _TEMP127
          }
          else {
            
            let _TEMP128 = SDAI.aggregate(TYPES, contains: SDAI.STRING("COMPARISON_LESS"))
            if SDAI.IS_TRUE( _TEMP128 ) {
              
              let _TEMP129 = V1 < V2
              let _TEMP130 = BOOL(SDAI.LOGICAL(_TEMP129))
              BOO = _TEMP130
            }
            else {
              
              let _TEMP131 = SDAI.aggregate(TYPES, contains: SDAI.STRING("COMPARISON_LESS_EQUAL"))
              if SDAI.IS_TRUE( _TEMP131 ) {
                
                let _TEMP132 = V1 <= V2
                let _TEMP133 = BOOL(SDAI.LOGICAL(_TEMP132))
                BOO = _TEMP133
              }
              else {
                
                let _TEMP134 = SDAI.aggregate(TYPES, contains: SDAI.STRING("COMPARISON_NOT_EQUAL"))
                if SDAI.IS_TRUE( _TEMP134 ) {
                  
                  let _TEMP135 = V1 .!=. V2
                  let _TEMP136 = BOOL(SDAI.LOGICAL(_TEMP135))
                  BOO = _TEMP136
                }
                else {
                  
                  let _TEMP137 = SDAI.aggregate(TYPES, contains: SDAI.STRING("LIKE_EXPRESSION"))
                  if SDAI.IS_TRUE( _TEMP137 ) {
                    V1_STRING = SDAI.STRING(/*sMATHS_VALUE*/V1)
                    V2_STRING = SDAI.STRING(/*sMATHS_VALUE*/V2)
                    
                    let _TEMP138 = V1_STRING?.ISLIKE( PATTERN: V2_STRING )
                    let _TEMP139 = BOOL(SDAI.LOGICAL(_TEMP138))
                    BOO = _TEMP139
                  }
                  else {
                    return _simplify_generic_expression__cache.updateCache(params: _params, value: (nil as 
                      sMATHS_VALUE?))
                  }
                }
              }
            }
          }
        }
      }
      
      let _TEMP140 = CONVERT_TO_MATHS_VALUE(BOO)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP140)
    }
    
    let _TEMP141 = SDAI.aggregate(TYPES, contains: SDAI.STRING("CONCAT_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP141 ) {
      STR = SDAI.STRING("")
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
        VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
        for I in incrementControl {
          
          let _TEMP142 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.STRING.self)
          if SDAI.IS_TRUE( _TEMP142 ) {
            
            let _TEMP143 = VLIST?[I]
            let _TEMP144 = _TEMP143 + STR
            STR = SDAI.STRING(/*SDAI.INTEGER*/_TEMP144)
            SDAI.REMOVE( L: &OPLIST, P: I )
          }
          else {
            
            let _TEMP145 = SDAI.LENGTH(STR)
            let _TEMP146 = _TEMP145 > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
            if SDAI.IS_TRUE( _TEMP146 ) {
              SDAI.INSERT( L: &OPLIST, E: MAKE_STRING_LITERAL(STR), P: I )
              STR = SDAI.STRING("")
            }
          }
        }
      }
      
      let _TEMP147 = SDAI.SIZEOF(OPLIST)
      let _TEMP148 = _TEMP147 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP148 ) {
        
        let _TEMP149 = CONVERT_TO_MATHS_VALUE(STR)
        return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP149)
      }
      
      let _TEMP150 = SDAI.LENGTH(STR)
      let _TEMP151 = _TEMP150 > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP151 ) {
        SDAI.INSERT( L: &OPLIST, E: MAKE_STRING_LITERAL(STR), P: 0 )
      }
      
      let _TEMP152 = SDAI.SIZEOF(OPLIST)
      let _TEMP153 = _TEMP152 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      if SDAI.IS_TRUE( _TEMP153 ) {
        
        let _TEMP154 = OPLIST?[1]
        return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
          eGENERIC_EXPRESSION*/_TEMP154))
      }
    }
    
    let _TEMP155 = SDAI.aggregate(TYPES, contains: SDAI.STRING("COS_EXPRESSION"))
    let _TEMP156 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP157 = _TEMP155 && _TEMP156
    if SDAI.IS_TRUE( _TEMP157 ) {
      
      let _TEMP158 = SDAI.COS(V1)
      let _TEMP159 = CONVERT_TO_MATHS_VALUE(_TEMP158)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP159)
    }
    
    let _TEMP160 = SDAI.aggregate(TYPES, contains: SDAI.STRING("DIV_EXPRESSION"))
    let _TEMP161 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP162 = _TEMP160 && _TEMP161
    let _TEMP163 = SDAI.TYPEOF(V2, IS: SDAI.NUMBER.self)
    let _TEMP164 = _TEMP162 && _TEMP163
    if SDAI.IS_TRUE( _TEMP164 ) {
      V1_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V1)
      V2_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V2)
      
      let _TEMP165 = V1_NUMBER ./. V2_NUMBER
      let _TEMP166 = CONVERT_TO_MATHS_VALUE(_TEMP165)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP166)
    }
    
    let _TEMP167 = SDAI.aggregate(TYPES, contains: SDAI.STRING("EQUALS_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP167 ) {
      
      let _TEMP168 = EXPR?.GROUP_REF(eBINARY_GENERIC_EXPRESSION.self)
      let _TEMP169 = _TEMP168?.OPERANDS
      OPNDS = SDAI.LIST<eGENERIC_EXPRESSION>(bound1: SDAI.UNWRAP(SDAI.INTEGER(2)), bound2: (nil as SDAI.INTEGER?), 
        /*SDAI.LIST<eGENERIC_EXPRESSION>[2:2] */_TEMP169)
      
      let _TEMP170 = OPNDS?[1]
      let _TEMP171 = OPNDS?[2]
      let _TEMP172 = _TEMP170 .===. _TEMP171
      let _TEMP173 = CONVERT_TO_MATHS_VALUE(_TEMP172)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP173)
    }
    
    let _TEMP174 = SDAI.aggregate(TYPES, contains: SDAI.STRING("EXP_EXPRESSION"))
    let _TEMP175 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP176 = _TEMP174 && _TEMP175
    if SDAI.IS_TRUE( _TEMP176 ) {
      
      let _TEMP177 = SDAI.EXP(V1)
      let _TEMP178 = CONVERT_TO_MATHS_VALUE(_TEMP177)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP178)
    }
    
    let _TEMP179 = SDAI.aggregate(TYPES, contains: SDAI.STRING("FORMAT_EXPRESSION"))
    let _TEMP180 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP181 = _TEMP179 && _TEMP180
    let _TEMP182 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
    let _TEMP183 = _TEMP181 && _TEMP182
    if SDAI.IS_TRUE( _TEMP183 ) {
      
      let _TEMP184 = SDAI.FORMAT(N: V1, 
                                 F: V2)
      let _TEMP185 = CONVERT_TO_MATHS_VALUE(_TEMP184)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP185)
    }
    
    let _TEMP186 = SDAI.aggregate(TYPES, contains: SDAI.STRING("INDEX_EXPRESSION"))
    let _TEMP187 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
    let _TEMP188 = _TEMP186 && _TEMP187
    let _TEMP189 = SDAI.TYPEOF(V2, IS: SDAI.NUMBER.self)
    let _TEMP190 = _TEMP188 && _TEMP189
    if SDAI.IS_TRUE( _TEMP190 ) {
      STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
      N = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
      
      let _TEMP191 = STR?[N]
      let _TEMP192 = CONVERT_TO_MATHS_VALUE(_TEMP191)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP192)
    }
    
    let _TEMP193 = SDAI.aggregate(TYPES, contains: SDAI.STRING("INT_VALUE_EXPRESSION"))
    let _TEMP194 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
    let _TEMP195 = _TEMP193 && _TEMP194
    if SDAI.IS_TRUE( _TEMP195 ) {
      
      let _TEMP196 = SDAI.VALUE(V1)
      let _TEMP197 = CONVERT_TO_MATHS_VALUE(_TEMP196)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP197)
    }
    
    let _TEMP198 = SDAI.aggregate(TYPES, contains: SDAI.STRING("INTERVAL_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP198 ) {
      STR = SDAI.STRING("")
      
      let _TEMP199 = SDAI.TYPEOF(VLIST?[1], IS: SDAI.NUMBER.self)
      if SDAI.IS_TRUE( _TEMP199 ) {
        STR = SDAI.STRING("NUMBER")
      }
      
      let _TEMP200 = SDAI.TYPEOF(VLIST?[1], IS: SDAI.STRING.self)
      if SDAI.IS_TRUE( _TEMP200 ) {
        STR = SDAI.STRING("STRING")
      }
      
      let _TEMP201 = SDAI.TYPEOF(VLIST?[1], IS: SDAI.BOOLEAN.self)
      if SDAI.IS_TRUE( _TEMP201 ) {
        STR = SDAI.STRING("BOOLEAN")
      }
      
      let _TEMP202 = SDAI.LENGTH(STR)
      let _TEMP203 = _TEMP202 > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      let _TEMP204 = VLIST?[2]
      let _TEMP205 = SDAI.TYPEOF(_TEMP204)
      let _TEMP206 = SDAI.aggregate(_TEMP205, contains: STR)
      let _TEMP207 = _TEMP203 && _TEMP206
      let _TEMP208 = VLIST?[3]
      let _TEMP209 = SDAI.TYPEOF(_TEMP208)
      let _TEMP210 = SDAI.aggregate(_TEMP209, contains: STR)
      let _TEMP211 = _TEMP207 && _TEMP210
      if SDAI.IS_TRUE( _TEMP211 ) {
        
        let _TEMP212 = VLIST?[1]
        let _TEMP213 = VLIST?[2]
        let _TEMP214 = _TEMP212 <= _TEMP213
        let _TEMP215 = VLIST?[2]
        let _TEMP216 = VLIST?[3]
        let _TEMP217 = _TEMP215 <= _TEMP216
        let _TEMP218 = _TEMP214 && _TEMP217
        let _TEMP219 = CONVERT_TO_MATHS_VALUE(_TEMP218)
        return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP219)
      }
    }
    
    let _TEMP220 = SDAI.aggregate(TYPES, contains: SDAI.STRING("LENGTH_EXPRESSION"))
    let _TEMP221 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
    let _TEMP222 = _TEMP220 && _TEMP221
    if SDAI.IS_TRUE( _TEMP222 ) {
      
      let _TEMP223 = SDAI.LENGTH(V1)
      let _TEMP224 = CONVERT_TO_MATHS_VALUE(_TEMP223)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP224)
    }
    
    let _TEMP225 = SDAI.aggregate(TYPES, contains: SDAI.STRING("LOG_EXPRESSION"))
    let _TEMP226 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP227 = _TEMP225 && _TEMP226
    if SDAI.IS_TRUE( _TEMP227 ) {
      
      let _TEMP228 = SDAI.LOG(V1)
      let _TEMP229 = CONVERT_TO_MATHS_VALUE(_TEMP228)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP229)
    }
    
    let _TEMP230 = SDAI.aggregate(TYPES, contains: SDAI.STRING("LOG10_EXPRESSION"))
    let _TEMP231 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP232 = _TEMP230 && _TEMP231
    if SDAI.IS_TRUE( _TEMP232 ) {
      
      let _TEMP233 = SDAI.LOG10(V1)
      let _TEMP234 = CONVERT_TO_MATHS_VALUE(_TEMP233)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP234)
    }
    
    let _TEMP235 = SDAI.aggregate(TYPES, contains: SDAI.STRING("LOG2_EXPRESSION"))
    let _TEMP236 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP237 = _TEMP235 && _TEMP236
    if SDAI.IS_TRUE( _TEMP237 ) {
      
      let _TEMP238 = SDAI.LOG2(V1)
      let _TEMP239 = CONVERT_TO_MATHS_VALUE(_TEMP238)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP239)
    }
    
    let _TEMP240 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MAXIMUM_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP240 ) {
      BOO = SDAI.BOOLEAN(SDAI.FALSE)
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
        VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
        for I in incrementControl {
          
          let _TEMP241 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.NUMBER.self)
          if SDAI.IS_TRUE( _TEMP241 ) {
            if SDAI.IS_TRUE( BOO ) {
              
              let _TEMP242 = VLIST?[I]
              let _TEMP243 = NMB < _TEMP242
              if SDAI.IS_TRUE( _TEMP243 ) {
                
                let _TEMP244 = VLIST?[I]
                NMB = SDAI.NUMBER(/*sMATHS_VALUE*/_TEMP244)
              }
            }
            else {
              
              let _TEMP245 = VLIST?[I]
              NMB = SDAI.NUMBER(/*sMATHS_VALUE*/_TEMP245)
              BOO = SDAI.BOOLEAN(SDAI.TRUE)
            }
            SDAI.REMOVE( L: &OPLIST, P: I )
          }
        }
      }
      
      let _TEMP246 = SDAI.SIZEOF(OPLIST)
      let _TEMP247 = _TEMP246 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP247 ) {
        
        let _TEMP248 = CONVERT_TO_MATHS_VALUE(NMB)
        return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP248)
      }
      if SDAI.IS_TRUE( BOO ) {
        SDAI.INSERT( L: &OPLIST, E: MAKE_NUMBER_LITERAL(NMB), P: 0 )
      }
    }
    
    let _TEMP249 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MINIMUM_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP249 ) {
      BOO = SDAI.BOOLEAN(SDAI.FALSE)
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
        VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
        for I in incrementControl {
          
          let _TEMP250 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.NUMBER.self)
          if SDAI.IS_TRUE( _TEMP250 ) {
            if SDAI.IS_TRUE( BOO ) {
              
              let _TEMP251 = VLIST?[I]
              let _TEMP252 = NMB > _TEMP251
              if SDAI.IS_TRUE( _TEMP252 ) {
                
                let _TEMP253 = VLIST?[I]
                NMB = SDAI.NUMBER(/*sMATHS_VALUE*/_TEMP253)
              }
            }
            else {
              
              let _TEMP254 = VLIST?[I]
              NMB = SDAI.NUMBER(/*sMATHS_VALUE*/_TEMP254)
              BOO = SDAI.BOOLEAN(SDAI.TRUE)
            }
            SDAI.REMOVE( L: &OPLIST, P: I )
          }
        }
      }
      
      let _TEMP255 = SDAI.SIZEOF(OPLIST)
      let _TEMP256 = _TEMP255 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP256 ) {
        
        let _TEMP257 = CONVERT_TO_MATHS_VALUE(NMB)
        return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP257)
      }
      if SDAI.IS_TRUE( BOO ) {
        SDAI.INSERT( L: &OPLIST, E: MAKE_NUMBER_LITERAL(NMB), P: 0 )
      }
    }
    
    let _TEMP258 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MINUS_EXPRESSION"))
    let _TEMP259 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP260 = _TEMP258 && _TEMP259
    let _TEMP261 = SDAI.TYPEOF(V2, IS: SDAI.NUMBER.self)
    let _TEMP262 = _TEMP260 && _TEMP261
    if SDAI.IS_TRUE( _TEMP262 ) {
      V1_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V1)
      V2_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V2)
      
      let _TEMP263 = V1_NUMBER - V2_NUMBER
      let _TEMP264 = CONVERT_TO_MATHS_VALUE(_TEMP263)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP264)
    }
    
    let _TEMP265 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MOD_EXPRESSION"))
    let _TEMP266 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP267 = _TEMP265 && _TEMP266
    let _TEMP268 = SDAI.TYPEOF(V2, IS: SDAI.NUMBER.self)
    let _TEMP269 = _TEMP267 && _TEMP268
    if SDAI.IS_TRUE( _TEMP269 ) {
      V1_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V1)
      V2_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V2)
      
      let _TEMP270 = V1_NUMBER % V2_NUMBER
      let _TEMP271 = CONVERT_TO_MATHS_VALUE(_TEMP270)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP271)
    }
    
    let _TEMP272 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MULT_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP272 ) {
      NMB = SDAI.NUMBER(1)
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
        VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
        for I in incrementControl {
          
          let _TEMP273 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.NUMBER.self)
          if SDAI.IS_TRUE( _TEMP273 ) {
            
            let _TEMP274 = VLIST?[I]
            let _TEMP275 = NMB * _TEMP274
            NMB = SDAI.NUMBER(/*SDAI.INTEGER*/_TEMP275)
            SDAI.REMOVE( L: &OPLIST, P: I )
          }
        }
      }
      
      let _TEMP276 = SDAI.SIZEOF(OPLIST)
      let _TEMP277 = _TEMP276 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP277 ) {
        
        let _TEMP278 = CONVERT_TO_MATHS_VALUE(NMB)
        return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP278)
      }
      
      let _TEMP279 = NMB .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      if SDAI.IS_TRUE( _TEMP279 ) {
        SDAI.INSERT( L: &OPLIST, E: MAKE_NUMBER_LITERAL(NMB), P: 0 )
      }
      
      let _TEMP280 = SDAI.SIZEOF(OPLIST)
      let _TEMP281 = _TEMP280 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      if SDAI.IS_TRUE( _TEMP281 ) {
        
        let _TEMP282 = OPLIST?[1]
        return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
          eGENERIC_EXPRESSION*/_TEMP282))
      }
    }
    
    let _TEMP283 = SDAI.aggregate(TYPES, contains: SDAI.STRING("NOT_EXPRESSION"))
    let _TEMP284 = SDAI.TYPEOF(V1, IS: SDAI.BOOLEAN.self)
    let _TEMP285 = _TEMP283 && _TEMP284
    if SDAI.IS_TRUE( _TEMP285 ) {
      BOO = SDAI.BOOLEAN(/*sMATHS_VALUE*/V1)
      
      let _TEMP286 = CONVERT_TO_MATHS_VALUE( !BOO)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP286)
    }
    
    let _TEMP287 = SDAI.aggregate(TYPES, contains: SDAI.STRING("ODD_EXPRESSION"))
    let _TEMP288 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
    let _TEMP289 = _TEMP287 && _TEMP288
    if SDAI.IS_TRUE( _TEMP289 ) {
      
      let _TEMP290 = SDAI.ODD(V1)
      let _TEMP291 = CONVERT_TO_MATHS_VALUE(_TEMP290)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP291)
    }
    
    let _TEMP292 = SDAI.aggregate(TYPES, contains: SDAI.STRING("OR_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP292 ) {
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
        VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
        for I in incrementControl {
          
          let _TEMP293 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.BOOLEAN.self)
          if SDAI.IS_TRUE( _TEMP293 ) {
            
            let _TEMP294 = VLIST?[I]
            BOO = SDAI.BOOLEAN(/*sMATHS_VALUE*/_TEMP294)
            if SDAI.IS_TRUE( BOO ) {
              
              let _TEMP295 = CONVERT_TO_MATHS_VALUE(SDAI.TRUE)
              return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP295)
            }
            SDAI.REMOVE( L: &OPLIST, P: I )
          }
        }
      }
      
      let _TEMP296 = SDAI.SIZEOF(OPLIST)
      let _TEMP297 = _TEMP296 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP297 ) {
        
        let _TEMP298 = CONVERT_TO_MATHS_VALUE(SDAI.FALSE)
        return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP298)
      }
      
      let _TEMP299 = SDAI.SIZEOF(OPLIST)
      let _TEMP300 = _TEMP299 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      if SDAI.IS_TRUE( _TEMP300 ) {
        
        let _TEMP301 = OPLIST?[1]
        return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
          eGENERIC_EXPRESSION*/_TEMP301))
      }
    }
    
    let _TEMP302 = SDAI.aggregate(TYPES, contains: SDAI.STRING("PLUS_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP302 ) {
      NMB = SDAI.NUMBER(0)
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
        VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
        for I in incrementControl {
          
          let _TEMP303 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.NUMBER.self)
          if SDAI.IS_TRUE( _TEMP303 ) {
            
            let _TEMP304 = VLIST?[I]
            let _TEMP305 = NMB + _TEMP304
            NMB = SDAI.NUMBER(/*SDAI.INTEGER*/_TEMP305)
            SDAI.REMOVE( L: &OPLIST, P: I )
          }
        }
      }
      
      let _TEMP306 = SDAI.SIZEOF(OPLIST)
      let _TEMP307 = _TEMP306 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP307 ) {
        
        let _TEMP308 = CONVERT_TO_MATHS_VALUE(NMB)
        return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP308)
      }
      
      let _TEMP309 = NMB .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP309 ) {
        SDAI.INSERT( L: &OPLIST, E: MAKE_NUMBER_LITERAL(NMB), P: 0 )
      }
      
      let _TEMP310 = SDAI.SIZEOF(OPLIST)
      let _TEMP311 = _TEMP310 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      if SDAI.IS_TRUE( _TEMP311 ) {
        
        let _TEMP312 = OPLIST?[1]
        return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
          eGENERIC_EXPRESSION*/_TEMP312))
      }
    }
    
    let _TEMP313 = SDAI.aggregate(TYPES, contains: SDAI.STRING("POWER_EXPRESSION"))
    let _TEMP314 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP315 = _TEMP313 && _TEMP314
    let _TEMP316 = SDAI.TYPEOF(V2, IS: SDAI.NUMBER.self)
    let _TEMP317 = _TEMP315 && _TEMP316
    if SDAI.IS_TRUE( _TEMP317 ) {
      V1_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V1)
      V2_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V2)
      
      let _TEMP318 = V1_NUMBER ** V2_NUMBER
      let _TEMP319 = CONVERT_TO_MATHS_VALUE(_TEMP318)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP319)
    }
    
    let _TEMP320 = SDAI.aggregate(TYPES, contains: SDAI.STRING("SIN_EXPRESSION"))
    let _TEMP321 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP322 = _TEMP320 && _TEMP321
    if SDAI.IS_TRUE( _TEMP322 ) {
      
      let _TEMP323 = SDAI.SIN(V1)
      let _TEMP324 = CONVERT_TO_MATHS_VALUE(_TEMP323)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP324)
    }
    
    let _TEMP325 = SDAI.aggregate(TYPES, contains: SDAI.STRING("SLASH_EXPRESSION"))
    let _TEMP326 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP327 = _TEMP325 && _TEMP326
    let _TEMP328 = SDAI.TYPEOF(V2, IS: SDAI.NUMBER.self)
    let _TEMP329 = _TEMP327 && _TEMP328
    if SDAI.IS_TRUE( _TEMP329 ) {
      V1_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V1)
      V2_NUMBER = SDAI.NUMBER(/*sMATHS_VALUE*/V2)
      
      let _TEMP330 = V1_NUMBER / V2_NUMBER
      let _TEMP331 = CONVERT_TO_MATHS_VALUE(_TEMP330)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP331)
    }
    
    let _TEMP332 = SDAI.aggregate(TYPES, contains: SDAI.STRING("SQUARE_ROOT_EXPRESSION"))
    let _TEMP333 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP334 = _TEMP332 && _TEMP333
    if SDAI.IS_TRUE( _TEMP334 ) {
      
      let _TEMP335 = SDAI.SQRT(V1)
      let _TEMP336 = CONVERT_TO_MATHS_VALUE(_TEMP335)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP336)
    }
    
    let _TEMP337 = SDAI.aggregate(TYPES, contains: SDAI.STRING("SUBSTRING_EXPRESSION"))
    let _TEMP338 = SDAI.TYPEOF(VLIST?[1], IS: SDAI.STRING.self)
    let _TEMP339 = _TEMP337 && _TEMP338
    let _TEMP340 = SDAI.TYPEOF(VLIST?[2], IS: SDAI.NUMBER.self)
    let _TEMP341 = _TEMP339 && _TEMP340
    let _TEMP342 = SDAI.TYPEOF(VLIST?[3], IS: SDAI.NUMBER.self)
    let _TEMP343 = _TEMP341 && _TEMP342
    if SDAI.IS_TRUE( _TEMP343 ) {
      
      let _TEMP344 = VLIST?[1]
      STR = SDAI.STRING(/*sMATHS_VALUE*/_TEMP344)
      
      let _TEMP345 = VLIST?[2]
      N = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP345)
      
      let _TEMP346 = VLIST?[3]
      M = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP346)
      
      let _TEMP347 = STR?[N ... M]
      let _TEMP348 = CONVERT_TO_MATHS_VALUE(_TEMP347)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP348)
    }
    
    let _TEMP349 = SDAI.aggregate(TYPES, contains: SDAI.STRING("TAN_EXPRESSION"))
    let _TEMP350 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP351 = _TEMP349 && _TEMP350
    if SDAI.IS_TRUE( _TEMP351 ) {
      
      let _TEMP352 = SDAI.TAN(V1)
      let _TEMP353 = CONVERT_TO_MATHS_VALUE(_TEMP352)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP353)
    }
    
    let _TEMP354 = SDAI.aggregate(TYPES, contains: SDAI.STRING("UNARY_MINUS_EXPRESSION"))
    let _TEMP355 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
    let _TEMP356 = _TEMP354 && _TEMP355
    if SDAI.IS_TRUE( _TEMP356 ) {
      NMB = SDAI.NUMBER(/*sMATHS_VALUE*/V1)
      
      let _TEMP357 = CONVERT_TO_MATHS_VALUE( -NMB)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP357)
    }
    
    let _TEMP358 = SDAI.aggregate(TYPES, contains: SDAI.STRING("VALUE_EXPRESSION"))
    let _TEMP359 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
    let _TEMP360 = _TEMP358 && _TEMP359
    if SDAI.IS_TRUE( _TEMP360 ) {
      
      let _TEMP361 = SDAI.VALUE(V1)
      let _TEMP362 = CONVERT_TO_MATHS_VALUE(_TEMP361)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP362)
    }
    
    let _TEMP363 = SDAI.aggregate(TYPES, contains: SDAI.STRING("XOR_EXPRESSION"))
    let _TEMP364 = SDAI.TYPEOF(V1, IS: SDAI.BOOLEAN.self)
    let _TEMP365 = _TEMP363 && _TEMP364
    let _TEMP366 = SDAI.TYPEOF(V2, IS: SDAI.BOOLEAN.self)
    let _TEMP367 = _TEMP365 && _TEMP366
    if SDAI.IS_TRUE( _TEMP367 ) {
      
      let _TEMP368 = V1 .!=. V2
      let _TEMP369 = CONVERT_TO_MATHS_VALUE(_TEMP368)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: _TEMP369)
    }
    
    let _TEMP370 = SDAI.aggregate(TYPES, contains: SDAI.STRING("UNARY_GENERIC_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP370 ) {
      
      let _TEMP371 = RESTORE_UNARY(EXPR: eUNARY_GENERIC_EXPRESSION(/*eGENERIC_EXPRESSION*/EXPR), 
                                   OPND: OP1)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        eGENERIC_EXPRESSION*/_TEMP371))
    }
    
    let _TEMP372 = SDAI.aggregate(TYPES, contains: SDAI.STRING("BINARY_GENERIC_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP372 ) {
      
      let _TEMP373 = RESTORE_BINARY(
        EXPR: eBINARY_GENERIC_EXPRESSION(/*eGENERIC_EXPRESSION*/EXPR), 
        OPD1: OP1, OPD2: OP2)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        eGENERIC_EXPRESSION*/_TEMP373))
    }
    
    let _TEMP374 = SDAI.aggregate(TYPES, contains: SDAI.STRING("MULTIPLE_ARITY_GENERIC_EXPRESSION"))
    if SDAI.IS_TRUE( _TEMP374 ) {
      
      let _TEMP375 = RESTORE_MULARY(
        EXPR: eMULTIPLE_ARITY_GENERIC_EXPRESSION(/*eGENERIC_EXPRESSION*/EXPR), 
        OPS: OPLIST)
      return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        eGENERIC_EXPRESSION*/_TEMP375))
    }
    return _simplify_generic_expression__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
      eGENERIC_EXPRESSION*/EXPR))
  }

}

//MARK: - function result cache
private var _simplify_generic_expression__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

