/* file: simplify_function_application.swift 	 generated: Sat Aug 14 13:46:02 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION simplify_function_application(
               expr : function_application
           ) : maths_value;

    FUNCTION ctmv(
                 x : GENERIC:g
             ) : maths_value;
      RETURN( convert_to_maths_value( x ) );

    END_FUNCTION; -- ctmv (line:44320 file:ap242ed2_mim_lf_v1.101.TY.exp)

    FUNCTION good_t(
                 v : maths_value;
                 tn : STRING
             ) : BOOLEAN;

      LOCAL
        tpl : LIST OF maths_value;
      END_LOCAL;
      IF 'LIST' IN TYPEOF( v ) THEN
        tpl := v;
        REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
          IF NOT ( tn IN TYPEOF( tpl[i] ) ) THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        RETURN( TRUE );
      END_IF;
      RETURN( FALSE );

    END_FUNCTION; -- good_t (line:44331 file:ap242ed2_mim_lf_v1.101.TY.exp)

    FUNCTION makec(
                 x : REAL;
                 y : REAL
             ) : complex_number_literal;
      RETURN( make_complex_number_literal( x, y ) );

    END_FUNCTION; -- makec (line:44327 file:ap242ed2_mim_lf_v1.101.TY.exp)

    PROCEDURE parts(
                  c : complex_number_literal;
                  VAR x : REAL;
                  VAR y : REAL      );
      x := c.real_part;
      y := c.imag_part;

    END_PROCEDURE; -- parts (line:44323 file:ap242ed2_mim_lf_v1.101.TY.exp)

    CONSTANT
      cnlit : STRING :=
               schema_prefix + 'COMPLEX_NUMBER_LITERAL';
    END_CONSTANT;

    LOCAL
      types         : SET OF STRING := stripped_typeof( expr.func );
      ef_val        : elementary_function_enumerators;
      is_elementary : BOOLEAN := FALSE;
      v             : maths_value;
      v1            : maths_value;
      v2            : maths_value;
      v3            : maths_value;
      vlist         : LIST OF maths_value := [];
      gexpr         : generic_expression;
      pairs         : SET [1 : ?] OF LIST [2 : 2] OF maths_value;
      boo           : BOOLEAN;
      lgc           : LOGICAL;
      cum           : LOGICAL;
      j             : INTEGER;
      k             : INTEGER;
      n             : INTEGER;
      p             : REAL;
      q             : REAL;
      r             : REAL;
      s             : REAL;
      t             : REAL;
      u             : REAL;
      str           : STRING;
      st2           : STRING;
      bin           : BINARY;
      bi2           : BINARY;
      tpl           : LIST OF maths_value;
      tp2           : LIST OF maths_value;
      mem           : SET OF maths_value := [];
      v1_string     : STRING;
      v2_string     : STRING;
      tpl_integer   : INTEGER;
      tp2_integer   : INTEGER;
      tpl_real      : REAL;
      tp2_real      : REAL;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF( expr.arguments ) BY 1;
      v := simplify_maths_value( expr.arguments[i] );
      INSERT( vlist, v, i - 1 );
    END_REPEAT;
    IF SIZEOF( vlist ) >= 1 THEN
      v1 := vlist[1];
    END_IF;
    IF SIZEOF( vlist ) >= 2 THEN
      v2 := vlist[2];
    END_IF;
    IF SIZEOF( vlist ) >= 3 THEN
      v3 := vlist[3];
    END_IF;
    IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types THEN
      ef_val := expr.func;
      is_elementary := TRUE;
    END_IF;
    IF 'ELEMENTARY_FUNCTION' IN types THEN
      ef_val := expr.func\elementary_function.func_id;
      is_elementary := TRUE;
    END_IF;
    IF is_elementary THEN
      CASE ef_val OF
        ef_and                    : 
          BEGIN
            cum := TRUE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'LOGICAL' IN TYPEOF( vlist[i] ) THEN
                lgc := vlist[i];
                cum := cum AND lgc;
                IF lgc = FALSE THEN
                  RETURN( ctmv( FALSE ) );
                END_IF;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( cum ) );
            END_IF;
            IF cum <> TRUE THEN
              INSERT( vlist, ctmv( cum ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_or                     : 
          BEGIN
            cum := FALSE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'LOGICAL' IN TYPEOF( vlist[i] ) THEN
                lgc := vlist[i];
                cum := cum OR lgc;
                IF lgc = TRUE THEN
                  RETURN( ctmv( TRUE ) );
                END_IF;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( cum ) );
            END_IF;
            IF cum <> FALSE THEN
              INSERT( vlist, ctmv( cum ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_not                    :           IF 'LOGICAL' IN TYPEOF( v1 ) THEN
            lgc := v1;
            RETURN( ctmv( NOT lgc ) );
          END_IF;
        ef_xor                    : 
          BEGIN
            IF 'LOGICAL' IN TYPEOF( v1 ) THEN
              lgc := v1;
              IF 'LOGICAL' IN TYPEOF( v2 ) THEN
                cum := v2;
                RETURN( ctmv( lgc XOR cum ) );
              ELSE
                IF lgc = FALSE THEN
                  RETURN( ctmv( v2 ) );
                ELSE
                  IF lgc = UNKNOWN THEN
                    RETURN( ctmv( UNKNOWN ) );
                  ELSE
                    RETURN( make_function_application( ef_not, [v2] ) );
                  END_IF;
                END_IF;
              END_IF;
            ELSE
              IF 'LOGICAL' IN TYPEOF( v2 ) THEN
                lgc := v2;
                IF lgc = FALSE THEN
                  RETURN( ctmv( v1 ) );
                ELSE
                  IF lgc = UNKNOWN THEN
                    RETURN( ctmv( UNKNOWN ) );
                  ELSE
                    RETURN( make_function_application( ef_not, [v1] ) );
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END;
        ef_negate_i               :           IF 'INTEGER' IN TYPEOF( v1 ) THEN
            j := v1;
            RETURN( ctmv( -j ) );
          END_IF;
        ef_add_i                  : 
          BEGIN
            j := 0;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'INTEGER' IN TYPEOF( vlist[i] ) THEN
                k := vlist[i];
                j := j + k;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( j ) );
            END_IF;
            IF j <> 0 THEN
              INSERT( vlist, ctmv( j ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_subtract_i             :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            RETURN( ctmv( j - k ) );
          END_IF;
        ef_multiply_i             : 
          BEGIN
            j := 1;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'INTEGER' IN TYPEOF( vlist[i] ) THEN
                k := vlist[i];
                j := j * k;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( j ) );
            END_IF;
            IF j <> 1 THEN
              INSERT( vlist, ctmv( j ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_divide_i               :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            RETURN( ctmv( j DIV k ) );
          END_IF;
        ef_mod_i                  :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            RETURN( ctmv( j MOD k ) );
          END_IF;
        ef_exponentiate_i         :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            n := 1;
            REPEAT i := 1 TO ABS( k ) BY 1;
              n := n * j;
            END_REPEAT;
            IF k < 0 THEN
              n := 1 DIV n;
            END_IF;
            RETURN( ctmv( n ) );
          END_IF;
        ef_eq_i                   :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            RETURN( ctmv( j = k ) );
          END_IF;
        ef_ne_i                   :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            RETURN( ctmv( j <> k ) );
          END_IF;
        ef_gt_i                   :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            RETURN( ctmv( j > k ) );
          END_IF;
        ef_lt_i                   :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            RETURN( ctmv( j < k ) );
          END_IF;
        ef_ge_i                   :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            RETURN( ctmv( j >= k ) );
          END_IF;
        ef_le_i                   :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            j := v1;
            k := v2;
            RETURN( ctmv( j <= k ) );
          END_IF;
        ef_abs_i                  :           IF 'INTEGER' IN TYPEOF( v1 ) THEN
            j := v1;
            RETURN( ctmv( ABS( j ) ) );
          END_IF;
        ef_max_i                  : 
          BEGIN
            boo := FALSE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'INTEGER' IN TYPEOF( vlist[i] ) THEN
                IF boo THEN
                  k := vlist[i];
                  IF k > j THEN
                    j := k;
                  END_IF;
                ELSE
                  j := vlist[i];
                  boo := TRUE;
                END_IF;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( j ) );
            END_IF;
            IF boo THEN
              INSERT( vlist, ctmv( j ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_min_i                  : 
          BEGIN
            boo := FALSE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'INTEGER' IN TYPEOF( vlist[i] ) THEN
                IF boo THEN
                  k := vlist[i];
                  IF k < j THEN
                    j := k;
                  END_IF;
                ELSE
                  j := vlist[i];
                  boo := TRUE;
                END_IF;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( j ) );
            END_IF;
            IF boo THEN
              INSERT( vlist, ctmv( j ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_negate_r               :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( -r ) );
          END_IF;
        ef_reciprocal_r           :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( 1 / r ) );
          END_IF;
        ef_add_r                  : 
          BEGIN
            r := 0;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'REAL' IN TYPEOF( vlist[i] ) THEN
                s := vlist[i];
                r := r + s;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( r ) );
            END_IF;
            IF r <> 0 THEN
              INSERT( vlist, ctmv( r ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_subtract_r             :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( r - s ) );
          END_IF;
        ef_multiply_r             : 
          BEGIN
            r := 1;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'REAL' IN TYPEOF( vlist[i] ) THEN
                s := vlist[i];
                r := r * s;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( r ) );
            END_IF;
            IF r <> 1 THEN
              INSERT( vlist, ctmv( r ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_divide_r               :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( r / s ) );
          END_IF;
        ef_mod_r                  :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            t := r / s;
            j := t DIV 1;
            IF ( t < 0 ) AND ( j <> t ) THEN
              j := j - 1;
            END_IF;
            RETURN( ctmv( r - ( j * s ) ) );
          END_IF;
        ef_exponentiate_r         :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( r ** s ) );
          END_IF;
        ef_exponentiate_ri        :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            k := v2;
            t := 1;
            REPEAT i := 1 TO ABS( k ) BY 1;
              t := t * r;
            END_REPEAT;
            IF k < 0 THEN
              t := 1 / t;
            END_IF;
            RETURN( ctmv( t ) );
          END_IF;
        ef_eq_r                   :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( r = s ) );
          END_IF;
        ef_ne_r                   :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( r <> s ) );
          END_IF;
        ef_gt_r                   :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( r > s ) );
          END_IF;
        ef_lt_r                   :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( r < s ) );
          END_IF;
        ef_ge_r                   :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( r >= s ) );
          END_IF;
        ef_le_r                   :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( r <= s ) );
          END_IF;
        ef_abs_r                  :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( ABS( r ) ) );
          END_IF;
        ef_max_r                  : 
          BEGIN
            boo := FALSE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'REAL' IN TYPEOF( vlist[i] ) THEN
                IF boo THEN
                  s := vlist[i];
                  IF s > r THEN
                    r := s;
                  END_IF;
                ELSE
                  r := vlist[i];
                  boo := TRUE;
                END_IF;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( r ) );
            END_IF;
            IF boo THEN
              INSERT( vlist, ctmv( r ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_min_r                  : 
          BEGIN
            boo := FALSE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'REAL' IN TYPEOF( vlist[i] ) THEN
                IF boo THEN
                  s := vlist[i];
                  IF s < r THEN
                    r := s;
                  END_IF;
                ELSE
                  r := vlist[i];
                  boo := TRUE;
                END_IF;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( r ) );
            END_IF;
            IF boo THEN
              INSERT( vlist, ctmv( r ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_acos_r                 :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( ACOS( r ) ) );
          END_IF;
        ef_asin_r                 :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( ASIN( r ) ) );
          END_IF;
        ef_atan2_r                :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( ctmv( atan2( r, s ) ) );
          END_IF;
        ef_cos_r                  :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( COS( r ) ) );
          END_IF;
        ef_exp_r                  :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( EXP( r ) ) );
          END_IF;
        ef_ln_r                   :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( LOG( r ) ) );
          END_IF;
        ef_log2_r                 :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( LOG2( r ) ) );
          END_IF;
        ef_log10_r                :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( LOG10( r ) ) );
          END_IF;
        ef_sin_r                  :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( SIN( r ) ) );
          END_IF;
        ef_sqrt_r                 :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( SQRT( r ) ) );
          END_IF;
        ef_tan_r                  :           IF 'REAL' IN TYPEOF( v1 ) THEN
            r := v1;
            RETURN( ctmv( TAN( r ) ) );
          END_IF;
        ef_form_c                 :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND ( 'REAL' IN TYPEOF( v2 ) )
              THEN
            r := v1;
            s := v2;
            RETURN( makec( r, s ) );
          END_IF;
        ef_rpart_c                :           IF cnlit IN TYPEOF( v1 ) THEN
            RETURN( ctmv( v1\complex_number_literal.real_part ) );
          END_IF;
        ef_ipart_c                :           IF cnlit IN TYPEOF( v1 ) THEN
            RETURN( ctmv( v1\complex_number_literal.imag_part ) );
          END_IF;
        ef_negate_c               :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            RETURN( makec( -p, -q ) );
          END_IF;
        ef_reciprocal_c           :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            t := ( p * p ) + ( q * q );
            RETURN( makec( p / t, ( -q ) / t ) );
          END_IF;
        ef_add_c                  : 
          BEGIN
            p := 0;
            q := 0;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF cnlit IN TYPEOF( vlist[i] ) THEN
                parts( vlist[i], r, s );
                p := p + r;
                q := q + s;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( makec( p, q ) );
            END_IF;
            IF ( ( p * p ) + ( q * q ) ) <> 0 THEN
              INSERT( vlist, makec( p, q ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_subtract_c             :           IF ( cnlit IN TYPEOF( v1 ) ) AND ( cnlit IN TYPEOF( v2 ) )
              THEN
            parts( v1, p, q );
            parts( v2, r, s );
            RETURN( makec( p - r, q - s ) );
          END_IF;
        ef_multiply_c             : 
          BEGIN
            p := 1;
            q := 0;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF cnlit IN TYPEOF( vlist[i] ) THEN
                parts( vlist[i], r, s );
                p := ( p * r ) - ( q * s );
                q := ( p * s ) + ( q * r );
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( makec( p, q ) );
            END_IF;
            IF ( p <> 1 ) OR ( q <> 0 ) THEN
              INSERT( vlist, makec( p, q ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_divide_c               :           IF ( cnlit IN TYPEOF( v1 ) ) AND ( cnlit IN TYPEOF( v2 ) )
              THEN
            parts( v1, p, q );
            parts( v2, r, s );
            t := ( r * r ) + ( s * s );
            RETURN( makec( ( ( p * r ) + ( q * s ) ) / t, ( ( q * r ) - ( p * s ) ) / t ) );
          END_IF;
        ef_exponentiate_c         :           IF ( cnlit IN TYPEOF( v1 ) ) AND ( cnlit IN TYPEOF( v2 ) )
              THEN
            parts( v1, p, q );
            parts( v2, r, s );
            t := 0.5 * LOG( ( p * p ) + ( q * q ) );
            u := atan2( q, p );
            p := ( r * t ) - ( s * u );
            q := ( r * u ) + ( s * t );
            r := EXP( p );
            RETURN( makec( r * COS( q ), r * SIN( q ) ) );
          END_IF;
        ef_exponentiate_ci        :           IF ( cnlit IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            parts( v1, p, q );
            k := v2;
            r := 1;
            s := 0;
            REPEAT i := 1 TO ABS( k ) BY 1;
              r := ( p * r ) - ( q * s );
              s := ( p * s ) + ( q * r );
            END_REPEAT;
            IF k < 0 THEN
              t := ( r * r ) + ( s * s );
              r := r / t;
              s := ( -s ) / t;
            END_IF;
            RETURN( makec( r, s ) );
          END_IF;
        ef_eq_c                   :           IF ( cnlit IN TYPEOF( v1 ) ) AND ( cnlit IN TYPEOF( v2 ) )
              THEN
            parts( v1, p, q );
            parts( v2, r, s );
            RETURN( ctmv( ( p = r ) AND ( q = s ) ) );
          END_IF;
        ef_ne_c                   :           IF ( cnlit IN TYPEOF( v1 ) ) AND ( cnlit IN TYPEOF( v2 ) )
              THEN
            parts( v1, p, q );
            parts( v2, r, s );
            RETURN( ctmv( ( p <> r ) OR ( q <> s ) ) );
          END_IF;
        ef_conjugate_c            :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            RETURN( makec( p, -q ) );
          END_IF;
        ef_abs_c                  :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            RETURN( ctmv( SQRT( ( p * p ) + ( q * q ) ) ) );
          END_IF;
        ef_arg_c                  :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            RETURN( ctmv( atan2( q, p ) ) );
          END_IF;
        ef_cos_c                  :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            t := 0.5 * EXP( -q );
            u := 0.5 * EXP( q );
            RETURN( makec( ( t + u ) * COS( p ), ( t - u ) * SIN( p ) ) );
          END_IF;
        ef_exp_c                  :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            RETURN( makec( EXP( p ) * COS( q ), EXP( p ) * SIN( q ) ) );
          END_IF;
        ef_ln_c                   :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            RETURN( makec( 0.5 * LOG( ( p * p ) + ( q * q ) ), atan2( q, p ) ) );
          END_IF;
        ef_sin_c                  :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            t := 0.5 * EXP( -q );
            u := 0.5 * EXP( q );
            RETURN( makec( ( t + u ) * SIN( p ), ( u - t ) * COS( p ) ) );
          END_IF;
        ef_sqrt_c                 :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            t := SQRT( SQRT( ( p * p ) + ( q * q ) ) );
            u := 0.5 * atan2( q, p );
            RETURN( makec( t * COS( u ), t * SIN( u ) ) );
          END_IF;
        ef_tan_c                  :           IF cnlit IN TYPEOF( v1 ) THEN
            parts( v1, p, q );
            t := EXP( 2 * q ) + EXP( ( -2 ) * q ) + ( 2 * COS( 2 * p ) );
            RETURN( makec( ( 2 * SIN( 2 * p ) ) / t, ( EXP( ( -2 ) * q ) - EXP( 2 * q ) ) / t ) );
          END_IF;
        ef_subscript_s            :           IF ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            str := v1;
            k := v2;
            RETURN( ctmv( str[k] ) );
          END_IF;
        ef_eq_s                   :           IF ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) )
              THEN
            str := v1;
            st2 := v2;
            RETURN( ctmv( str = st2 ) );
          END_IF;
        ef_ne_s                   :           IF ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) )
              THEN
            str := v1;
            st2 := v2;
            RETURN( ctmv( str <> st2 ) );
          END_IF;
        ef_gt_s                   :           IF ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) )
              THEN
            str := v1;
            st2 := v2;
            RETURN( ctmv( str > st2 ) );
          END_IF;
        ef_lt_s                   :           IF ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) )
              THEN
            str := v1;
            st2 := v2;
            RETURN( ctmv( str < st2 ) );
          END_IF;
        ef_ge_s                   :           IF ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) )
              THEN
            str := v1;
            st2 := v2;
            RETURN( ctmv( str >= st2 ) );
          END_IF;
        ef_le_s                   :           IF ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) )
              THEN
            str := v1;
            st2 := v2;
            RETURN( ctmv( str <= st2 ) );
          END_IF;
        ef_subsequence_s          :           IF ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) ) 
              AND ( 'INTEGER' IN TYPEOF( v3 ) ) THEN
            str := v1;
            j := v2;
            k := v3;
            RETURN( ctmv( str[j : k] ) );
          END_IF;
        ef_concat_s               : 
          BEGIN
            str := '';
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'STRING' IN TYPEOF( vlist[i] ) THEN
                st2 := vlist[i];
                str := str + st2;
                REMOVE( vlist, i );
              ELSE
                IF str <> '' THEN
                  INSERT( vlist, ctmv( str ), i );
                  str := '';
                END_IF;
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( str ) );
            END_IF;
            IF str <> '' THEN
              INSERT( vlist, ctmv( str ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_size_s                 :           IF 'STRING' IN TYPEOF( v1 ) THEN
            str := v1;
            RETURN( ctmv( LENGTH( str ) ) );
          END_IF;
        ef_format                 :           IF ( 'NUMBER' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) )
              THEN
            RETURN( ctmv( FORMAT( v1, v2 ) ) );
          END_IF;
        ef_value                  :           IF 'STRING' IN TYPEOF( v1 ) THEN
            str := v1;
            RETURN( ctmv( VALUE( str ) ) );
          END_IF;
        ef_like                   :           IF ( 'STRING' IN TYPEOF( v1 ) ) AND ( 'STRING' IN TYPEOF( v2 ) )
              THEN
            v1_string := v1;
            v2_string := v2;
            RETURN( ctmv( v1_string LIKE v2_string ) );
          END_IF;
        ef_subscript_b            :           IF ( 'BINARY' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            bin := v1;
            k := v2;
            RETURN( ctmv( bin[k] ) );
          END_IF;
        ef_eq_b                   :           IF ( 'BINARY' IN TYPEOF( v1 ) ) AND ( 'BINARY' IN TYPEOF( v2 ) )
              THEN
            bin := v1;
            bi2 := v2;
            RETURN( ctmv( bin = bi2 ) );
          END_IF;
        ef_ne_b                   :           IF ( 'BINARY' IN TYPEOF( v1 ) ) AND ( 'BINARY' IN TYPEOF( v2 ) )
              THEN
            bin := v1;
            bi2 := v2;
            RETURN( ctmv( bin <> bi2 ) );
          END_IF;
        ef_gt_b                   :           IF ( 'BINARY' IN TYPEOF( v1 ) ) AND ( 'BINARY' IN TYPEOF( v2 ) )
              THEN
            bin := v1;
            bi2 := v2;
            RETURN( ctmv( bin > bi2 ) );
          END_IF;
        ef_lt_b                   :           IF ( 'BINARY' IN TYPEOF( v1 ) ) AND ( 'BINARY' IN TYPEOF( v2 ) )
              THEN
            bin := v1;
            bi2 := v2;
            RETURN( ctmv( bin < bi2 ) );
          END_IF;
        ef_ge_b                   :           IF ( 'BINARY' IN TYPEOF( v1 ) ) AND ( 'BINARY' IN TYPEOF( v2 ) )
              THEN
            bin := v1;
            bi2 := v2;
            RETURN( ctmv( bin >= bi2 ) );
          END_IF;
        ef_le_b                   :           IF ( 'BINARY' IN TYPEOF( v1 ) ) AND ( 'BINARY' IN TYPEOF( v2 ) )
              THEN
            bin := v1;
            bi2 := v2;
            RETURN( ctmv( bin <= bi2 ) );
          END_IF;
        ef_subsequence_b          :           IF ( 'BINARY' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) ) 
              AND ( 'INTEGER' IN TYPEOF( v3 ) ) THEN
            bin := v1;
            j := v2;
            k := v3;
            RETURN( ctmv( bin[j : k] ) );
          END_IF;
        ef_concat_b               : 
          BEGIN
            boo := FALSE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'BINARY' IN TYPEOF( vlist[i] ) THEN
                IF boo THEN
                  bi2 := vlist[i];
                  bin := bin + bi2;
                ELSE
                  bin := vlist[i];
                  boo := TRUE;
                END_IF;
                REMOVE( vlist, i );
              ELSE
                IF boo THEN
                  INSERT( vlist, ctmv( bin ), i );
                  boo := FALSE;
                END_IF;
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( bin ) );
            END_IF;
            IF boo THEN
              INSERT( vlist, ctmv( bin ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_size_b                 :           IF 'BINARY' IN TYPEOF( v1 ) THEN
            bin := v1;
            RETURN( ctmv( BLENGTH( bin ) ) );
          END_IF;
        ef_subscript_t            :           IF ( 'LIST' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            tpl := v1;
            k := v2;
            RETURN( ctmv( tpl[k] ) );
          END_IF;
        ef_eq_t                   :           IF ( 'LIST' IN TYPEOF( v1 ) ) AND ( 'LIST' IN TYPEOF( v2 ) )
              THEN
            lgc := equal_maths_values( v1, v2 );
            IF lgc <> UNKNOWN THEN
              RETURN( ctmv( lgc ) );
            END_IF;
          END_IF;
        ef_ne_t                   :           IF ( 'LIST' IN TYPEOF( v1 ) ) AND ( 'LIST' IN TYPEOF( v2 ) )
              THEN
            lgc := equal_maths_values( v1, v2 );
            IF lgc <> UNKNOWN THEN
              RETURN( ctmv( NOT lgc ) );
            END_IF;
          END_IF;
        ef_concat_t               : 
          BEGIN
            tpl := [];
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF 'STRING' IN TYPEOF( vlist[i] ) THEN
                tp2 := vlist[i];
                tpl := tpl + tp2;
                REMOVE( vlist, i );
              ELSE
                IF SIZEOF( tpl ) <> 0 THEN
                  INSERT( vlist, ctmv( tpl ), i );
                  tpl := [];
                END_IF;
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( tpl ) );
            END_IF;
            IF SIZEOF( tpl ) <> 0 THEN
              INSERT( vlist, ctmv( tpl ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_size_t                 :           IF 'LIST' IN TYPEOF( v1 ) THEN
            tpl := v1;
            RETURN( ctmv( SIZEOF( tpl ) ) );
          END_IF;
        ef_entuple                :           RETURN( ctmv( vlist ) );
        ef_detuple                :           IF 'LIST' IN TYPEOF( v1 ) THEN
            tpl := v1;
            RETURN( ctmv( tpl[1] ) );
          END_IF;
        ef_insert                 :           IF ( 'LIST' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v3 ) )
              THEN
            tpl := v1;
            k := v3;
            INSERT( tpl, v2, k );
            RETURN( ctmv( tpl ) );
          END_IF;
        ef_remove                 :           IF ( 'LIST' IN TYPEOF( v1 ) ) AND ( 'INTEGER' IN TYPEOF( v2 ) )
              THEN
            tpl := v1;
            k := v2;
            REMOVE( tpl, k );
            RETURN( ctmv( tpl ) );
          END_IF;
        ef_sum_it                 :           IF good_t( v1, 'INTEGER' ) THEN
            tpl := v1;
            j := 0;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              j := j + tpl[i];
            END_REPEAT;
            RETURN( ctmv( j ) );
          END_IF;
        ef_product_it             :           IF good_t( v1, 'INTEGER' ) THEN
            tpl := v1;
            j := 1;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              j := j * tpl[i];
            END_REPEAT;
            RETURN( ctmv( j ) );
          END_IF;
        ef_add_it                 : 
          BEGIN
            boo := FALSE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF good_t( vlist[i], 'INTEGER' ) THEN
                IF NOT boo THEN
                  tpl := vlist[i];
                  boo := TRUE;
                ELSE
                  tp2 := vlist[i];
                  IF SIZEOF( tpl ) <> SIZEOF( tp2 ) THEN
                    RETURN( ? );
                  END_IF;
                  REPEAT j := 1 TO SIZEOF( tpl ) BY 1;
                    tpl_integer := tpl[j];
                    tp2_integer := tp2[j];
                    tpl[j] := tpl_integer + tp2_integer;
                  END_REPEAT;
                END_IF;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( tpl ) );
            END_IF;
            IF boo THEN
              INSERT( vlist, ctmv( tpl ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_subtract_it            :           IF good_t( v1, 'INTEGER' ) AND good_t( v2, 'INTEGER' ) THEN
            tpl := v1;
            tp2 := v2;
            IF SIZEOF( tpl ) <> SIZEOF( tp2 ) THEN
              RETURN( ? );
            END_IF;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              tpl_integer := tpl[i];
              tp2_integer := tp2[i];
              tpl[i] := tpl_integer - tp2_integer;
            END_REPEAT;
            RETURN( ctmv( tpl ) );
          END_IF;
        ef_scalar_mult_it         :           IF ( 'INTEGER' IN TYPEOF( v1 ) ) AND good_t( v2, 'INTEGER' )
              THEN
            j := v1;
            tpl := v2;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              tpl[i] := j * tpl[i];
            END_REPEAT;
            RETURN( ctmv( tpl ) );
          END_IF;
        ef_dot_prod_it            :           IF good_t( v1, 'INTEGER' ) AND good_t( v2, 'INTEGER' ) THEN
            tpl := v1;
            tp2 := v2;
            j := 0;
            IF SIZEOF( tpl ) <> SIZEOF( tp2 ) THEN
              RETURN( ? );
            END_IF;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              tpl_integer := tpl[i];
              tp2_integer := tp2[i];
              j := j + ( tpl_integer * tp2_integer );
            END_REPEAT;
            RETURN( ctmv( j ) );
          END_IF;
        ef_sum_rt                 :           IF good_t( v1, 'REAL' ) THEN
            tpl := v1;
            r := 0;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              r := r + tpl[i];
            END_REPEAT;
            RETURN( ctmv( r ) );
          END_IF;
        ef_product_rt             :           IF good_t( v1, 'REAL' ) THEN
            tpl := v1;
            r := 1;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              r := r * tpl[i];
            END_REPEAT;
            RETURN( ctmv( r ) );
          END_IF;
        ef_add_rt                 : 
          BEGIN
            boo := FALSE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF good_t( vlist[i], 'REAL' ) THEN
                IF NOT boo THEN
                  tpl := vlist[i];
                  boo := TRUE;
                ELSE
                  tp2 := vlist[i];
                  IF SIZEOF( tpl ) <> SIZEOF( tp2 ) THEN
                    RETURN( ? );
                  END_IF;
                  REPEAT j := 1 TO SIZEOF( tpl ) BY 1;
                    tpl_real := tpl[j];
                    tp2_real := tp2[j];
                    tpl[j] := tpl_real + tp2_real;
                  END_REPEAT;
                END_IF;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( tpl ) );
            END_IF;
            IF boo THEN
              INSERT( vlist, ctmv( tpl ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_subtract_rt            :           IF good_t( v1, 'REAL' ) AND good_t( v2, 'REAL' ) THEN
            tpl := v1;
            tp2 := v2;
            IF SIZEOF( tpl ) <> SIZEOF( tp2 ) THEN
              RETURN( ? );
            END_IF;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              tpl_real := tpl[i];
              tp2_real := tp2[i];
              tpl[i] := tpl_real - tp2_real;
            END_REPEAT;
            RETURN( ctmv( tpl ) );
          END_IF;
        ef_scalar_mult_rt         :           IF ( 'REAL' IN TYPEOF( v1 ) ) AND good_t( v2, 'REAL' ) THEN
            r := v1;
            tpl := v2;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              tpl[i] := r * tpl[i];
            END_REPEAT;
            RETURN( ctmv( tpl ) );
          END_IF;
        ef_dot_prod_rt            :           IF good_t( v1, 'REAL' ) AND good_t( v2, 'REAL' ) THEN
            tpl := v1;
            tp2 := v2;
            r := 0;
            IF SIZEOF( tpl ) <> SIZEOF( tp2 ) THEN
              RETURN( ? );
            END_IF;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              tpl_real := tpl[i];
              tp2_real := tp2[i];
              r := r + ( tpl_real * tp2_real );
            END_REPEAT;
            RETURN( ctmv( r ) );
          END_IF;
        ef_norm_rt                :           IF good_t( v1, 'REAL' ) THEN
            tpl := v1;
            r := 0;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              tpl_real := tpl[i];
              tp2_real := tp2[i];
              r := r + ( tpl_real * tp2_real );
            END_REPEAT;
            RETURN( ctmv( SQRT( r ) ) );
          END_IF;
        ef_sum_ct                 :           IF good_t( v1, cnlit ) THEN
            tpl := v1;
            p := 0;
            q := 0;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              parts( tpl[i], r, s );
              p := p + r;
              q := q + s;
            END_REPEAT;
            RETURN( makec( p, q ) );
          END_IF;
        ef_product_ct             :           IF good_t( v1, cnlit ) THEN
            tpl := v1;
            p := 1;
            q := 0;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              parts( tpl[i], r, s );
              p := ( p * r ) - ( q * s );
              q := ( p * s ) + ( q * r );
            END_REPEAT;
            RETURN( makec( p, q ) );
          END_IF;
        ef_add_ct                 : 
          BEGIN
            boo := FALSE;
            REPEAT i := SIZEOF( vlist ) TO 1 BY -1;
              IF good_t( vlist[i], cnlit ) THEN
                IF NOT boo THEN
                  tpl := vlist[i];
                  boo := TRUE;
                ELSE
                  tp2 := vlist[i];
                  IF SIZEOF( tpl ) <> SIZEOF( tp2 ) THEN
                    RETURN( ? );
                  END_IF;
                  REPEAT j := 1 TO SIZEOF( tpl ) BY 1;
                    parts( tpl[j], p, q );
                    parts( tp2[j], r, s );
                    tpl[j] := makec( p + r, q + s );
                  END_REPEAT;
                END_IF;
                REMOVE( vlist, i );
              END_IF;
            END_REPEAT;
            IF SIZEOF( vlist ) = 0 THEN
              RETURN( ctmv( tpl ) );
            END_IF;
            IF boo THEN
              INSERT( vlist, ctmv( tpl ), 0 );
            END_IF;
            IF SIZEOF( vlist ) = 1 THEN
              RETURN( vlist[1] );
            END_IF;
          END;
        ef_subtract_ct            :           IF good_t( v1, cnlit ) AND good_t( v2, cnlit ) THEN
            tpl := v1;
            tp2 := v2;
            IF SIZEOF( tpl ) <> SIZEOF( tp2 ) THEN
              RETURN( ? );
            END_IF;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              parts( tpl[i], p, q );
              parts( tp2[i], r, s );
              tpl[i] := makec( p - r, q - s );
            END_REPEAT;
            RETURN( ctmv( tpl ) );
          END_IF;
        ef_scalar_mult_ct         :           IF ( cnlit IN TYPEOF( v1 ) ) AND good_t( v2, cnlit ) THEN
            parts( v1, p, q );
            tpl := v2;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              parts( tpl[i], r, s );
              tpl[i] := makec( ( p * r ) - ( q * s ), ( p * s ) + ( q * r ) );
            END_REPEAT;
            RETURN( ctmv( tpl ) );
          END_IF;
        ef_dot_prod_ct            :           IF good_t( v1, cnlit ) AND good_t( v2, cnlit ) THEN
            tpl := v1;
            tp2 := v2;
            t := 0;
            u := 0;
            IF SIZEOF( tpl ) <> SIZEOF( tp2 ) THEN
              RETURN( ? );
            END_IF;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              parts( tpl[i], p, q );
              parts( tp2[i], r, s );
              t := t + ( p * r ) + ( q * s );
              u := ( u + ( q * r ) ) - ( p * s );
            END_REPEAT;
            RETURN( makec( t, u ) );
          END_IF;
        ef_norm_ct                :           IF good_t( v1, cnlit ) THEN
            tpl := v1;
            r := 0;
            REPEAT i := 1 TO SIZEOF( tpl ) BY 1;
              parts( tpl[i], p, q );
              r := r + ( p * p ) + ( q * q );
            END_REPEAT;
            RETURN( ctmv( SQRT( r ) ) );
          END_IF;
        ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t :           IF 'LOGICAL' IN TYPEOF( v1 )
              THEN
            lgc := v1;
            IF lgc THEN
              RETURN( v2 );
            ELSE
              RETURN( v3 );
            END_IF;
          END_IF;
        ef_ensemble               :           RETURN( make_finite_space( mem + vlist ) );
        ef_member_of              :           IF ( schema_prefix + 'MATHS_SPACE' ) IN TYPEOF( v2 ) THEN
            lgc := member_of( v1, v2 );
            IF lgc <> UNKNOWN THEN
              RETURN( ctmv( lgc ) );
            END_IF;
          END_IF;
      END_CASE;
      RETURN( make_function_application( expr.func, vlist ) );
    END_IF;
    IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types THEN
      gexpr := substitute( expr.func\abstracted_expression_function.expr, expr.func\quantifier_expression.
          variables, vlist );
      RETURN( simplify_generic_expression( gexpr ) );
    END_IF;
    IF 'FINITE_FUNCTION' IN types THEN
      pairs := expr.func\finite_function.pairs;
      REPEAT i := 1 TO SIZEOF( pairs ) BY 1;
        IF equal_maths_values( vlist[1], pairs[i][1] ) THEN
          RETURN( simplify_maths_value( pairs[i][2] ) );
        END_IF;
      END_REPEAT;
      RETURN( make_function_application( expr.func, vlist ) );
    END_IF;
    RETURN( expr );

  END_FUNCTION; -- simplify_function_application (line:44319 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func SIMPLIFY_FUNCTION_APPLICATION(
    _ EXPR: eFUNCTION_APPLICATION? ) 
    -> sMATHS_VALUE? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( EXPR )
    if case .available(let _cached_value) = _simplify_function_application__cache.cachedValue(params: _params) {
      return _cached_value as? sMATHS_VALUE
    }

    var EXPR = EXPR; SDAI.TOUCH(var: &EXPR)

    //NESTED FUNCTION
    func CTMV<gG: SDAIGenericType>(_ X: gG? ) 
      -> sMATHS_VALUE? {

      var X = X; SDAI.TOUCH(var: &X)

      
      let _TEMP1 = CONVERT_TO_MATHS_VALUE(X)
      return _TEMP1
    } //END FUNCTION CTMV

    //NESTED FUNCTION
    func GOOD_T(V: sMATHS_VALUE? , TN: SDAI.STRING? ) 
      -> SDAI.BOOLEAN? {

      var V = V; SDAI.TOUCH(var: &V)
      var TN = TN; SDAI.TOUCH(var: &TN)

      //LOCAL
      var TPL: SDAI.LIST<sMATHS_VALUE>? 

      
      let _TEMP1 = SDAI.aggregate(SDAI.TYPEOF(V), contains: SDAI.STRING("LIST"))
      if SDAI.IS_TRUE( _TEMP1 ) {
        TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V)
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
          SDAI.SIZEOF(TPL)) {
          for I in incrementControl {
            
            let _TEMP2 = TPL?[I]
            let _TEMP3 = SDAI.TYPEOF(_TEMP2)
            let _TEMP4 = SDAI.aggregate(_TEMP3, contains: TN)
            let _TEMP5 =  !_TEMP4
            if SDAI.IS_TRUE( _TEMP5 ) {
              return SDAI.BOOLEAN(SDAI.FALSE)
            }
          }
        }
        return SDAI.BOOLEAN(SDAI.TRUE)
      }
      return SDAI.BOOLEAN(SDAI.FALSE)
    } //END FUNCTION GOOD_T

    //NESTED FUNCTION
    func MAKEC(X: SDAI.REAL? , Y: SDAI.REAL? ) 
      -> eCOMPLEX_NUMBER_LITERAL? {

      var X = X; SDAI.TOUCH(var: &X)
      var Y = Y; SDAI.TOUCH(var: &Y)

      
      let _TEMP1 = MAKE_COMPLEX_NUMBER_LITERAL(
        RPART: X, IPART: Y)
      return _TEMP1
    } //END FUNCTION MAKEC

    //NESTED PROCEDURE
    func PARTS(C: eCOMPLEX_NUMBER_LITERAL? , X: inout SDAI.REAL? , Y: inout SDAI.REAL? ) {

      var C = C; SDAI.TOUCH(var: &C)

      
      let _TEMP1 = C?.REAL_PART
      X = _TEMP1
      
      let _TEMP2 = C?.IMAG_PART
      Y = _TEMP2
    } //END PROCEDURE PARTS


    //CONSTANT
    let CNLIT: SDAI.STRING = SDAI.UNWRAP(
      SDAI.STRING(/*SDAI.INTEGER*/SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING(
      "COMPLEX_NUMBER_LITERAL"))))

    //LOCAL
    var TYPES: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(EXPR?.FUNC); SDAI.TOUCH(var: &TYPES)
    var EF_VAL: nELEMENTARY_FUNCTION_ENUMERATORS? 
    var IS_ELEMENTARY: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &IS_ELEMENTARY)
    var V: sMATHS_VALUE? 
    var V1: sMATHS_VALUE? 
    var V2: sMATHS_VALUE? 
    var V3: sMATHS_VALUE? 
    var VLIST: SDAI.LIST<sMATHS_VALUE>?  = SDAI.LIST<sMATHS_VALUE>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &VLIST)
    var GEXPR: eGENERIC_EXPRESSION? 
    var PAIRS: (SDAI.SET<SDAI.LIST<sMATHS_VALUE>/*[2:2]*/ >/*[1:nil]*/ )? 
    var BOO: SDAI.BOOLEAN? 
    var LGC: SDAI.LOGICAL
    var CUM: SDAI.LOGICAL
    var J: SDAI.INTEGER? 
    var K: SDAI.INTEGER? 
    var N: SDAI.INTEGER? 
    var P: SDAI.REAL? 
    var Q: SDAI.REAL? 
    var R: SDAI.REAL? 
    var S: SDAI.REAL? 
    var T: SDAI.REAL? 
    var U: SDAI.REAL? 
    var STR: SDAI.STRING? 
    var ST2: SDAI.STRING? 
    var BIN: SDAI.BINARY? 
    var BI2: SDAI.BINARY? 
    var TPL: SDAI.LIST<sMATHS_VALUE>? 
    var TP2: SDAI.LIST<sMATHS_VALUE>? 
    var MEM: SDAI.SET<sMATHS_VALUE>?  = SDAI.SET<sMATHS_VALUE>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &MEM)
    var V1_STRING: SDAI.STRING? 
    var V2_STRING: SDAI.STRING? 
    var TPL_INTEGER: SDAI.INTEGER? 
    var TP2_INTEGER: SDAI.INTEGER? 
    var TPL_REAL: SDAI.REAL? 
    var TP2_REAL: SDAI.REAL? 
    //END_LOCAL

    if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
      EXPR?.ARGUMENTS)) {
      for I in incrementControl {
        
        let _TEMP1 = EXPR?.ARGUMENTS
        let _TEMP2 = _TEMP1?[I]
        let _TEMP3 = SIMPLIFY_MATHS_VALUE(sMATHS_VALUE(/*sMATHS_EXPRESSION*/_TEMP2))
        V = _TEMP3
        SDAI.INSERT( L: &VLIST, E: V, P: SDAI.FORCE_OPTIONAL(I) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) )
      }
    }
    
    let _TEMP4 = SDAI.SIZEOF(VLIST)
    let _TEMP5 = _TEMP4 >= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
    if SDAI.IS_TRUE( _TEMP5 ) {
      
      let _TEMP6 = VLIST?[1]
      V1 = _TEMP6
    }
    
    let _TEMP7 = SDAI.SIZEOF(VLIST)
    let _TEMP8 = _TEMP7 >= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
    if SDAI.IS_TRUE( _TEMP8 ) {
      
      let _TEMP9 = VLIST?[2]
      V2 = _TEMP9
    }
    
    let _TEMP10 = SDAI.SIZEOF(VLIST)
    let _TEMP11 = _TEMP10 >= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(3))
    if SDAI.IS_TRUE( _TEMP11 ) {
      
      let _TEMP12 = VLIST?[3]
      V3 = _TEMP12
    }
    
    let _TEMP13 = SDAI.aggregate(TYPES, contains: SDAI.STRING("ELEMENTARY_FUNCTION_ENUMERATORS"))
    if SDAI.IS_TRUE( _TEMP13 ) {
      
      let _TEMP14 = EXPR?.FUNC
      EF_VAL = nELEMENTARY_FUNCTION_ENUMERATORS(/*sMATHS_FUNCTION_SELECT*/_TEMP14)
      IS_ELEMENTARY = SDAI.BOOLEAN(SDAI.TRUE)
    }
    
    let _TEMP15 = SDAI.aggregate(TYPES, contains: SDAI.STRING("ELEMENTARY_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP15 ) {
      
      let _TEMP16 = EXPR?.FUNC
      let _TEMP17 = _TEMP16?.GROUP_REF(eELEMENTARY_FUNCTION.self)
      let _TEMP18 = _TEMP17?.FUNC_ID
      EF_VAL = _TEMP18
      IS_ELEMENTARY = SDAI.BOOLEAN(SDAI.TRUE)
    }
    if SDAI.IS_TRUE( IS_ELEMENTARY ) {
      if let selector = EF_VAL {
        switch selector {
        case EF_AND:
          //BEGIN
          CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE))
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP19 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.LOGICAL.self)
              if SDAI.IS_TRUE( _TEMP19 ) {
                
                let _TEMP20 = VLIST?[I]
                LGC = SDAI.UNWRAP(SDAI.LOGICAL(/*sMATHS_VALUE*/_TEMP20))
                
                let _TEMP21 = CUM && LGC
                CUM = SDAI.UNWRAP(_TEMP21)
                
                let _TEMP22 = SDAI.FORCE_OPTIONAL(LGC) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
                if SDAI.IS_TRUE( _TEMP22 ) {
                  
                  let _TEMP23 = CTMV(SDAI.FALSE)
                  return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP23)
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP24 = SDAI.SIZEOF(VLIST)
          let _TEMP25 = _TEMP24 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP25 ) {
            
            let _TEMP26 = CTMV(CUM)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP26)
          }
          
          let _TEMP27 = SDAI.FORCE_OPTIONAL(CUM) .!=. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.TRUE))
          if SDAI.IS_TRUE( _TEMP27 ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(CUM), P: 0 )
          }
          
          let _TEMP28 = SDAI.SIZEOF(VLIST)
          let _TEMP29 = _TEMP28 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP29 ) {
            
            let _TEMP30 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP30)
          }
          //END

        case EF_OR:
          //BEGIN
          CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE))
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP31 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.LOGICAL.self)
              if SDAI.IS_TRUE( _TEMP31 ) {
                
                let _TEMP32 = VLIST?[I]
                LGC = SDAI.UNWRAP(SDAI.LOGICAL(/*sMATHS_VALUE*/_TEMP32))
                
                let _TEMP33 = CUM || LGC
                CUM = SDAI.UNWRAP(_TEMP33)
                
                let _TEMP34 = SDAI.FORCE_OPTIONAL(LGC) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.TRUE))
                if SDAI.IS_TRUE( _TEMP34 ) {
                  
                  let _TEMP35 = CTMV(SDAI.TRUE)
                  return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP35)
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP36 = SDAI.SIZEOF(VLIST)
          let _TEMP37 = _TEMP36 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP37 ) {
            
            let _TEMP38 = CTMV(CUM)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP38)
          }
          
          let _TEMP39 = SDAI.FORCE_OPTIONAL(CUM) .!=. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
          if SDAI.IS_TRUE( _TEMP39 ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(CUM), P: 0 )
          }
          
          let _TEMP40 = SDAI.SIZEOF(VLIST)
          let _TEMP41 = _TEMP40 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP41 ) {
            
            let _TEMP42 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP42)
          }
          //END

        case EF_NOT:
          
          let _TEMP43 = SDAI.TYPEOF(V1, IS: SDAI.LOGICAL.self)
          if SDAI.IS_TRUE( _TEMP43 ) {
            LGC = SDAI.UNWRAP(SDAI.LOGICAL(/*sMATHS_VALUE*/V1))
            
            let _TEMP44 = CTMV( !LGC)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP44)
          }

        case EF_XOR:
          //BEGIN
          
          let _TEMP45 = SDAI.TYPEOF(V1, IS: SDAI.LOGICAL.self)
          if SDAI.IS_TRUE( _TEMP45 ) {
            LGC = SDAI.UNWRAP(SDAI.LOGICAL(/*sMATHS_VALUE*/V1))
            
            let _TEMP46 = SDAI.TYPEOF(V2, IS: SDAI.LOGICAL.self)
            if SDAI.IS_TRUE( _TEMP46 ) {
              CUM = SDAI.UNWRAP(SDAI.LOGICAL(/*sMATHS_VALUE*/V2))
              
              let _TEMP47 = LGC .!=. CUM
              let _TEMP48 = CTMV(_TEMP47)
              return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP48)
            }
            else {
              
              let _TEMP49 = SDAI.FORCE_OPTIONAL(LGC) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
              if SDAI.IS_TRUE( _TEMP49 ) {
                
                let _TEMP50 = CTMV(V2)
                return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP50)
              }
              else {
                
                let _TEMP51 = SDAI.FORCE_OPTIONAL(LGC) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.UNKNOWN))
                if SDAI.IS_TRUE( _TEMP51 ) {
                  
                  let _TEMP52 = CTMV(SDAI.UNKNOWN)
                  return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP52)
                }
                else {
                  
                  let _TEMP53 = SDAI.LIST<sMATHS_VALUE>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), bound2: (nil as 
                    SDAI.INTEGER?), 
                    ([SDAI.AIE(V2)] as [SDAI.AggregationInitializerElement<sMATHS_VALUE>]))
                  let _TEMP54 = MAKE_FUNCTION_APPLICATION(
                    AFUNCTION: sMATHS_FUNCTION_SELECT(/*nELEMENTARY_FUNCTION_ENUMERATORS*/EF_NOT), 
                    ARGUMENTS: _TEMP53)
                  return _simplify_function_application__cache.updateCache(params: _params, value: 
                    sMATHS_VALUE(/*eFUNCTION_APPLICATION*/_TEMP54))
                }
              }
            }
          }
          else {
            
            let _TEMP55 = SDAI.TYPEOF(V2, IS: SDAI.LOGICAL.self)
            if SDAI.IS_TRUE( _TEMP55 ) {
              LGC = SDAI.UNWRAP(SDAI.LOGICAL(/*sMATHS_VALUE*/V2))
              
              let _TEMP56 = SDAI.FORCE_OPTIONAL(LGC) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
              if SDAI.IS_TRUE( _TEMP56 ) {
                
                let _TEMP57 = CTMV(V1)
                return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP57)
              }
              else {
                
                let _TEMP58 = SDAI.FORCE_OPTIONAL(LGC) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.UNKNOWN))
                if SDAI.IS_TRUE( _TEMP58 ) {
                  
                  let _TEMP59 = CTMV(SDAI.UNKNOWN)
                  return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP59)
                }
                else {
                  
                  let _TEMP60 = SDAI.LIST<sMATHS_VALUE>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), bound2: (nil as 
                    SDAI.INTEGER?), 
                    ([SDAI.AIE(V1)] as [SDAI.AggregationInitializerElement<sMATHS_VALUE>]))
                  let _TEMP61 = MAKE_FUNCTION_APPLICATION(
                    AFUNCTION: sMATHS_FUNCTION_SELECT(/*nELEMENTARY_FUNCTION_ENUMERATORS*/EF_NOT), 
                    ARGUMENTS: _TEMP60)
                  return _simplify_function_application__cache.updateCache(params: _params, value: 
                    sMATHS_VALUE(/*eFUNCTION_APPLICATION*/_TEMP61))
                }
              }
            }
          }
          //END

        case EF_NEGATE_I:
          
          let _TEMP62 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          if SDAI.IS_TRUE( _TEMP62 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            
            let _TEMP63 = CTMV( -J)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP63)
          }

        case EF_ADD_I:
          //BEGIN
          J = SDAI.INTEGER(0)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP64 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.INTEGER.self)
              if SDAI.IS_TRUE( _TEMP64 ) {
                
                let _TEMP65 = VLIST?[I]
                K = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP65)
                
                let _TEMP66 = J + K
                J = _TEMP66
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP67 = SDAI.SIZEOF(VLIST)
          let _TEMP68 = _TEMP67 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP68 ) {
            
            let _TEMP69 = CTMV(J)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP69)
          }
          
          let _TEMP70 = J .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP70 ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(J), P: 0 )
          }
          
          let _TEMP71 = SDAI.SIZEOF(VLIST)
          let _TEMP72 = _TEMP71 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP72 ) {
            
            let _TEMP73 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP73)
          }
          //END

        case EF_SUBTRACT_I:
          
          let _TEMP74 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP75 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP76 = _TEMP74 && _TEMP75
          if SDAI.IS_TRUE( _TEMP76 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP77 = J - K
            let _TEMP78 = CTMV(_TEMP77)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP78)
          }

        case EF_MULTIPLY_I:
          //BEGIN
          J = SDAI.INTEGER(1)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP79 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.INTEGER.self)
              if SDAI.IS_TRUE( _TEMP79 ) {
                
                let _TEMP80 = VLIST?[I]
                K = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP80)
                
                let _TEMP81 = J * K
                J = _TEMP81
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP82 = SDAI.SIZEOF(VLIST)
          let _TEMP83 = _TEMP82 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP83 ) {
            
            let _TEMP84 = CTMV(J)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP84)
          }
          
          let _TEMP85 = J .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP85 ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(J), P: 0 )
          }
          
          let _TEMP86 = SDAI.SIZEOF(VLIST)
          let _TEMP87 = _TEMP86 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP87 ) {
            
            let _TEMP88 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP88)
          }
          //END

        case EF_DIVIDE_I:
          
          let _TEMP89 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP90 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP91 = _TEMP89 && _TEMP90
          if SDAI.IS_TRUE( _TEMP91 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP92 = J ./. K
            let _TEMP93 = CTMV(_TEMP92)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP93)
          }

        case EF_MOD_I:
          
          let _TEMP94 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP95 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP96 = _TEMP94 && _TEMP95
          if SDAI.IS_TRUE( _TEMP96 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP97 = J % K
            let _TEMP98 = CTMV(_TEMP97)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP98)
          }

        case EF_EXPONENTIATE_I:
          
          let _TEMP99 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP100 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP101 = _TEMP99 && _TEMP100
          if SDAI.IS_TRUE( _TEMP101 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            N = SDAI.INTEGER(1)
            if let incrementControl/*SDAI.NUMBER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.NUMBER*/SDAI.ABS(
              K)) {
              for I in incrementControl {
                
                let _TEMP102 = N * J
                N = _TEMP102
              }
            }
            
            let _TEMP103 = K < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
            if SDAI.IS_TRUE( _TEMP103 ) {
              
              let _TEMP104 = SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) ./. N
              N = _TEMP104
            }
            
            let _TEMP105 = CTMV(N)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP105)
          }

        case EF_EQ_I:
          
          let _TEMP106 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP107 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP108 = _TEMP106 && _TEMP107
          if SDAI.IS_TRUE( _TEMP108 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP109 = J .==. K
            let _TEMP110 = CTMV(_TEMP109)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP110)
          }

        case EF_NE_I:
          
          let _TEMP111 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP112 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP113 = _TEMP111 && _TEMP112
          if SDAI.IS_TRUE( _TEMP113 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP114 = J .!=. K
            let _TEMP115 = CTMV(_TEMP114)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP115)
          }

        case EF_GT_I:
          
          let _TEMP116 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP117 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP118 = _TEMP116 && _TEMP117
          if SDAI.IS_TRUE( _TEMP118 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP119 = J > K
            let _TEMP120 = CTMV(_TEMP119)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP120)
          }

        case EF_LT_I:
          
          let _TEMP121 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP122 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP123 = _TEMP121 && _TEMP122
          if SDAI.IS_TRUE( _TEMP123 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP124 = J < K
            let _TEMP125 = CTMV(_TEMP124)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP125)
          }

        case EF_GE_I:
          
          let _TEMP126 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP127 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP128 = _TEMP126 && _TEMP127
          if SDAI.IS_TRUE( _TEMP128 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP129 = J >= K
            let _TEMP130 = CTMV(_TEMP129)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP130)
          }

        case EF_LE_I:
          
          let _TEMP131 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP132 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP133 = _TEMP131 && _TEMP132
          if SDAI.IS_TRUE( _TEMP133 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP134 = J <= K
            let _TEMP135 = CTMV(_TEMP134)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP135)
          }

        case EF_ABS_I:
          
          let _TEMP136 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          if SDAI.IS_TRUE( _TEMP136 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            
            let _TEMP137 = SDAI.ABS(J)
            let _TEMP138 = CTMV(_TEMP137)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP138)
          }

        case EF_MAX_I:
          //BEGIN
          BOO = SDAI.BOOLEAN(SDAI.FALSE)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP139 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.INTEGER.self)
              if SDAI.IS_TRUE( _TEMP139 ) {
                if SDAI.IS_TRUE( BOO ) {
                  
                  let _TEMP140 = VLIST?[I]
                  K = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP140)
                  
                  let _TEMP141 = K > J
                  if SDAI.IS_TRUE( _TEMP141 ) {
                    J = K
                  }
                }
                else {
                  
                  let _TEMP142 = VLIST?[I]
                  J = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP142)
                  BOO = SDAI.BOOLEAN(SDAI.TRUE)
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP143 = SDAI.SIZEOF(VLIST)
          let _TEMP144 = _TEMP143 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP144 ) {
            
            let _TEMP145 = CTMV(J)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP145)
          }
          if SDAI.IS_TRUE( BOO ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(J), P: 0 )
          }
          
          let _TEMP146 = SDAI.SIZEOF(VLIST)
          let _TEMP147 = _TEMP146 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP147 ) {
            
            let _TEMP148 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP148)
          }
          //END

        case EF_MIN_I:
          //BEGIN
          BOO = SDAI.BOOLEAN(SDAI.FALSE)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP149 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.INTEGER.self)
              if SDAI.IS_TRUE( _TEMP149 ) {
                if SDAI.IS_TRUE( BOO ) {
                  
                  let _TEMP150 = VLIST?[I]
                  K = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP150)
                  
                  let _TEMP151 = K < J
                  if SDAI.IS_TRUE( _TEMP151 ) {
                    J = K
                  }
                }
                else {
                  
                  let _TEMP152 = VLIST?[I]
                  J = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP152)
                  BOO = SDAI.BOOLEAN(SDAI.TRUE)
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP153 = SDAI.SIZEOF(VLIST)
          let _TEMP154 = _TEMP153 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP154 ) {
            
            let _TEMP155 = CTMV(J)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP155)
          }
          if SDAI.IS_TRUE( BOO ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(J), P: 0 )
          }
          
          let _TEMP156 = SDAI.SIZEOF(VLIST)
          let _TEMP157 = _TEMP156 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP157 ) {
            
            let _TEMP158 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP158)
          }
          //END

        case EF_NEGATE_R:
          
          let _TEMP159 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP159 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP160 = CTMV( -R)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP160)
          }

        case EF_RECIPROCAL_R:
          
          let _TEMP161 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP161 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP162 = SDAI.FORCE_OPTIONAL(SDAI.REAL(1.0000000000e+00)) / R
            let _TEMP163 = CTMV(_TEMP162)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP163)
          }

        case EF_ADD_R:
          //BEGIN
          R = SDAI.REAL(0)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP164 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.REAL.self)
              if SDAI.IS_TRUE( _TEMP164 ) {
                
                let _TEMP165 = VLIST?[I]
                S = SDAI.REAL(/*sMATHS_VALUE*/_TEMP165)
                
                let _TEMP166 = R + S
                R = _TEMP166
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP167 = SDAI.SIZEOF(VLIST)
          let _TEMP168 = _TEMP167 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP168 ) {
            
            let _TEMP169 = CTMV(R)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP169)
          }
          
          let _TEMP170 = R .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP170 ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(R), P: 0 )
          }
          
          let _TEMP171 = SDAI.SIZEOF(VLIST)
          let _TEMP172 = _TEMP171 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP172 ) {
            
            let _TEMP173 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP173)
          }
          //END

        case EF_SUBTRACT_R:
          
          let _TEMP174 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP175 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP176 = _TEMP174 && _TEMP175
          if SDAI.IS_TRUE( _TEMP176 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP177 = R - S
            let _TEMP178 = CTMV(_TEMP177)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP178)
          }

        case EF_MULTIPLY_R:
          //BEGIN
          R = SDAI.REAL(1.0000000000e+00)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP179 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.REAL.self)
              if SDAI.IS_TRUE( _TEMP179 ) {
                
                let _TEMP180 = VLIST?[I]
                S = SDAI.REAL(/*sMATHS_VALUE*/_TEMP180)
                
                let _TEMP181 = R * S
                R = _TEMP181
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP182 = SDAI.SIZEOF(VLIST)
          let _TEMP183 = _TEMP182 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP183 ) {
            
            let _TEMP184 = CTMV(R)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP184)
          }
          
          let _TEMP185 = R .!=. SDAI.FORCE_OPTIONAL(SDAI.REAL(1.0000000000e+00))
          if SDAI.IS_TRUE( _TEMP185 ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(R), P: 0 )
          }
          
          let _TEMP186 = SDAI.SIZEOF(VLIST)
          let _TEMP187 = _TEMP186 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP187 ) {
            
            let _TEMP188 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP188)
          }
          //END

        case EF_DIVIDE_R:
          
          let _TEMP189 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP190 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP191 = _TEMP189 && _TEMP190
          if SDAI.IS_TRUE( _TEMP191 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP192 = R / S
            let _TEMP193 = CTMV(_TEMP192)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP193)
          }

        case EF_MOD_R:
          
          let _TEMP194 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP195 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP196 = _TEMP194 && _TEMP195
          if SDAI.IS_TRUE( _TEMP196 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP197 = R / S
            T = _TEMP197
            
            let _TEMP198 = T ./. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
            J = _TEMP198
            
            let _TEMP199 = T < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
            let _TEMP200 = J .!=. T
            let _TEMP201 = _TEMP199 && _TEMP200
            if SDAI.IS_TRUE( _TEMP201 ) {
              
              let _TEMP202 = J - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
              J = _TEMP202
            }
            
            let _TEMP203 = J * S
            let _TEMP204 = R - _TEMP203
            let _TEMP205 = CTMV(_TEMP204)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP205)
          }

        case EF_EXPONENTIATE_R:
          
          let _TEMP206 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP207 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP208 = _TEMP206 && _TEMP207
          if SDAI.IS_TRUE( _TEMP208 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP209 = R ** S
            let _TEMP210 = CTMV(_TEMP209)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP210)
          }

        case EF_EXPONENTIATE_RI:
          
          let _TEMP211 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP212 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP213 = _TEMP211 && _TEMP212
          if SDAI.IS_TRUE( _TEMP213 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            T = SDAI.REAL(1.0000000000e+00)
            if let incrementControl/*SDAI.NUMBER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.NUMBER*/SDAI.ABS(
              K)) {
              for I in incrementControl {
                
                let _TEMP214 = T * R
                T = _TEMP214
              }
            }
            
            let _TEMP215 = K < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
            if SDAI.IS_TRUE( _TEMP215 ) {
              
              let _TEMP216 = SDAI.FORCE_OPTIONAL(SDAI.REAL(1.0000000000e+00)) / T
              T = _TEMP216
            }
            
            let _TEMP217 = CTMV(T)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP217)
          }

        case EF_EQ_R:
          
          let _TEMP218 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP219 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP220 = _TEMP218 && _TEMP219
          if SDAI.IS_TRUE( _TEMP220 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP221 = R .==. S
            let _TEMP222 = CTMV(_TEMP221)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP222)
          }

        case EF_NE_R:
          
          let _TEMP223 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP224 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP225 = _TEMP223 && _TEMP224
          if SDAI.IS_TRUE( _TEMP225 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP226 = R .!=. S
            let _TEMP227 = CTMV(_TEMP226)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP227)
          }

        case EF_GT_R:
          
          let _TEMP228 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP229 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP230 = _TEMP228 && _TEMP229
          if SDAI.IS_TRUE( _TEMP230 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP231 = R > S
            let _TEMP232 = CTMV(_TEMP231)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP232)
          }

        case EF_LT_R:
          
          let _TEMP233 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP234 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP235 = _TEMP233 && _TEMP234
          if SDAI.IS_TRUE( _TEMP235 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP236 = R < S
            let _TEMP237 = CTMV(_TEMP236)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP237)
          }

        case EF_GE_R:
          
          let _TEMP238 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP239 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP240 = _TEMP238 && _TEMP239
          if SDAI.IS_TRUE( _TEMP240 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP241 = R >= S
            let _TEMP242 = CTMV(_TEMP241)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP242)
          }

        case EF_LE_R:
          
          let _TEMP243 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP244 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP245 = _TEMP243 && _TEMP244
          if SDAI.IS_TRUE( _TEMP245 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP246 = R <= S
            let _TEMP247 = CTMV(_TEMP246)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP247)
          }

        case EF_ABS_R:
          
          let _TEMP248 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP248 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP249 = SDAI.ABS(R)
            let _TEMP250 = CTMV(_TEMP249)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP250)
          }

        case EF_MAX_R:
          //BEGIN
          BOO = SDAI.BOOLEAN(SDAI.FALSE)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP251 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.REAL.self)
              if SDAI.IS_TRUE( _TEMP251 ) {
                if SDAI.IS_TRUE( BOO ) {
                  
                  let _TEMP252 = VLIST?[I]
                  S = SDAI.REAL(/*sMATHS_VALUE*/_TEMP252)
                  
                  let _TEMP253 = S > R
                  if SDAI.IS_TRUE( _TEMP253 ) {
                    R = S
                  }
                }
                else {
                  
                  let _TEMP254 = VLIST?[I]
                  R = SDAI.REAL(/*sMATHS_VALUE*/_TEMP254)
                  BOO = SDAI.BOOLEAN(SDAI.TRUE)
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP255 = SDAI.SIZEOF(VLIST)
          let _TEMP256 = _TEMP255 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP256 ) {
            
            let _TEMP257 = CTMV(R)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP257)
          }
          if SDAI.IS_TRUE( BOO ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(R), P: 0 )
          }
          
          let _TEMP258 = SDAI.SIZEOF(VLIST)
          let _TEMP259 = _TEMP258 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP259 ) {
            
            let _TEMP260 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP260)
          }
          //END

        case EF_MIN_R:
          //BEGIN
          BOO = SDAI.BOOLEAN(SDAI.FALSE)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP261 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.REAL.self)
              if SDAI.IS_TRUE( _TEMP261 ) {
                if SDAI.IS_TRUE( BOO ) {
                  
                  let _TEMP262 = VLIST?[I]
                  S = SDAI.REAL(/*sMATHS_VALUE*/_TEMP262)
                  
                  let _TEMP263 = S < R
                  if SDAI.IS_TRUE( _TEMP263 ) {
                    R = S
                  }
                }
                else {
                  
                  let _TEMP264 = VLIST?[I]
                  R = SDAI.REAL(/*sMATHS_VALUE*/_TEMP264)
                  BOO = SDAI.BOOLEAN(SDAI.TRUE)
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP265 = SDAI.SIZEOF(VLIST)
          let _TEMP266 = _TEMP265 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP266 ) {
            
            let _TEMP267 = CTMV(R)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP267)
          }
          if SDAI.IS_TRUE( BOO ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(R), P: 0 )
          }
          
          let _TEMP268 = SDAI.SIZEOF(VLIST)
          let _TEMP269 = _TEMP268 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP269 ) {
            
            let _TEMP270 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP270)
          }
          //END

        case EF_ACOS_R:
          
          let _TEMP271 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP271 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP272 = SDAI.ACOS(R)
            let _TEMP273 = CTMV(_TEMP272)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP273)
          }

        case EF_ASIN_R:
          
          let _TEMP274 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP274 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP275 = SDAI.ASIN(R)
            let _TEMP276 = CTMV(_TEMP275)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP276)
          }

        case EF_ATAN2_R:
          
          let _TEMP277 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP278 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP279 = _TEMP277 && _TEMP278
          if SDAI.IS_TRUE( _TEMP279 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP280 = ATAN2(Y: R, 
                                 X: S)
            let _TEMP281 = CTMV(_TEMP280)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP281)
          }

        case EF_COS_R:
          
          let _TEMP282 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP282 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP283 = SDAI.COS(R)
            let _TEMP284 = CTMV(_TEMP283)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP284)
          }

        case EF_EXP_R:
          
          let _TEMP285 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP285 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP286 = SDAI.EXP(R)
            let _TEMP287 = CTMV(_TEMP286)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP287)
          }

        case EF_LN_R:
          
          let _TEMP288 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP288 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP289 = SDAI.LOG(R)
            let _TEMP290 = CTMV(_TEMP289)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP290)
          }

        case EF_LOG2_R:
          
          let _TEMP291 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP291 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP292 = SDAI.LOG2(R)
            let _TEMP293 = CTMV(_TEMP292)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP293)
          }

        case EF_LOG10_R:
          
          let _TEMP294 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP294 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP295 = SDAI.LOG10(R)
            let _TEMP296 = CTMV(_TEMP295)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP296)
          }

        case EF_SIN_R:
          
          let _TEMP297 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP297 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP298 = SDAI.SIN(R)
            let _TEMP299 = CTMV(_TEMP298)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP299)
          }

        case EF_SQRT_R:
          
          let _TEMP300 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP300 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP301 = SDAI.SQRT(R)
            let _TEMP302 = CTMV(_TEMP301)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP302)
          }

        case EF_TAN_R:
          
          let _TEMP303 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          if SDAI.IS_TRUE( _TEMP303 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            
            let _TEMP304 = SDAI.TAN(R)
            let _TEMP305 = CTMV(_TEMP304)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP305)
          }

        case EF_FORM_C:
          
          let _TEMP306 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP307 = SDAI.TYPEOF(V2, IS: SDAI.REAL.self)
          let _TEMP308 = _TEMP306 && _TEMP307
          if SDAI.IS_TRUE( _TEMP308 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            S = SDAI.REAL(/*sMATHS_VALUE*/V2)
            
            let _TEMP309 = MAKEC(X: R, 
                                 Y: S)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP309))
          }

        case EF_RPART_C:
          
          let _TEMP310 = SDAI.TYPEOF(V1)
          let _TEMP311 = SDAI.aggregate(_TEMP310, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP311 ) {
            
            let _TEMP312 = V1?.GROUP_REF(eCOMPLEX_NUMBER_LITERAL.self)
            let _TEMP313 = _TEMP312?.REAL_PART
            let _TEMP314 = CTMV(_TEMP313)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP314)
          }

        case EF_IPART_C:
          
          let _TEMP315 = SDAI.TYPEOF(V1)
          let _TEMP316 = SDAI.aggregate(_TEMP315, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP316 ) {
            
            let _TEMP317 = V1?.GROUP_REF(eCOMPLEX_NUMBER_LITERAL.self)
            let _TEMP318 = _TEMP317?.IMAG_PART
            let _TEMP319 = CTMV(_TEMP318)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP319)
          }

        case EF_NEGATE_C:
          
          let _TEMP320 = SDAI.TYPEOF(V1)
          let _TEMP321 = SDAI.aggregate(_TEMP320, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP321 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP322 = MAKEC(X:  -P, 
                                 Y:  -Q)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP322))
          }

        case EF_RECIPROCAL_C:
          
          let _TEMP323 = SDAI.TYPEOF(V1)
          let _TEMP324 = SDAI.aggregate(_TEMP323, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP324 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP325 = P * P
            let _TEMP326 = Q * Q
            let _TEMP327 = _TEMP325 + _TEMP326
            T = _TEMP327
            
            let _TEMP328 = P / T
            let _TEMP329 = (  -Q ) / T
            let _TEMP330 = MAKEC(X: _TEMP328, 
                                 Y: _TEMP329)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP330))
          }

        case EF_ADD_C:
          //BEGIN
          P = SDAI.REAL(0)
          Q = SDAI.REAL(0)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP331 = VLIST?[I]
              let _TEMP332 = SDAI.TYPEOF(_TEMP331)
              let _TEMP333 = SDAI.aggregate(_TEMP332, contains: CNLIT)
              if SDAI.IS_TRUE( _TEMP333 ) {
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/VLIST?[I]), 
                  X: &R, Y: &S )
                
                let _TEMP334 = P + R
                P = _TEMP334
                
                let _TEMP335 = Q + S
                Q = _TEMP335
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP336 = SDAI.SIZEOF(VLIST)
          let _TEMP337 = _TEMP336 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP337 ) {
            
            let _TEMP338 = MAKEC(X: P, 
                                 Y: Q)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP338))
          }
          
          let _TEMP339 = P * P
          let _TEMP340 = Q * Q
          let _TEMP341 = _TEMP339 + _TEMP340
          let _TEMP342 = _TEMP341 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP342 ) {
            SDAI.INSERT( L: &VLIST, E: MAKEC(
              X: P, Y: Q), P: 0 )
          }
          
          let _TEMP343 = SDAI.SIZEOF(VLIST)
          let _TEMP344 = _TEMP343 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP344 ) {
            
            let _TEMP345 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP345)
          }
          //END

        case EF_SUBTRACT_C:
          
          let _TEMP346 = SDAI.TYPEOF(V1)
          let _TEMP347 = SDAI.aggregate(_TEMP346, contains: CNLIT)
          let _TEMP348 = SDAI.TYPEOF(V2)
          let _TEMP349 = SDAI.aggregate(_TEMP348, contains: CNLIT)
          let _TEMP350 = _TEMP347 && _TEMP349
          if SDAI.IS_TRUE( _TEMP350 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V2), X: &R, 
              Y: &S )
            
            let _TEMP351 = P - R
            let _TEMP352 = Q - S
            let _TEMP353 = MAKEC(X: _TEMP351, 
                                 Y: _TEMP352)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP353))
          }

        case EF_MULTIPLY_C:
          //BEGIN
          P = SDAI.REAL(1.0000000000e+00)
          Q = SDAI.REAL(0)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP354 = VLIST?[I]
              let _TEMP355 = SDAI.TYPEOF(_TEMP354)
              let _TEMP356 = SDAI.aggregate(_TEMP355, contains: CNLIT)
              if SDAI.IS_TRUE( _TEMP356 ) {
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/VLIST?[I]), 
                  X: &R, Y: &S )
                
                let _TEMP357 = P * R
                let _TEMP358 = Q * S
                let _TEMP359 = _TEMP357 - _TEMP358
                P = _TEMP359
                
                let _TEMP360 = P * S
                let _TEMP361 = Q * R
                let _TEMP362 = _TEMP360 + _TEMP361
                Q = _TEMP362
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP363 = SDAI.SIZEOF(VLIST)
          let _TEMP364 = _TEMP363 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP364 ) {
            
            let _TEMP365 = MAKEC(X: P, 
                                 Y: Q)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP365))
          }
          
          let _TEMP366 = P .!=. SDAI.FORCE_OPTIONAL(SDAI.REAL(1.0000000000e+00))
          let _TEMP367 = Q .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          let _TEMP368 = _TEMP366 || _TEMP367
          if SDAI.IS_TRUE( _TEMP368 ) {
            SDAI.INSERT( L: &VLIST, E: MAKEC(
              X: P, Y: Q), P: 0 )
          }
          
          let _TEMP369 = SDAI.SIZEOF(VLIST)
          let _TEMP370 = _TEMP369 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP370 ) {
            
            let _TEMP371 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP371)
          }
          //END

        case EF_DIVIDE_C:
          
          let _TEMP372 = SDAI.TYPEOF(V1)
          let _TEMP373 = SDAI.aggregate(_TEMP372, contains: CNLIT)
          let _TEMP374 = SDAI.TYPEOF(V2)
          let _TEMP375 = SDAI.aggregate(_TEMP374, contains: CNLIT)
          let _TEMP376 = _TEMP373 && _TEMP375
          if SDAI.IS_TRUE( _TEMP376 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V2), X: &R, 
              Y: &S )
            
            let _TEMP377 = R * R
            let _TEMP378 = S * S
            let _TEMP379 = _TEMP377 + _TEMP378
            T = _TEMP379
            
            let _TEMP380 = P * R
            let _TEMP381 = Q * S
            let _TEMP382 = _TEMP380 + _TEMP381
            let _TEMP383 = _TEMP382 / T
            let _TEMP384 = Q * R
            let _TEMP385 = P * S
            let _TEMP386 = _TEMP384 - _TEMP385
            let _TEMP387 = _TEMP386 / T
            let _TEMP388 = MAKEC(X: _TEMP383, 
                                 Y: _TEMP387)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP388))
          }

        case EF_EXPONENTIATE_C:
          
          let _TEMP389 = SDAI.TYPEOF(V1)
          let _TEMP390 = SDAI.aggregate(_TEMP389, contains: CNLIT)
          let _TEMP391 = SDAI.TYPEOF(V2)
          let _TEMP392 = SDAI.aggregate(_TEMP391, contains: CNLIT)
          let _TEMP393 = _TEMP390 && _TEMP392
          if SDAI.IS_TRUE( _TEMP393 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V2), X: &R, 
              Y: &S )
            
            let _TEMP394 = P * P
            let _TEMP395 = Q * Q
            let _TEMP396 = _TEMP394 + _TEMP395
            let _TEMP397 = SDAI.LOG(_TEMP396)
            let _TEMP398 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP397
            T = _TEMP398
            
            let _TEMP399 = ATAN2(Y: Q, 
                                 X: P)
            U = _TEMP399
            
            let _TEMP400 = R * T
            let _TEMP401 = S * U
            let _TEMP402 = _TEMP400 - _TEMP401
            P = _TEMP402
            
            let _TEMP403 = R * U
            let _TEMP404 = S * T
            let _TEMP405 = _TEMP403 + _TEMP404
            Q = _TEMP405
            
            let _TEMP406 = SDAI.EXP(P)
            R = _TEMP406
            
            let _TEMP407 = SDAI.COS(Q)
            let _TEMP408 = R * _TEMP407
            let _TEMP409 = SDAI.SIN(Q)
            let _TEMP410 = R * _TEMP409
            let _TEMP411 = MAKEC(X: _TEMP408, 
                                 Y: _TEMP410)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP411))
          }

        case EF_EXPONENTIATE_CI:
          
          let _TEMP412 = SDAI.TYPEOF(V1)
          let _TEMP413 = SDAI.aggregate(_TEMP412, contains: CNLIT)
          let _TEMP414 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP415 = _TEMP413 && _TEMP414
          if SDAI.IS_TRUE( _TEMP415 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            R = SDAI.REAL(1.0000000000e+00)
            S = SDAI.REAL(0)
            if let incrementControl/*SDAI.NUMBER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.NUMBER*/SDAI.ABS(
              K)) {
              for I in incrementControl {
                
                let _TEMP416 = P * R
                let _TEMP417 = Q * S
                let _TEMP418 = _TEMP416 - _TEMP417
                R = _TEMP418
                
                let _TEMP419 = P * S
                let _TEMP420 = Q * R
                let _TEMP421 = _TEMP419 + _TEMP420
                S = _TEMP421
              }
            }
            
            let _TEMP422 = K < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
            if SDAI.IS_TRUE( _TEMP422 ) {
              
              let _TEMP423 = R * R
              let _TEMP424 = S * S
              let _TEMP425 = _TEMP423 + _TEMP424
              T = _TEMP425
              
              let _TEMP426 = R / T
              R = _TEMP426
              
              let _TEMP427 = (  -S ) / T
              S = _TEMP427
            }
            
            let _TEMP428 = MAKEC(X: R, 
                                 Y: S)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP428))
          }

        case EF_EQ_C:
          
          let _TEMP429 = SDAI.TYPEOF(V1)
          let _TEMP430 = SDAI.aggregate(_TEMP429, contains: CNLIT)
          let _TEMP431 = SDAI.TYPEOF(V2)
          let _TEMP432 = SDAI.aggregate(_TEMP431, contains: CNLIT)
          let _TEMP433 = _TEMP430 && _TEMP432
          if SDAI.IS_TRUE( _TEMP433 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V2), X: &R, 
              Y: &S )
            
            let _TEMP434 = P .==. R
            let _TEMP435 = Q .==. S
            let _TEMP436 = _TEMP434 && _TEMP435
            let _TEMP437 = CTMV(_TEMP436)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP437)
          }

        case EF_NE_C:
          
          let _TEMP438 = SDAI.TYPEOF(V1)
          let _TEMP439 = SDAI.aggregate(_TEMP438, contains: CNLIT)
          let _TEMP440 = SDAI.TYPEOF(V2)
          let _TEMP441 = SDAI.aggregate(_TEMP440, contains: CNLIT)
          let _TEMP442 = _TEMP439 && _TEMP441
          if SDAI.IS_TRUE( _TEMP442 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V2), X: &R, 
              Y: &S )
            
            let _TEMP443 = P .!=. R
            let _TEMP444 = Q .!=. S
            let _TEMP445 = _TEMP443 || _TEMP444
            let _TEMP446 = CTMV(_TEMP445)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP446)
          }

        case EF_CONJUGATE_C:
          
          let _TEMP447 = SDAI.TYPEOF(V1)
          let _TEMP448 = SDAI.aggregate(_TEMP447, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP448 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP449 = MAKEC(X: P, 
                                 Y:  -Q)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP449))
          }

        case EF_ABS_C:
          
          let _TEMP450 = SDAI.TYPEOF(V1)
          let _TEMP451 = SDAI.aggregate(_TEMP450, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP451 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP452 = P * P
            let _TEMP453 = Q * Q
            let _TEMP454 = _TEMP452 + _TEMP453
            let _TEMP455 = SDAI.SQRT(_TEMP454)
            let _TEMP456 = CTMV(_TEMP455)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP456)
          }

        case EF_ARG_C:
          
          let _TEMP457 = SDAI.TYPEOF(V1)
          let _TEMP458 = SDAI.aggregate(_TEMP457, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP458 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP459 = ATAN2(Y: Q, 
                                 X: P)
            let _TEMP460 = CTMV(_TEMP459)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP460)
          }

        case EF_COS_C:
          
          let _TEMP461 = SDAI.TYPEOF(V1)
          let _TEMP462 = SDAI.aggregate(_TEMP461, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP462 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP463 = SDAI.EXP( -Q)
            let _TEMP464 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP463
            T = _TEMP464
            
            let _TEMP465 = SDAI.EXP(Q)
            let _TEMP466 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP465
            U = _TEMP466
            
            let _TEMP467 = T + U
            let _TEMP468 = SDAI.COS(P)
            let _TEMP469 = _TEMP467 * _TEMP468
            let _TEMP470 = T - U
            let _TEMP471 = SDAI.SIN(P)
            let _TEMP472 = _TEMP470 * _TEMP471
            let _TEMP473 = MAKEC(X: _TEMP469, 
                                 Y: _TEMP472)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP473))
          }

        case EF_EXP_C:
          
          let _TEMP474 = SDAI.TYPEOF(V1)
          let _TEMP475 = SDAI.aggregate(_TEMP474, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP475 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP476 = SDAI.EXP(P)
            let _TEMP477 = SDAI.COS(Q)
            let _TEMP478 = _TEMP476 * _TEMP477
            let _TEMP479 = SDAI.EXP(P)
            let _TEMP480 = SDAI.SIN(Q)
            let _TEMP481 = _TEMP479 * _TEMP480
            let _TEMP482 = MAKEC(X: _TEMP478, 
                                 Y: _TEMP481)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP482))
          }

        case EF_LN_C:
          
          let _TEMP483 = SDAI.TYPEOF(V1)
          let _TEMP484 = SDAI.aggregate(_TEMP483, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP484 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP485 = P * P
            let _TEMP486 = Q * Q
            let _TEMP487 = _TEMP485 + _TEMP486
            let _TEMP488 = SDAI.LOG(_TEMP487)
            let _TEMP489 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP488
            let _TEMP490 = ATAN2(Y: Q, 
                                 X: P)
            let _TEMP491 = MAKEC(X: _TEMP489, 
                                 Y: _TEMP490)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP491))
          }

        case EF_SIN_C:
          
          let _TEMP492 = SDAI.TYPEOF(V1)
          let _TEMP493 = SDAI.aggregate(_TEMP492, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP493 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP494 = SDAI.EXP( -Q)
            let _TEMP495 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP494
            T = _TEMP495
            
            let _TEMP496 = SDAI.EXP(Q)
            let _TEMP497 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP496
            U = _TEMP497
            
            let _TEMP498 = T + U
            let _TEMP499 = SDAI.SIN(P)
            let _TEMP500 = _TEMP498 * _TEMP499
            let _TEMP501 = U - T
            let _TEMP502 = SDAI.COS(P)
            let _TEMP503 = _TEMP501 * _TEMP502
            let _TEMP504 = MAKEC(X: _TEMP500, 
                                 Y: _TEMP503)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP504))
          }

        case EF_SQRT_C:
          
          let _TEMP505 = SDAI.TYPEOF(V1)
          let _TEMP506 = SDAI.aggregate(_TEMP505, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP506 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP507 = P * P
            let _TEMP508 = Q * Q
            let _TEMP509 = _TEMP507 + _TEMP508
            let _TEMP510 = SDAI.SQRT(_TEMP509)
            let _TEMP511 = SDAI.SQRT(_TEMP510)
            T = _TEMP511
            
            let _TEMP512 = ATAN2(Y: Q, 
                                 X: P)
            let _TEMP513 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP512
            U = _TEMP513
            
            let _TEMP514 = SDAI.COS(U)
            let _TEMP515 = T * _TEMP514
            let _TEMP516 = SDAI.SIN(U)
            let _TEMP517 = T * _TEMP516
            let _TEMP518 = MAKEC(X: _TEMP515, 
                                 Y: _TEMP517)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP518))
          }

        case EF_TAN_C:
          
          let _TEMP519 = SDAI.TYPEOF(V1)
          let _TEMP520 = SDAI.aggregate(_TEMP519, contains: CNLIT)
          if SDAI.IS_TRUE( _TEMP520 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            
            let _TEMP521 = SDAI.FORCE_OPTIONAL(SDAI.REAL(2.0000000000e+00)) * Q
            let _TEMP522 = SDAI.EXP(_TEMP521)
            let _TEMP523 = SDAI.FORCE_OPTIONAL(SDAI.REAL( -2.0000000000e+00)) * Q
            let _TEMP524 = SDAI.EXP(_TEMP523)
            let _TEMP525 = _TEMP522 + _TEMP524
            let _TEMP526 = SDAI.FORCE_OPTIONAL(SDAI.REAL(2.0000000000e+00)) * P
            let _TEMP527 = SDAI.COS(_TEMP526)
            let _TEMP528 = SDAI.FORCE_OPTIONAL(SDAI.REAL(2.0000000000e+00)) * _TEMP527
            let _TEMP529 = _TEMP525 + _TEMP528
            T = _TEMP529
            
            let _TEMP530 = SDAI.FORCE_OPTIONAL(SDAI.REAL(2.0000000000e+00)) * P
            let _TEMP531 = SDAI.SIN(_TEMP530)
            let _TEMP532 = SDAI.FORCE_OPTIONAL(SDAI.REAL(2.0000000000e+00)) * _TEMP531
            let _TEMP533 = _TEMP532 / T
            let _TEMP534 = SDAI.FORCE_OPTIONAL(SDAI.REAL( -2.0000000000e+00)) * Q
            let _TEMP535 = SDAI.EXP(_TEMP534)
            let _TEMP536 = SDAI.FORCE_OPTIONAL(SDAI.REAL(2.0000000000e+00)) * Q
            let _TEMP537 = SDAI.EXP(_TEMP536)
            let _TEMP538 = _TEMP535 - _TEMP537
            let _TEMP539 = _TEMP538 / T
            let _TEMP540 = MAKEC(X: _TEMP533, 
                                 Y: _TEMP539)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP540))
          }

        case EF_SUBSCRIPT_S:
          
          let _TEMP541 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          let _TEMP542 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP543 = _TEMP541 && _TEMP542
          if SDAI.IS_TRUE( _TEMP543 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP544 = STR?[K]
            let _TEMP545 = CTMV(_TEMP544)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP545)
          }

        case EF_EQ_S:
          
          let _TEMP546 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          let _TEMP547 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
          let _TEMP548 = _TEMP546 && _TEMP547
          if SDAI.IS_TRUE( _TEMP548 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            ST2 = SDAI.STRING(/*sMATHS_VALUE*/V2)
            
            let _TEMP549 = STR .==. ST2
            let _TEMP550 = CTMV(_TEMP549)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP550)
          }

        case EF_NE_S:
          
          let _TEMP551 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          let _TEMP552 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
          let _TEMP553 = _TEMP551 && _TEMP552
          if SDAI.IS_TRUE( _TEMP553 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            ST2 = SDAI.STRING(/*sMATHS_VALUE*/V2)
            
            let _TEMP554 = STR .!=. ST2
            let _TEMP555 = CTMV(_TEMP554)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP555)
          }

        case EF_GT_S:
          
          let _TEMP556 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          let _TEMP557 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
          let _TEMP558 = _TEMP556 && _TEMP557
          if SDAI.IS_TRUE( _TEMP558 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            ST2 = SDAI.STRING(/*sMATHS_VALUE*/V2)
            
            let _TEMP559 = STR > ST2
            let _TEMP560 = CTMV(_TEMP559)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP560)
          }

        case EF_LT_S:
          
          let _TEMP561 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          let _TEMP562 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
          let _TEMP563 = _TEMP561 && _TEMP562
          if SDAI.IS_TRUE( _TEMP563 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            ST2 = SDAI.STRING(/*sMATHS_VALUE*/V2)
            
            let _TEMP564 = STR < ST2
            let _TEMP565 = CTMV(_TEMP564)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP565)
          }

        case EF_GE_S:
          
          let _TEMP566 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          let _TEMP567 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
          let _TEMP568 = _TEMP566 && _TEMP567
          if SDAI.IS_TRUE( _TEMP568 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            ST2 = SDAI.STRING(/*sMATHS_VALUE*/V2)
            
            let _TEMP569 = STR >= ST2
            let _TEMP570 = CTMV(_TEMP569)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP570)
          }

        case EF_LE_S:
          
          let _TEMP571 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          let _TEMP572 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
          let _TEMP573 = _TEMP571 && _TEMP572
          if SDAI.IS_TRUE( _TEMP573 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            ST2 = SDAI.STRING(/*sMATHS_VALUE*/V2)
            
            let _TEMP574 = STR <= ST2
            let _TEMP575 = CTMV(_TEMP574)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP575)
          }

        case EF_SUBSEQUENCE_S:
          
          let _TEMP576 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          let _TEMP577 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP578 = _TEMP576 && _TEMP577
          let _TEMP579 = SDAI.TYPEOF(V3, IS: SDAI.INTEGER.self)
          let _TEMP580 = _TEMP578 && _TEMP579
          if SDAI.IS_TRUE( _TEMP580 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V3)
            
            let _TEMP581 = STR?[J ... K]
            let _TEMP582 = CTMV(_TEMP581)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP582)
          }

        case EF_CONCAT_S:
          //BEGIN
          STR = SDAI.STRING("")
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP583 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.STRING.self)
              if SDAI.IS_TRUE( _TEMP583 ) {
                
                let _TEMP584 = VLIST?[I]
                ST2 = SDAI.STRING(/*sMATHS_VALUE*/_TEMP584)
                
                let _TEMP585 = STR + ST2
                STR = SDAI.STRING(/*SDAI.INTEGER*/_TEMP585)
                SDAI.REMOVE( L: &VLIST, P: I )
              }
              else {
                
                let _TEMP586 = STR .!=. SDAI.FORCE_OPTIONAL(SDAI.STRING(""))
                if SDAI.IS_TRUE( _TEMP586 ) {
                  SDAI.INSERT( L: &VLIST, E: CTMV(STR), P: I )
                  STR = SDAI.STRING("")
                }
              }
            }
          }
          
          let _TEMP587 = SDAI.SIZEOF(VLIST)
          let _TEMP588 = _TEMP587 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP588 ) {
            
            let _TEMP589 = CTMV(STR)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP589)
          }
          
          let _TEMP590 = STR .!=. SDAI.FORCE_OPTIONAL(SDAI.STRING(""))
          if SDAI.IS_TRUE( _TEMP590 ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(STR), P: 0 )
          }
          
          let _TEMP591 = SDAI.SIZEOF(VLIST)
          let _TEMP592 = _TEMP591 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP592 ) {
            
            let _TEMP593 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP593)
          }
          //END

        case EF_SIZE_S:
          
          let _TEMP594 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          if SDAI.IS_TRUE( _TEMP594 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            
            let _TEMP595 = SDAI.LENGTH(STR)
            let _TEMP596 = CTMV(_TEMP595)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP596)
          }

        case EF_FORMAT:
          
          let _TEMP597 = SDAI.TYPEOF(V1, IS: SDAI.NUMBER.self)
          let _TEMP598 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
          let _TEMP599 = _TEMP597 && _TEMP598
          if SDAI.IS_TRUE( _TEMP599 ) {
            
            let _TEMP600 = SDAI.FORMAT(
              N: V1, F: V2)
            let _TEMP601 = CTMV(_TEMP600)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP601)
          }

        case EF_VALUE:
          
          let _TEMP602 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          if SDAI.IS_TRUE( _TEMP602 ) {
            STR = SDAI.STRING(/*sMATHS_VALUE*/V1)
            
            let _TEMP603 = SDAI.VALUE(STR)
            let _TEMP604 = CTMV(_TEMP603)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP604)
          }

        case EF_LIKE:
          
          let _TEMP605 = SDAI.TYPEOF(V1, IS: SDAI.STRING.self)
          let _TEMP606 = SDAI.TYPEOF(V2, IS: SDAI.STRING.self)
          let _TEMP607 = _TEMP605 && _TEMP606
          if SDAI.IS_TRUE( _TEMP607 ) {
            V1_STRING = SDAI.STRING(/*sMATHS_VALUE*/V1)
            V2_STRING = SDAI.STRING(/*sMATHS_VALUE*/V2)
            
            let _TEMP608 = V1_STRING?.ISLIKE( PATTERN: V2_STRING )
            let _TEMP609 = CTMV(_TEMP608)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP609)
          }

        case EF_SUBSCRIPT_B:
          
          let _TEMP610 = SDAI.TYPEOF(V1, IS: SDAI.BINARY.self)
          let _TEMP611 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP612 = _TEMP610 && _TEMP611
          if SDAI.IS_TRUE( _TEMP612 ) {
            BIN = SDAI.BINARY(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP613 = BIN?[K]
            let _TEMP614 = CTMV(_TEMP613)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP614)
          }

        case EF_EQ_B:
          
          let _TEMP615 = SDAI.TYPEOF(V1, IS: SDAI.BINARY.self)
          let _TEMP616 = SDAI.TYPEOF(V2, IS: SDAI.BINARY.self)
          let _TEMP617 = _TEMP615 && _TEMP616
          if SDAI.IS_TRUE( _TEMP617 ) {
            BIN = SDAI.BINARY(/*sMATHS_VALUE*/V1)
            BI2 = SDAI.BINARY(/*sMATHS_VALUE*/V2)
            
            let _TEMP618 = BIN .==. BI2
            let _TEMP619 = CTMV(_TEMP618)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP619)
          }

        case EF_NE_B:
          
          let _TEMP620 = SDAI.TYPEOF(V1, IS: SDAI.BINARY.self)
          let _TEMP621 = SDAI.TYPEOF(V2, IS: SDAI.BINARY.self)
          let _TEMP622 = _TEMP620 && _TEMP621
          if SDAI.IS_TRUE( _TEMP622 ) {
            BIN = SDAI.BINARY(/*sMATHS_VALUE*/V1)
            BI2 = SDAI.BINARY(/*sMATHS_VALUE*/V2)
            
            let _TEMP623 = BIN .!=. BI2
            let _TEMP624 = CTMV(_TEMP623)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP624)
          }

        case EF_GT_B:
          
          let _TEMP625 = SDAI.TYPEOF(V1, IS: SDAI.BINARY.self)
          let _TEMP626 = SDAI.TYPEOF(V2, IS: SDAI.BINARY.self)
          let _TEMP627 = _TEMP625 && _TEMP626
          if SDAI.IS_TRUE( _TEMP627 ) {
            BIN = SDAI.BINARY(/*sMATHS_VALUE*/V1)
            BI2 = SDAI.BINARY(/*sMATHS_VALUE*/V2)
            
            let _TEMP628 = BIN > BI2
            let _TEMP629 = CTMV(_TEMP628)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP629)
          }

        case EF_LT_B:
          
          let _TEMP630 = SDAI.TYPEOF(V1, IS: SDAI.BINARY.self)
          let _TEMP631 = SDAI.TYPEOF(V2, IS: SDAI.BINARY.self)
          let _TEMP632 = _TEMP630 && _TEMP631
          if SDAI.IS_TRUE( _TEMP632 ) {
            BIN = SDAI.BINARY(/*sMATHS_VALUE*/V1)
            BI2 = SDAI.BINARY(/*sMATHS_VALUE*/V2)
            
            let _TEMP633 = BIN < BI2
            let _TEMP634 = CTMV(_TEMP633)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP634)
          }

        case EF_GE_B:
          
          let _TEMP635 = SDAI.TYPEOF(V1, IS: SDAI.BINARY.self)
          let _TEMP636 = SDAI.TYPEOF(V2, IS: SDAI.BINARY.self)
          let _TEMP637 = _TEMP635 && _TEMP636
          if SDAI.IS_TRUE( _TEMP637 ) {
            BIN = SDAI.BINARY(/*sMATHS_VALUE*/V1)
            BI2 = SDAI.BINARY(/*sMATHS_VALUE*/V2)
            
            let _TEMP638 = BIN >= BI2
            let _TEMP639 = CTMV(_TEMP638)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP639)
          }

        case EF_LE_B:
          
          let _TEMP640 = SDAI.TYPEOF(V1, IS: SDAI.BINARY.self)
          let _TEMP641 = SDAI.TYPEOF(V2, IS: SDAI.BINARY.self)
          let _TEMP642 = _TEMP640 && _TEMP641
          if SDAI.IS_TRUE( _TEMP642 ) {
            BIN = SDAI.BINARY(/*sMATHS_VALUE*/V1)
            BI2 = SDAI.BINARY(/*sMATHS_VALUE*/V2)
            
            let _TEMP643 = BIN <= BI2
            let _TEMP644 = CTMV(_TEMP643)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP644)
          }

        case EF_SUBSEQUENCE_B:
          
          let _TEMP645 = SDAI.TYPEOF(V1, IS: SDAI.BINARY.self)
          let _TEMP646 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP647 = _TEMP645 && _TEMP646
          let _TEMP648 = SDAI.TYPEOF(V3, IS: SDAI.INTEGER.self)
          let _TEMP649 = _TEMP647 && _TEMP648
          if SDAI.IS_TRUE( _TEMP649 ) {
            BIN = SDAI.BINARY(/*sMATHS_VALUE*/V1)
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V3)
            
            let _TEMP650 = BIN?[J ... K]
            let _TEMP651 = CTMV(_TEMP650)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP651)
          }

        case EF_CONCAT_B:
          //BEGIN
          BOO = SDAI.BOOLEAN(SDAI.FALSE)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP652 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.BINARY.self)
              if SDAI.IS_TRUE( _TEMP652 ) {
                if SDAI.IS_TRUE( BOO ) {
                  
                  let _TEMP653 = VLIST?[I]
                  BI2 = SDAI.BINARY(/*sMATHS_VALUE*/_TEMP653)
                  
                  let _TEMP654 = BIN + BI2
                  BIN = SDAI.BINARY(/*SDAI.INTEGER*/_TEMP654)
                }
                else {
                  
                  let _TEMP655 = VLIST?[I]
                  BIN = SDAI.BINARY(/*sMATHS_VALUE*/_TEMP655)
                  BOO = SDAI.BOOLEAN(SDAI.TRUE)
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
              else {
                if SDAI.IS_TRUE( BOO ) {
                  SDAI.INSERT( L: &VLIST, E: CTMV(BIN), P: I )
                  BOO = SDAI.BOOLEAN(SDAI.FALSE)
                }
              }
            }
          }
          
          let _TEMP656 = SDAI.SIZEOF(VLIST)
          let _TEMP657 = _TEMP656 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP657 ) {
            
            let _TEMP658 = CTMV(BIN)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP658)
          }
          if SDAI.IS_TRUE( BOO ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(BIN), P: 0 )
          }
          
          let _TEMP659 = SDAI.SIZEOF(VLIST)
          let _TEMP660 = _TEMP659 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP660 ) {
            
            let _TEMP661 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP661)
          }
          //END

        case EF_SIZE_B:
          
          let _TEMP662 = SDAI.TYPEOF(V1, IS: SDAI.BINARY.self)
          if SDAI.IS_TRUE( _TEMP662 ) {
            BIN = SDAI.BINARY(/*sMATHS_VALUE*/V1)
            
            let _TEMP663 = SDAI.BLENGTH(BIN)
            let _TEMP664 = CTMV(_TEMP663)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP664)
          }

        case EF_SUBSCRIPT_T:
          
          let _TEMP665 = SDAI.aggregate(SDAI.TYPEOF(V1), contains: SDAI.STRING("LIST"))
          let _TEMP666 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP667 = _TEMP665 && _TEMP666
          if SDAI.IS_TRUE( _TEMP667 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            
            let _TEMP668 = TPL?[K]
            let _TEMP669 = CTMV(_TEMP668)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP669)
          }

        case EF_EQ_T:
          
          let _TEMP670 = SDAI.aggregate(SDAI.TYPEOF(V1), contains: SDAI.STRING("LIST"))
          let _TEMP671 = SDAI.aggregate(SDAI.TYPEOF(V2), contains: SDAI.STRING("LIST"))
          let _TEMP672 = _TEMP670 && _TEMP671
          if SDAI.IS_TRUE( _TEMP672 ) {
            
            let _TEMP673 = EQUAL_MATHS_VALUES(
              VAL1: V1, VAL2: V2)
            LGC = SDAI.UNWRAP(_TEMP673)
            
            let _TEMP674 = SDAI.FORCE_OPTIONAL(LGC) .!=. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.UNKNOWN))
            if SDAI.IS_TRUE( _TEMP674 ) {
              
              let _TEMP675 = CTMV(LGC)
              return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP675)
            }
          }

        case EF_NE_T:
          
          let _TEMP676 = SDAI.aggregate(SDAI.TYPEOF(V1), contains: SDAI.STRING("LIST"))
          let _TEMP677 = SDAI.aggregate(SDAI.TYPEOF(V2), contains: SDAI.STRING("LIST"))
          let _TEMP678 = _TEMP676 && _TEMP677
          if SDAI.IS_TRUE( _TEMP678 ) {
            
            let _TEMP679 = EQUAL_MATHS_VALUES(
              VAL1: V1, VAL2: V2)
            LGC = SDAI.UNWRAP(_TEMP679)
            
            let _TEMP680 = SDAI.FORCE_OPTIONAL(LGC) .!=. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.UNKNOWN))
            if SDAI.IS_TRUE( _TEMP680 ) {
              
              let _TEMP681 = CTMV( !LGC)
              return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP681)
            }
          }

        case EF_CONCAT_T:
          //BEGIN
          
          let _TEMP682 = SDAI.LIST<sMATHS_VALUE>(SDAI.EMPLY_AGGREGATE)
          TPL = _TEMP682
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP683 = SDAI.TYPEOF(VLIST?[I], IS: SDAI.STRING.self)
              if SDAI.IS_TRUE( _TEMP683 ) {
                
                let _TEMP684 = VLIST?[I]
                TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/_TEMP684)
                
                let _TEMP685 = TPL + TP2
                TPL = _TEMP685
                SDAI.REMOVE( L: &VLIST, P: I )
              }
              else {
                
                let _TEMP686 = SDAI.SIZEOF(TPL)
                let _TEMP687 = _TEMP686 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
                if SDAI.IS_TRUE( _TEMP687 ) {
                  SDAI.INSERT( L: &VLIST, E: CTMV(TPL), P: I )
                  
                  let _TEMP688 = SDAI.LIST<sMATHS_VALUE>(SDAI.EMPLY_AGGREGATE)
                  TPL = _TEMP688
                }
              }
            }
          }
          
          let _TEMP689 = SDAI.SIZEOF(VLIST)
          let _TEMP690 = _TEMP689 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP690 ) {
            
            let _TEMP691 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP691)
          }
          
          let _TEMP692 = SDAI.SIZEOF(TPL)
          let _TEMP693 = _TEMP692 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP693 ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(TPL), P: 0 )
          }
          
          let _TEMP694 = SDAI.SIZEOF(VLIST)
          let _TEMP695 = _TEMP694 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP695 ) {
            
            let _TEMP696 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP696)
          }
          //END

        case EF_SIZE_T:
          
          let _TEMP697 = SDAI.aggregate(SDAI.TYPEOF(V1), contains: SDAI.STRING("LIST"))
          if SDAI.IS_TRUE( _TEMP697 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            
            let _TEMP698 = SDAI.SIZEOF(TPL)
            let _TEMP699 = CTMV(_TEMP698)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP699)
          }

        case EF_ENTUPLE:
          
          let _TEMP700 = CTMV(VLIST)
          return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP700)

        case EF_DETUPLE:
          
          let _TEMP701 = SDAI.aggregate(SDAI.TYPEOF(V1), contains: SDAI.STRING("LIST"))
          if SDAI.IS_TRUE( _TEMP701 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            
            let _TEMP702 = TPL?[1]
            let _TEMP703 = CTMV(_TEMP702)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP703)
          }

        case EF_INSERT:
          
          let _TEMP704 = SDAI.aggregate(SDAI.TYPEOF(V1), contains: SDAI.STRING("LIST"))
          let _TEMP705 = SDAI.TYPEOF(V3, IS: SDAI.INTEGER.self)
          let _TEMP706 = _TEMP704 && _TEMP705
          if SDAI.IS_TRUE( _TEMP706 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V3)
            SDAI.INSERT( L: &TPL, E: V2, P: K )
            
            let _TEMP707 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP707)
          }

        case EF_REMOVE:
          
          let _TEMP708 = SDAI.aggregate(SDAI.TYPEOF(V1), contains: SDAI.STRING("LIST"))
          let _TEMP709 = SDAI.TYPEOF(V2, IS: SDAI.INTEGER.self)
          let _TEMP710 = _TEMP708 && _TEMP709
          if SDAI.IS_TRUE( _TEMP710 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            K = SDAI.INTEGER(/*sMATHS_VALUE*/V2)
            SDAI.REMOVE( L: &TPL, P: K )
            
            let _TEMP711 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP711)
          }

        case EF_SUM_IT:
          
          let _TEMP712 = GOOD_T(V: V1, 
                                TN: SDAI.STRING("INTEGER"))
          if SDAI.IS_TRUE( _TEMP712 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            J = SDAI.INTEGER(0)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP713 = TPL?[I]
                let _TEMP714 = J + _TEMP713
                J = _TEMP714
              }
            }
            
            let _TEMP715 = CTMV(J)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP715)
          }

        case EF_PRODUCT_IT:
          
          let _TEMP716 = GOOD_T(V: V1, 
                                TN: SDAI.STRING("INTEGER"))
          if SDAI.IS_TRUE( _TEMP716 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            J = SDAI.INTEGER(1)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP717 = TPL?[I]
                let _TEMP718 = J * _TEMP717
                J = _TEMP718
              }
            }
            
            let _TEMP719 = CTMV(J)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP719)
          }

        case EF_ADD_IT:
          //BEGIN
          BOO = SDAI.BOOLEAN(SDAI.FALSE)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP720 = VLIST?[I]
              let _TEMP721 = GOOD_T(
                V: _TEMP720, TN: SDAI.STRING("INTEGER"))
              if SDAI.IS_TRUE( _TEMP721 ) {
                if SDAI.IS_TRUE( (  !BOO ) ) {
                  
                  let _TEMP722 = VLIST?[I]
                  TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/_TEMP722)
                  BOO = SDAI.BOOLEAN(SDAI.TRUE)
                }
                else {
                  
                  let _TEMP723 = VLIST?[I]
                  TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/_TEMP723)
                  
                  let _TEMP724 = SDAI.SIZEOF(TPL)
                  let _TEMP725 = SDAI.SIZEOF(TP2)
                  let _TEMP726 = _TEMP724 .!=. _TEMP725
                  if SDAI.IS_TRUE( _TEMP726 ) {
                    return _simplify_function_application__cache.updateCache(params: _params, value: (nil as 
                      sMATHS_VALUE?))
                  }
                  if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
                    SDAI.SIZEOF(TPL)) {
                    for J in incrementControl {
                      
                      let _TEMP727 = TPL?[J]
                      TPL_INTEGER = 
                        SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP727)
                      
                      let _TEMP728 = TP2?[J]
                      TP2_INTEGER = 
                        SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP728)
                      
                      let _TEMP729 = TPL_INTEGER + TP2_INTEGER
                      TPL?[J] = sMATHS_VALUE(/*SDAI.INTEGER*/_TEMP729)
                    }
                  }
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP730 = SDAI.SIZEOF(VLIST)
          let _TEMP731 = _TEMP730 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP731 ) {
            
            let _TEMP732 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP732)
          }
          if SDAI.IS_TRUE( BOO ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(TPL), P: 0 )
          }
          
          let _TEMP733 = SDAI.SIZEOF(VLIST)
          let _TEMP734 = _TEMP733 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP734 ) {
            
            let _TEMP735 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP735)
          }
          //END

        case EF_SUBTRACT_IT:
          
          let _TEMP736 = GOOD_T(V: V1, 
                                TN: SDAI.STRING("INTEGER"))
          let _TEMP737 = GOOD_T(V: V2, 
                                TN: SDAI.STRING("INTEGER"))
          let _TEMP738 = _TEMP736 && _TEMP737
          if SDAI.IS_TRUE( _TEMP738 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V2)
            
            let _TEMP739 = SDAI.SIZEOF(TPL)
            let _TEMP740 = SDAI.SIZEOF(TP2)
            let _TEMP741 = _TEMP739 .!=. _TEMP740
            if SDAI.IS_TRUE( _TEMP741 ) {
              return _simplify_function_application__cache.updateCache(params: _params, value: (nil as 
                sMATHS_VALUE?))
            }
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP742 = TPL?[I]
                TPL_INTEGER = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP742)
                
                let _TEMP743 = TP2?[I]
                TP2_INTEGER = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP743)
                
                let _TEMP744 = TPL_INTEGER - TP2_INTEGER
                TPL?[I] = sMATHS_VALUE(/*SDAI.INTEGER*/_TEMP744)
              }
            }
            
            let _TEMP745 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP745)
          }

        case EF_SCALAR_MULT_IT:
          
          let _TEMP746 = SDAI.TYPEOF(V1, IS: SDAI.INTEGER.self)
          let _TEMP747 = GOOD_T(V: V2, 
                                TN: SDAI.STRING("INTEGER"))
          let _TEMP748 = _TEMP746 && _TEMP747
          if SDAI.IS_TRUE( _TEMP748 ) {
            J = SDAI.INTEGER(/*sMATHS_VALUE*/V1)
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V2)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP749 = TPL?[I]
                let _TEMP750 = J * _TEMP749
                TPL?[I] = sMATHS_VALUE(/*SDAI.INTEGER*/_TEMP750)
              }
            }
            
            let _TEMP751 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP751)
          }

        case EF_DOT_PROD_IT:
          
          let _TEMP752 = GOOD_T(V: V1, 
                                TN: SDAI.STRING("INTEGER"))
          let _TEMP753 = GOOD_T(V: V2, 
                                TN: SDAI.STRING("INTEGER"))
          let _TEMP754 = _TEMP752 && _TEMP753
          if SDAI.IS_TRUE( _TEMP754 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V2)
            J = SDAI.INTEGER(0)
            
            let _TEMP755 = SDAI.SIZEOF(TPL)
            let _TEMP756 = SDAI.SIZEOF(TP2)
            let _TEMP757 = _TEMP755 .!=. _TEMP756
            if SDAI.IS_TRUE( _TEMP757 ) {
              return _simplify_function_application__cache.updateCache(params: _params, value: (nil as 
                sMATHS_VALUE?))
            }
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP758 = TPL?[I]
                TPL_INTEGER = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP758)
                
                let _TEMP759 = TP2?[I]
                TP2_INTEGER = SDAI.INTEGER(/*sMATHS_VALUE*/_TEMP759)
                
                let _TEMP760 = TPL_INTEGER * TP2_INTEGER
                let _TEMP761 = J + _TEMP760
                J = _TEMP761
              }
            }
            
            let _TEMP762 = CTMV(J)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP762)
          }

        case EF_SUM_RT:
          
          let _TEMP763 = GOOD_T(V: V1, 
                                TN: SDAI.STRING("REAL"))
          if SDAI.IS_TRUE( _TEMP763 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            R = SDAI.REAL(0)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP764 = TPL?[I]
                let _TEMP765 = R + _TEMP764
                R = _TEMP765
              }
            }
            
            let _TEMP766 = CTMV(R)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP766)
          }

        case EF_PRODUCT_RT:
          
          let _TEMP767 = GOOD_T(V: V1, 
                                TN: SDAI.STRING("REAL"))
          if SDAI.IS_TRUE( _TEMP767 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            R = SDAI.REAL(1.0000000000e+00)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP768 = TPL?[I]
                let _TEMP769 = R * _TEMP768
                R = _TEMP769
              }
            }
            
            let _TEMP770 = CTMV(R)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP770)
          }

        case EF_ADD_RT:
          //BEGIN
          BOO = SDAI.BOOLEAN(SDAI.FALSE)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP771 = VLIST?[I]
              let _TEMP772 = GOOD_T(
                V: _TEMP771, TN: SDAI.STRING("REAL"))
              if SDAI.IS_TRUE( _TEMP772 ) {
                if SDAI.IS_TRUE( (  !BOO ) ) {
                  
                  let _TEMP773 = VLIST?[I]
                  TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/_TEMP773)
                  BOO = SDAI.BOOLEAN(SDAI.TRUE)
                }
                else {
                  
                  let _TEMP774 = VLIST?[I]
                  TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/_TEMP774)
                  
                  let _TEMP775 = SDAI.SIZEOF(TPL)
                  let _TEMP776 = SDAI.SIZEOF(TP2)
                  let _TEMP777 = _TEMP775 .!=. _TEMP776
                  if SDAI.IS_TRUE( _TEMP777 ) {
                    return _simplify_function_application__cache.updateCache(params: _params, value: (nil as 
                      sMATHS_VALUE?))
                  }
                  if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
                    SDAI.SIZEOF(TPL)) {
                    for J in incrementControl {
                      
                      let _TEMP778 = TPL?[J]
                      TPL_REAL = SDAI.REAL(/*sMATHS_VALUE*/_TEMP778)
                      
                      let _TEMP779 = TP2?[J]
                      TP2_REAL = SDAI.REAL(/*sMATHS_VALUE*/_TEMP779)
                      
                      let _TEMP780 = TPL_REAL + TP2_REAL
                      TPL?[J] = sMATHS_VALUE(/*SDAI.REAL*/_TEMP780)
                    }
                  }
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP781 = SDAI.SIZEOF(VLIST)
          let _TEMP782 = _TEMP781 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP782 ) {
            
            let _TEMP783 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP783)
          }
          if SDAI.IS_TRUE( BOO ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(TPL), P: 0 )
          }
          
          let _TEMP784 = SDAI.SIZEOF(VLIST)
          let _TEMP785 = _TEMP784 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP785 ) {
            
            let _TEMP786 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP786)
          }
          //END

        case EF_SUBTRACT_RT:
          
          let _TEMP787 = GOOD_T(V: V1, 
                                TN: SDAI.STRING("REAL"))
          let _TEMP788 = GOOD_T(V: V2, 
                                TN: SDAI.STRING("REAL"))
          let _TEMP789 = _TEMP787 && _TEMP788
          if SDAI.IS_TRUE( _TEMP789 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V2)
            
            let _TEMP790 = SDAI.SIZEOF(TPL)
            let _TEMP791 = SDAI.SIZEOF(TP2)
            let _TEMP792 = _TEMP790 .!=. _TEMP791
            if SDAI.IS_TRUE( _TEMP792 ) {
              return _simplify_function_application__cache.updateCache(params: _params, value: (nil as 
                sMATHS_VALUE?))
            }
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP793 = TPL?[I]
                TPL_REAL = SDAI.REAL(/*sMATHS_VALUE*/_TEMP793)
                
                let _TEMP794 = TP2?[I]
                TP2_REAL = SDAI.REAL(/*sMATHS_VALUE*/_TEMP794)
                
                let _TEMP795 = TPL_REAL - TP2_REAL
                TPL?[I] = sMATHS_VALUE(/*SDAI.REAL*/_TEMP795)
              }
            }
            
            let _TEMP796 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP796)
          }

        case EF_SCALAR_MULT_RT:
          
          let _TEMP797 = SDAI.TYPEOF(V1, IS: SDAI.REAL.self)
          let _TEMP798 = GOOD_T(V: V2, 
                                TN: SDAI.STRING("REAL"))
          let _TEMP799 = _TEMP797 && _TEMP798
          if SDAI.IS_TRUE( _TEMP799 ) {
            R = SDAI.REAL(/*sMATHS_VALUE*/V1)
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V2)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP800 = TPL?[I]
                let _TEMP801 = R * _TEMP800
                TPL?[I] = sMATHS_VALUE(/*SDAI.REAL*/_TEMP801)
              }
            }
            
            let _TEMP802 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP802)
          }

        case EF_DOT_PROD_RT:
          
          let _TEMP803 = GOOD_T(V: V1, 
                                TN: SDAI.STRING("REAL"))
          let _TEMP804 = GOOD_T(V: V2, 
                                TN: SDAI.STRING("REAL"))
          let _TEMP805 = _TEMP803 && _TEMP804
          if SDAI.IS_TRUE( _TEMP805 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V2)
            R = SDAI.REAL(0)
            
            let _TEMP806 = SDAI.SIZEOF(TPL)
            let _TEMP807 = SDAI.SIZEOF(TP2)
            let _TEMP808 = _TEMP806 .!=. _TEMP807
            if SDAI.IS_TRUE( _TEMP808 ) {
              return _simplify_function_application__cache.updateCache(params: _params, value: (nil as 
                sMATHS_VALUE?))
            }
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP809 = TPL?[I]
                TPL_REAL = SDAI.REAL(/*sMATHS_VALUE*/_TEMP809)
                
                let _TEMP810 = TP2?[I]
                TP2_REAL = SDAI.REAL(/*sMATHS_VALUE*/_TEMP810)
                
                let _TEMP811 = TPL_REAL * TP2_REAL
                let _TEMP812 = R + _TEMP811
                R = _TEMP812
              }
            }
            
            let _TEMP813 = CTMV(R)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP813)
          }

        case EF_NORM_RT:
          
          let _TEMP814 = GOOD_T(V: V1, 
                                TN: SDAI.STRING("REAL"))
          if SDAI.IS_TRUE( _TEMP814 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            R = SDAI.REAL(0)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                
                let _TEMP815 = TPL?[I]
                TPL_REAL = SDAI.REAL(/*sMATHS_VALUE*/_TEMP815)
                
                let _TEMP816 = TP2?[I]
                TP2_REAL = SDAI.REAL(/*sMATHS_VALUE*/_TEMP816)
                
                let _TEMP817 = TPL_REAL * TP2_REAL
                let _TEMP818 = R + _TEMP817
                R = _TEMP818
              }
            }
            
            let _TEMP819 = SDAI.SQRT(R)
            let _TEMP820 = CTMV(_TEMP819)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP820)
          }

        case EF_SUM_CT:
          
          let _TEMP821 = GOOD_T(V: V1, 
                                TN: CNLIT)
          if SDAI.IS_TRUE( _TEMP821 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            P = SDAI.REAL(0)
            Q = SDAI.REAL(0)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TPL?[I]), 
                  X: &R, Y: &S )
                
                let _TEMP822 = P + R
                P = _TEMP822
                
                let _TEMP823 = Q + S
                Q = _TEMP823
              }
            }
            
            let _TEMP824 = MAKEC(X: P, 
                                 Y: Q)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP824))
          }

        case EF_PRODUCT_CT:
          
          let _TEMP825 = GOOD_T(V: V1, 
                                TN: CNLIT)
          if SDAI.IS_TRUE( _TEMP825 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            P = SDAI.REAL(1.0000000000e+00)
            Q = SDAI.REAL(0)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TPL?[I]), 
                  X: &R, Y: &S )
                
                let _TEMP826 = P * R
                let _TEMP827 = Q * S
                let _TEMP828 = _TEMP826 - _TEMP827
                P = _TEMP828
                
                let _TEMP829 = P * S
                let _TEMP830 = Q * R
                let _TEMP831 = _TEMP829 + _TEMP830
                Q = _TEMP831
              }
            }
            
            let _TEMP832 = MAKEC(X: P, 
                                 Y: Q)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP832))
          }

        case EF_ADD_CT:
          //BEGIN
          BOO = SDAI.BOOLEAN(SDAI.FALSE)
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SDAI.SIZEOF(
            VLIST), TO:/*SDAI.INTEGER*/1, BY:/*SDAI.INTEGER*/ -1) {
            for I in incrementControl {
              
              let _TEMP833 = VLIST?[I]
              let _TEMP834 = GOOD_T(
                V: _TEMP833, TN: CNLIT)
              if SDAI.IS_TRUE( _TEMP834 ) {
                if SDAI.IS_TRUE( (  !BOO ) ) {
                  
                  let _TEMP835 = VLIST?[I]
                  TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/_TEMP835)
                  BOO = SDAI.BOOLEAN(SDAI.TRUE)
                }
                else {
                  
                  let _TEMP836 = VLIST?[I]
                  TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/_TEMP836)
                  
                  let _TEMP837 = SDAI.SIZEOF(TPL)
                  let _TEMP838 = SDAI.SIZEOF(TP2)
                  let _TEMP839 = _TEMP837 .!=. _TEMP838
                  if SDAI.IS_TRUE( _TEMP839 ) {
                    return _simplify_function_application__cache.updateCache(params: _params, value: (nil as 
                      sMATHS_VALUE?))
                  }
                  if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
                    SDAI.SIZEOF(TPL)) {
                    for J in incrementControl {
                      PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TPL?[J]), 
                        X: &P, Y: &Q )
                      PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TP2?[J]), 
                        X: &R, Y: &S )
                      
                      let _TEMP840 = P + R
                      let _TEMP841 = Q + S
                      let _TEMP842 = MAKEC(
                        X: _TEMP840, 
                        Y: _TEMP841)
                      TPL?[J] = sMATHS_VALUE(/*eCOMPLEX_NUMBER_LITERAL*/_TEMP842)
                    }
                  }
                }
                SDAI.REMOVE( L: &VLIST, P: I )
              }
            }
          }
          
          let _TEMP843 = SDAI.SIZEOF(VLIST)
          let _TEMP844 = _TEMP843 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP844 ) {
            
            let _TEMP845 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP845)
          }
          if SDAI.IS_TRUE( BOO ) {
            SDAI.INSERT( L: &VLIST, E: CTMV(TPL), P: 0 )
          }
          
          let _TEMP846 = SDAI.SIZEOF(VLIST)
          let _TEMP847 = _TEMP846 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          if SDAI.IS_TRUE( _TEMP847 ) {
            
            let _TEMP848 = VLIST?[1]
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP848)
          }
          //END

        case EF_SUBTRACT_CT:
          
          let _TEMP849 = GOOD_T(V: V1, 
                                TN: CNLIT)
          let _TEMP850 = GOOD_T(V: V2, 
                                TN: CNLIT)
          let _TEMP851 = _TEMP849 && _TEMP850
          if SDAI.IS_TRUE( _TEMP851 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V2)
            
            let _TEMP852 = SDAI.SIZEOF(TPL)
            let _TEMP853 = SDAI.SIZEOF(TP2)
            let _TEMP854 = _TEMP852 .!=. _TEMP853
            if SDAI.IS_TRUE( _TEMP854 ) {
              return _simplify_function_application__cache.updateCache(params: _params, value: (nil as 
                sMATHS_VALUE?))
            }
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TPL?[I]), 
                  X: &P, Y: &Q )
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TP2?[I]), 
                  X: &R, Y: &S )
                
                let _TEMP855 = P - R
                let _TEMP856 = Q - S
                let _TEMP857 = MAKEC(
                  X: _TEMP855, Y: _TEMP856)
                TPL?[I] = sMATHS_VALUE(/*eCOMPLEX_NUMBER_LITERAL*/_TEMP857)
              }
            }
            
            let _TEMP858 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP858)
          }

        case EF_SCALAR_MULT_CT:
          
          let _TEMP859 = SDAI.TYPEOF(V1)
          let _TEMP860 = SDAI.aggregate(_TEMP859, contains: CNLIT)
          let _TEMP861 = GOOD_T(V: V2, 
                                TN: CNLIT)
          let _TEMP862 = _TEMP860 && _TEMP861
          if SDAI.IS_TRUE( _TEMP862 ) {
            PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/V1), X: &P, 
              Y: &Q )
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V2)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TPL?[I]), 
                  X: &R, Y: &S )
                
                let _TEMP863 = P * R
                let _TEMP864 = Q * S
                let _TEMP865 = _TEMP863 - _TEMP864
                let _TEMP866 = P * S
                let _TEMP867 = Q * R
                let _TEMP868 = _TEMP866 + _TEMP867
                let _TEMP869 = MAKEC(
                  X: _TEMP865, Y: _TEMP868)
                TPL?[I] = sMATHS_VALUE(/*eCOMPLEX_NUMBER_LITERAL*/_TEMP869)
              }
            }
            
            let _TEMP870 = CTMV(TPL)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP870)
          }

        case EF_DOT_PROD_CT:
          
          let _TEMP871 = GOOD_T(V: V1, 
                                TN: CNLIT)
          let _TEMP872 = GOOD_T(V: V2, 
                                TN: CNLIT)
          let _TEMP873 = _TEMP871 && _TEMP872
          if SDAI.IS_TRUE( _TEMP873 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            TP2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V2)
            T = SDAI.REAL(0)
            U = SDAI.REAL(0)
            
            let _TEMP874 = SDAI.SIZEOF(TPL)
            let _TEMP875 = SDAI.SIZEOF(TP2)
            let _TEMP876 = _TEMP874 .!=. _TEMP875
            if SDAI.IS_TRUE( _TEMP876 ) {
              return _simplify_function_application__cache.updateCache(params: _params, value: (nil as 
                sMATHS_VALUE?))
            }
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TPL?[I]), 
                  X: &P, Y: &Q )
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TP2?[I]), 
                  X: &R, Y: &S )
                
                let _TEMP877 = P * R
                let _TEMP878 = T + _TEMP877
                let _TEMP879 = Q * S
                let _TEMP880 = _TEMP878 + _TEMP879
                T = _TEMP880
                
                let _TEMP881 = Q * R
                let _TEMP882 = U + _TEMP881
                let _TEMP883 = P * S
                let _TEMP884 = _TEMP882 - _TEMP883
                U = _TEMP884
              }
            }
            
            let _TEMP885 = MAKEC(X: T, 
                                 Y: U)
            return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
              eCOMPLEX_NUMBER_LITERAL*/_TEMP885))
          }

        case EF_NORM_CT:
          
          let _TEMP886 = GOOD_T(V: V1, 
                                TN: CNLIT)
          if SDAI.IS_TRUE( _TEMP886 ) {
            TPL = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/V1)
            R = SDAI.REAL(0)
            if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
              SDAI.SIZEOF(TPL)) {
              for I in incrementControl {
                PARTS( C: eCOMPLEX_NUMBER_LITERAL(/*sMATHS_VALUE*/TPL?[I]), 
                  X: &P, Y: &Q )
                
                let _TEMP887 = P * P
                let _TEMP888 = R + _TEMP887
                let _TEMP889 = Q * Q
                let _TEMP890 = _TEMP888 + _TEMP889
                R = _TEMP890
              }
            }
            
            let _TEMP891 = SDAI.SQRT(R)
            let _TEMP892 = CTMV(_TEMP891)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP892)
          }

        case EF_IF, EF_IF_I, EF_IF_R, EF_IF_C, EF_IF_S, EF_IF_B, EF_IF_T:
          
          let _TEMP893 = SDAI.TYPEOF(V1, IS: SDAI.LOGICAL.self)
          if SDAI.IS_TRUE( _TEMP893 ) {
            LGC = SDAI.UNWRAP(SDAI.LOGICAL(/*sMATHS_VALUE*/V1))
            if SDAI.IS_TRUE( LGC ) {
              return _simplify_function_application__cache.updateCache(params: _params, value: V2)
            }
            else {
              return _simplify_function_application__cache.updateCache(params: _params, value: V3)
            }
          }

        case EF_ENSEMBLE:
          
          let _TEMP894 = MEM + VLIST
          let _TEMP895 = MAKE_FINITE_SPACE(_TEMP894)
          return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
            eFINITE_SPACE*/_TEMP895))

        case EF_MEMBER_OF:
          
          let _TEMP896 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("MATHS_SPACE"))
          let _TEMP897 = SDAI.TYPEOF(V2)
          let _TEMP898 = SDAI.aggregate(_TEMP897, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP896))
          if SDAI.IS_TRUE( _TEMP898 ) {
            
            let _TEMP899 = MEMBER_OF(
              VAL: V1, SPC: eMATHS_SPACE(/*sMATHS_VALUE*/V2))
            LGC = SDAI.UNWRAP(_TEMP899)
            
            let _TEMP900 = SDAI.FORCE_OPTIONAL(LGC) .!=. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.UNKNOWN))
            if SDAI.IS_TRUE( _TEMP900 ) {
              
              let _TEMP901 = CTMV(LGC)
              return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP901)
            }
          }

        default: break
        } //end switch
      }
      
      let _TEMP902 = EXPR?.FUNC
      let _TEMP903 = MAKE_FUNCTION_APPLICATION(
        AFUNCTION: _TEMP902, ARGUMENTS: SDAI.LIST<sMATHS_VALUE>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), 
        bound2: (nil as SDAI.INTEGER?), 
        /*SDAI.LIST<sMATHS_VALUE>*/VLIST))
      return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        eFUNCTION_APPLICATION*/_TEMP903))
    }
    
    let _TEMP904 = SDAI.aggregate(TYPES, contains: SDAI.STRING("ABSTRACTED_EXPRESSION_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP904 ) {
      
      let _TEMP905 = EXPR?.FUNC
      let _TEMP906 = _TEMP905?.GROUP_REF(eABSTRACTED_EXPRESSION_FUNCTION.self)
      let _TEMP907 = _TEMP906?.EXPR
      let _TEMP908 = EXPR?.FUNC
      let _TEMP909 = _TEMP908?.GROUP_REF(eQUANTIFIER_EXPRESSION.self)
      let _TEMP910 = _TEMP909?.VARIABLES
      let _TEMP911 = SUBSTITUTE(EXPR: _TEMP907, 
                                VARS: SDAI.LIST<eGENERIC_VARIABLE>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), 
                                bound2: (nil as SDAI.INTEGER?), 
                                /*SDAI.LIST_UNIQUE<eGENERIC_VARIABLE>[1:nil] */_TEMP910), 
                                VALS: SDAI.LIST<sMATHS_VALUE>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), bound2: (nil as 
                                SDAI.INTEGER?), 
                                /*SDAI.LIST<sMATHS_VALUE>*/VLIST))
      GEXPR = _TEMP911
      
      let _TEMP912 = SIMPLIFY_GENERIC_EXPRESSION(GEXPR)
      return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP912)
    }
    
    let _TEMP913 = SDAI.aggregate(TYPES, contains: SDAI.STRING("FINITE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP913 ) {
      
      let _TEMP914 = EXPR?.FUNC
      let _TEMP915 = _TEMP914?.GROUP_REF(eFINITE_FUNCTION.self)
      let _TEMP916 = _TEMP915?.PAIRS
      PAIRS = _TEMP916
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        PAIRS)) {
        for I in incrementControl {
          
          let _TEMP917 = VLIST?[1]
          let _TEMP918 = PAIRS?[I]
          let _TEMP919 = _TEMP918?[1]
          let _TEMP920 = EQUAL_MATHS_VALUES(
            VAL1: _TEMP917, VAL2: _TEMP919)
          if SDAI.IS_TRUE( _TEMP920 ) {
            
            let _TEMP921 = PAIRS?[I]
            let _TEMP922 = _TEMP921?[2]
            let _TEMP923 = SIMPLIFY_MATHS_VALUE(_TEMP922)
            return _simplify_function_application__cache.updateCache(params: _params, value: _TEMP923)
          }
        }
      }
      
      let _TEMP924 = EXPR?.FUNC
      let _TEMP925 = MAKE_FUNCTION_APPLICATION(
        AFUNCTION: _TEMP924, ARGUMENTS: SDAI.LIST<sMATHS_VALUE>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), 
        bound2: (nil as SDAI.INTEGER?), 
        /*SDAI.LIST<sMATHS_VALUE>*/VLIST))
      return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
        eFUNCTION_APPLICATION*/_TEMP925))
    }
    return _simplify_function_application__cache.updateCache(params: _params, value: sMATHS_VALUE(/*
      eFUNCTION_APPLICATION*/EXPR))
  }

}

//MARK: - function result cache
private var _simplify_function_application__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

