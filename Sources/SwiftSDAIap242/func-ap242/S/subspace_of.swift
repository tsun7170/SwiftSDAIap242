/* file: subspace_of.swift 	 generated: Tue Nov 16 05:35:44 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION subspace_of(
               space1, space2 : maths_space
           ) : LOGICAL;

    LOCAL
      spc1   : maths_space := simplify_maths_space( space1 );
      spc2   : maths_space := simplify_maths_space( space2 );
      types1 : SET OF STRING := stripped_typeof( spc1 );
      types2 : SET OF STRING := stripped_typeof( spc2 );
      cum    : LOGICAL;
      es_val : elementary_space_enumerators;
      bnd1   : REAL;
      bnd2   : REAL;
      n      : INTEGER;
      sp1    : maths_space;
      sp2    : maths_space;
      prgn1  : polar_complex_number_region;
      prgn2  : polar_complex_number_region;
      aitv   : finite_real_interval;
    END_LOCAL;
    IF ( NOT EXISTS( spc1 ) ) OR ( NOT EXISTS( spc2 ) ) THEN
      RETURN( FALSE );
    END_IF;
    IF spc2 = the_generics THEN
      RETURN( TRUE );
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types1 THEN
      IF NOT ( 'ELEMENTARY_SPACE' IN types2 ) THEN
        RETURN( FALSE );
      END_IF;
      es_val := spc2\elementary_space.space_id;
      IF spc1\elementary_space.space_id = es_val THEN
        RETURN( TRUE );
      END_IF;
      CASE spc1\elementary_space.space_id OF
        es_numbers                :           RETURN( FALSE );
        es_complex_numbers        :           RETURN( es_val = es_numbers );
        es_reals                  :           RETURN( es_val = es_numbers );
        es_integers               :           RETURN( es_val = es_numbers );
        es_logicals               :           RETURN( FALSE );
        es_booleans               :           RETURN( es_val = es_logicals );
        es_strings                :           RETURN( FALSE );
        es_binarys                :           RETURN( FALSE );
        es_maths_spaces           :           RETURN( FALSE );
        es_maths_functions        :           RETURN( FALSE );
        es_generics               :           RETURN( FALSE );
      END_CASE;
      RETURN( UNKNOWN );
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN types1 THEN
      cum := TRUE;
      REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max BY 1;
        cum := cum AND member_of( i, spc2 );
        IF cum = FALSE THEN
          RETURN( FALSE );
        END_IF;
      END_REPEAT;
      RETURN( cum );
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types1 THEN
      IF 'ELEMENTARY_SPACE' IN types2 THEN
        es_val := spc2\elementary_space.space_id;
        RETURN( ( es_val = es_numbers ) OR ( es_val = es_integers ) );
      END_IF;
      IF 'INTEGER_INTERVAL_FROM_MIN' IN types2 THEN
        RETURN( spc1\integer_interval_from_min.min >= spc2\integer_interval_from_min.min );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types1 THEN
      IF 'ELEMENTARY_SPACE' IN types2 THEN
        es_val := spc2\elementary_space.space_id;
        RETURN( ( es_val = es_numbers ) OR ( es_val = es_integers ) );
      END_IF;
      IF 'INTEGER_INTERVAL_TO_MAX' IN types2 THEN
        RETURN( spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF 'FINITE_REAL_INTERVAL' IN types1 THEN
      IF 'ELEMENTARY_SPACE' IN types2 THEN
        es_val := spc2\elementary_space.space_id;
        RETURN( ( es_val = es_numbers ) OR ( es_val = es_reals ) );
      END_IF;
      IF ( 'FINITE_REAL_INTERVAL' IN types2 ) OR ( 'REAL_INTERVAL_FROM_MIN' IN types2 ) OR ( 
          'REAL_INTERVAL_TO_MAX'  IN types2 ) THEN
        IF min_exists( spc2 ) THEN
          bnd1 := spc1\finite_real_interval.min;
          bnd2 := real_min( spc2 );
          IF ( bnd1 < bnd2 ) OR ( ( bnd1 = bnd2 ) AND min_included( spc1 ) AND ( NOT min_included( spc2 ) ) )
              THEN
            RETURN( FALSE );
          END_IF;
        END_IF;
        IF max_exists( spc2 ) THEN
          bnd1 := spc1\finite_real_interval.max;
          bnd2 := real_max( spc2 );
          IF ( bnd1 > bnd2 ) OR ( ( bnd1 = bnd2 ) AND max_included( spc1 ) AND ( NOT max_included( spc2 ) ) )
              THEN
            RETURN( FALSE );
          END_IF;
        END_IF;
        RETURN( TRUE );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types1 THEN
      IF 'ELEMENTARY_SPACE' IN types2 THEN
        es_val := spc2\elementary_space.space_id;
        RETURN( ( es_val = es_numbers ) OR ( es_val = es_reals ) );
      END_IF;
      IF 'REAL_INTERVAL_FROM_MIN' IN types2 THEN
        bnd1 := spc1\real_interval_from_min.min;
        bnd2 := spc2\real_interval_from_min.min;
        RETURN( ( bnd2 < bnd1 ) OR ( ( bnd2 = bnd1 ) AND ( min_included( spc2 ) OR ( NOT min_included( spc1 ) ) ) ) );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types1 THEN
      IF 'ELEMENTARY_SPACE' IN types2 THEN
        es_val := spc2\elementary_space.space_id;
        RETURN( ( es_val = es_numbers ) OR ( es_val = es_reals ) );
      END_IF;
      IF 'REAL_INTERVAL_TO_MAX' IN types2 THEN
        bnd1 := spc1\real_interval_to_max.max;
        bnd2 := spc2\real_interval_to_max.max;
        RETURN( ( bnd2 > bnd1 ) OR ( ( bnd2 = bnd1 ) AND ( max_included( spc2 ) OR ( NOT max_included( spc1 ) ) ) ) );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 THEN
      IF 'ELEMENTARY_SPACE' IN types2 THEN
        es_val := spc2\elementary_space.space_id;
        RETURN( ( es_val = es_numbers ) OR ( es_val = es_complex_numbers ) );
      END_IF;
      IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
        RETURN( subspace_of( spc1\cartesian_complex_number_region.real_constraint, spc2\
            cartesian_complex_number_region.real_constraint ) AND subspace_of( spc1\
            cartesian_complex_number_region.imag_constraint, spc2\cartesian_complex_number_region.
            imag_constraint ) );
      END_IF;
      IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
        RETURN( subspace_of( enclose_cregion_in_pregion( spc1, spc2\polar_complex_number_region.centre ), 
            spc2 ) );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1 THEN
      IF 'ELEMENTARY_SPACE' IN types2 THEN
        es_val := spc2\elementary_space.space_id;
        RETURN( ( es_val = es_numbers ) OR ( es_val = es_complex_numbers ) );
      END_IF;
      IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
        RETURN( subspace_of( enclose_pregion_in_cregion( spc1 ), spc2 ) );
      END_IF;
      IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
        prgn1 := spc1;
        prgn2 := spc2;
        IF prgn1.centre = prgn2.centre THEN
          IF prgn2.direction_constraint.max > PI THEN
            aitv := make_finite_real_interval( -PI, open, prgn2.direction_constraint.max - ( 2 * PI ), prgn2.
                direction_constraint.max_closure );
            RETURN( subspace_of( prgn1.distance_constraint, prgn2.distance_constraint ) AND ( subspace_of( 
                prgn1.direction_constraint, prgn2.direction_constraint ) OR subspace_of( prgn1.
                direction_constraint, aitv ) ) );
          ELSE
            RETURN( subspace_of( prgn1.distance_constraint, prgn2.distance_constraint ) AND subspace_of( 
                prgn1.direction_constraint, prgn2.direction_constraint ) );
          END_IF;
        END_IF;
        RETURN( subspace_of( enclose_pregion_in_pregion( prgn1, prgn2.centre ), prgn2 ) );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF 'FINITE_SPACE' IN types1 THEN
      cum := TRUE;
      REPEAT i := 1 TO SIZEOF( spc1\finite_space.members ) BY 1;
        cum := cum AND member_of( spc1\finite_space.members[i], spc2 );
        IF cum = FALSE THEN
          RETURN( FALSE );
        END_IF;
      END_REPEAT;
      RETURN( cum );
    END_IF;
    IF 'PRODUCT_SPACE' IN types1 THEN
      IF 'PRODUCT_SPACE' IN types2 THEN
        IF space_dimension( spc1 ) = space_dimension( spc2 ) THEN
          cum := TRUE;
          REPEAT i := 1 TO space_dimension( spc1 ) BY 1;
            cum := cum AND subspace_of( factor_space( spc1, i ), factor_space( spc2, i ) );
            IF cum = FALSE THEN
              RETURN( FALSE );
            END_IF;
          END_REPEAT;
          RETURN( cum );
        END_IF;
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
        IF space_dimension( spc1 ) >= space_dimension( spc2 ) THEN
          cum := TRUE;
          REPEAT i := 1 TO space_dimension( spc1 ) BY 1;
            cum := cum AND subspace_of( factor_space( spc1, i ), factor_space( spc2, i ) );
            IF cum = FALSE THEN
              RETURN( FALSE );
            END_IF;
          END_REPEAT;
          RETURN( cum );
        END_IF;
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
      IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
        n := space_dimension( spc1 );
        IF n < space_dimension( spc2 ) THEN
          n := space_dimension( spc2 );
        END_IF;
        cum := TRUE;
        REPEAT i := 1 TO n + 1 BY 1;
          cum := cum AND subspace_of( factor_space( spc1, i ), factor_space( spc2, i ) );
          IF cum = FALSE THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        RETURN( cum );
      END_IF;
      RETURN( FALSE );
    END_IF;
    IF 'FUNCTION_SPACE' IN types1 THEN
      IF 'ELEMENTARY_SPACE' IN types2 THEN
        RETURN( spc2\elementary_space.space_id = es_maths_functions );
      END_IF;
      IF 'FUNCTION_SPACE' IN types2 THEN
        cum := TRUE;
        sp1 := spc1\function_space.domain_argument;
        sp2 := spc2\function_space.domain_argument;
        CASE spc1\function_space.domain_constraint OF
          sc_equal                  : 
            BEGIN
              CASE spc2\function_space.domain_constraint OF
                sc_equal                  :                   cum := cum AND equal_maths_spaces( sp1, sp2 );
                sc_subspace               :                   cum := cum AND subspace_of( sp1, sp2 );
                sc_member                 :                   cum := cum AND member_of( sp1, sp2 );
              END_CASE;
            END;
          sc_subspace               : 
            BEGIN
              CASE spc2\function_space.domain_constraint OF
                sc_equal                  :                   RETURN( FALSE );
                sc_subspace               :                   cum := cum AND subspace_of( sp1, sp2 );
                sc_member                 : 
                  BEGIN
                    IF NOT member_of( sp1, sp2 ) THEN
                      RETURN( FALSE );
                    END_IF;
                    cum := UNKNOWN;
                  END;
              END_CASE;
            END;
          sc_member                 : 
            BEGIN
              CASE spc2\function_space.domain_constraint OF
                sc_equal                  :                   cum := cum AND space_is_singleton( sp1 ) AND 
                      equal_maths_spaces( singleton_member_of( sp1 ), sp2 );
                sc_subspace               : 
                  BEGIN
                    IF NOT member_of( sp2, sp1 ) THEN
                      RETURN( FALSE );
                    END_IF;
                    cum := UNKNOWN;
                  END;
                sc_member                 :                   cum := cum AND subspace_of( sp1, sp2 );
              END_CASE;
            END;
        END_CASE;
        IF cum = FALSE THEN
          RETURN( FALSE );
        END_IF;
        sp1 := spc1\function_space.range_argument;
        sp2 := spc2\function_space.range_argument;
        CASE spc1\function_space.range_constraint OF
          sc_equal                  : 
            BEGIN
              CASE spc2\function_space.range_constraint OF
                sc_equal                  :                   cum := cum AND equal_maths_spaces( sp1, sp2 );
                sc_subspace               :                   cum := cum AND subspace_of( sp1, sp2 );
                sc_member                 :                   cum := cum AND member_of( sp1, sp2 );
              END_CASE;
            END;
          sc_subspace               : 
            BEGIN
              CASE spc2\function_space.domain_constraint OF
                sc_equal                  :                   RETURN( FALSE );
                sc_subspace               :                   cum := cum AND subspace_of( sp1, sp2 );
                sc_member                 : 
                  BEGIN
                    IF NOT member_of( sp1, sp2 ) THEN
                      RETURN( FALSE );
                    END_IF;
                    cum := UNKNOWN;
                  END;
              END_CASE;
            END;
          sc_member                 : 
            BEGIN
              CASE spc2\function_space.domain_constraint OF
                sc_equal                  :                   cum := cum AND space_is_singleton( sp1 ) AND 
                      equal_maths_spaces( singleton_member_of( sp1 ), sp2 );
                sc_subspace               : 
                  BEGIN
                    IF NOT member_of( sp2, sp1 ) THEN
                      RETURN( FALSE );
                    END_IF;
                    cum := UNKNOWN;
                  END;
                sc_member                 :                   cum := cum AND subspace_of( sp1, sp2 );
              END_CASE;
            END;
        END_CASE;
        RETURN( cum );
      END_IF;
      RETURN( FALSE );
    END_IF;
    RETURN( UNKNOWN );

  END_FUNCTION; -- subspace_of (line:46536 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func SUBSPACE_OF(SPACE1: eMATHS_SPACE? , SPACE2: eMATHS_SPACE? ) 
    -> SDAI.LOGICAL {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( SPACE1, SPACE2 )
    if case .available(let _cached_value) = _subspace_of__cache.cachedValue(params: _params) {
      return _cached_value as! SDAI.LOGICAL
    }

    var SPACE1 = SPACE1; SDAI.TOUCH(var: &SPACE1)
    var SPACE2 = SPACE2; SDAI.TOUCH(var: &SPACE2)

    //LOCAL
    var SPC1: eMATHS_SPACE?  = SIMPLIFY_MATHS_SPACE(SPACE1); SDAI.TOUCH(var: &SPC1)
    var SPC2: eMATHS_SPACE?  = SIMPLIFY_MATHS_SPACE(SPACE2); SDAI.TOUCH(var: &SPC2)
    var TYPES1: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(SPC1); SDAI.TOUCH(var: &TYPES1)
    var TYPES2: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(SPC2); SDAI.TOUCH(var: &TYPES2)
    var CUM: SDAI.LOGICAL
    var ES_VAL: nELEMENTARY_SPACE_ENUMERATORS? 
    var BND1: SDAI.REAL? 
    var BND2: SDAI.REAL? 
    var N: SDAI.INTEGER? 
    var SP1: eMATHS_SPACE? 
    var SP2: eMATHS_SPACE? 
    var PRGN1: ePOLAR_COMPLEX_NUMBER_REGION? 
    var PRGN2: ePOLAR_COMPLEX_NUMBER_REGION? 
    var AITV: eFINITE_REAL_INTERVAL? 
    //END_LOCAL

    
    let _TEMP1 = SDAI.EXISTS(SPC1)
    let _TEMP2 =  !_TEMP1
    let _TEMP3 = SDAI.EXISTS(SPC2)
    let _TEMP4 =  !_TEMP3
    let _TEMP5 = _TEMP2 || _TEMP4
    if SDAI.IS_TRUE( _TEMP5 ) {
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP6 = SPC2 .==. SDAI.FORCE_OPTIONAL(THE_GENERICS)
    if SDAI.IS_TRUE( _TEMP6 ) {
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE)))
    }
    
    let _TEMP7 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("ELEMENTARY_SPACE"))
    if SDAI.IS_TRUE( _TEMP7 ) {
      
      let _TEMP8 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      let _TEMP9 =  !_TEMP8
      if SDAI.IS_TRUE( _TEMP9 ) {
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
      }
      
      let _TEMP10 = SPC2?.GROUP_REF(eELEMENTARY_SPACE.self)
      let _TEMP11 = _TEMP10?.SPACE_ID
      ES_VAL = _TEMP11
      
      let _TEMP12 = SPC1?.GROUP_REF(eELEMENTARY_SPACE.self)
      let _TEMP13 = _TEMP12?.SPACE_ID
      let _TEMP14 = _TEMP13 .==. ES_VAL
      if SDAI.IS_TRUE( _TEMP14 ) {
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE)))
      }
      
      let _TEMP15 = SPC1?.GROUP_REF(eELEMENTARY_SPACE.self)
      let _TEMP16 = _TEMP15?.SPACE_ID
      if let selector = _TEMP16 {
        switch selector {
        case ES_NUMBERS:
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))

        case ES_COMPLEX_NUMBERS:
          
          let _TEMP17 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP17))

        case ES_REALS:
          
          let _TEMP18 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP18))

        case ES_INTEGERS:
          
          let _TEMP19 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP19))

        case ES_LOGICALS:
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))

        case ES_BOOLEANS:
          
          let _TEMP20 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_LOGICALS)
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP20))

        case ES_STRINGS:
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))

        case ES_BINARYS:
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))

        case ES_MATHS_SPACES:
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))

        case ES_MATHS_FUNCTIONS:
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))

        case ES_GENERICS:
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))

        default: break
        } //end switch
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN)))
    }
    
    let _TEMP21 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("FINITE_INTEGER_INTERVAL"))
    if SDAI.IS_TRUE( _TEMP21 ) {
      CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE))
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SPC1?.GROUP_REF(
        eFINITE_INTEGER_INTERVAL.self)?.MIN, TO:/*SDAI.INTEGER*/SPC1?.GROUP_REF(eFINITE_INTEGER_INTERVAL.self)?
        .MAX) {
        for I in incrementControl {
          
          let _TEMP22 = MEMBER_OF(VAL: I, 
                                  SPC: SPC2)
          let _TEMP23 = CUM && _TEMP22
          CUM = SDAI.UNWRAP(_TEMP23)
          
          let _TEMP24 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
          if SDAI.IS_TRUE( _TEMP24 ) {
            return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
              SDAI.FALSE)))
          }
        }
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
    }
    
    let _TEMP25 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("INTEGER_INTERVAL_FROM_MIN"))
    if SDAI.IS_TRUE( _TEMP25 ) {
      
      let _TEMP26 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      if SDAI.IS_TRUE( _TEMP26 ) {
        
        let _TEMP27 = SPC2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP28 = _TEMP27?.SPACE_ID
        ES_VAL = _TEMP28
        
        let _TEMP29 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
        let _TEMP30 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_INTEGERS)
        let _TEMP31 = _TEMP29 || _TEMP30
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP31))
      }
      
      let _TEMP32 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("INTEGER_INTERVAL_FROM_MIN"))
      if SDAI.IS_TRUE( _TEMP32 ) {
        
        let _TEMP33 = SPC1?.GROUP_REF(eINTEGER_INTERVAL_FROM_MIN.self)
        let _TEMP34 = _TEMP33?.MIN
        let _TEMP35 = SPC2?.GROUP_REF(eINTEGER_INTERVAL_FROM_MIN.self)
        let _TEMP36 = _TEMP35?.MIN
        let _TEMP37 = _TEMP34 >= _TEMP36
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP37))
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP38 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("INTEGER_INTERVAL_TO_MAX"))
    if SDAI.IS_TRUE( _TEMP38 ) {
      
      let _TEMP39 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      if SDAI.IS_TRUE( _TEMP39 ) {
        
        let _TEMP40 = SPC2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP41 = _TEMP40?.SPACE_ID
        ES_VAL = _TEMP41
        
        let _TEMP42 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
        let _TEMP43 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_INTEGERS)
        let _TEMP44 = _TEMP42 || _TEMP43
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP44))
      }
      
      let _TEMP45 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("INTEGER_INTERVAL_TO_MAX"))
      if SDAI.IS_TRUE( _TEMP45 ) {
        
        let _TEMP46 = SPC1?.GROUP_REF(eINTEGER_INTERVAL_TO_MAX.self)
        let _TEMP47 = _TEMP46?.MAX
        let _TEMP48 = SPC2?.GROUP_REF(eINTEGER_INTERVAL_TO_MAX.self)
        let _TEMP49 = _TEMP48?.MAX
        let _TEMP50 = _TEMP47 <= _TEMP49
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP50))
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP51 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("FINITE_REAL_INTERVAL"))
    if SDAI.IS_TRUE( _TEMP51 ) {
      
      let _TEMP52 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      if SDAI.IS_TRUE( _TEMP52 ) {
        
        let _TEMP53 = SPC2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP54 = _TEMP53?.SPACE_ID
        ES_VAL = _TEMP54
        
        let _TEMP55 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
        let _TEMP56 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_REALS)
        let _TEMP57 = _TEMP55 || _TEMP56
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP57))
      }
      
      let _TEMP58 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("FINITE_REAL_INTERVAL"))
      let _TEMP59 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("REAL_INTERVAL_FROM_MIN"))
      let _TEMP60 = _TEMP58 || _TEMP59
      let _TEMP61 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("REAL_INTERVAL_TO_MAX"))
      let _TEMP62 = _TEMP60 || _TEMP61
      if SDAI.IS_TRUE( _TEMP62 ) {
        
        let _TEMP63 = MIN_EXISTS(SPC2)
        if SDAI.IS_TRUE( _TEMP63 ) {
          
          let _TEMP64 = SPC1?.GROUP_REF(eFINITE_REAL_INTERVAL.self)
          let _TEMP65 = _TEMP64?.MIN
          BND1 = _TEMP65
          
          let _TEMP66 = REAL_MIN(SPC2)
          BND2 = _TEMP66
          
          let _TEMP67 = BND1 < BND2
          let _TEMP68 = BND1 .==. BND2
          let _TEMP69 = MIN_INCLUDED(SPC1)
          let _TEMP70 = _TEMP68 && _TEMP69
          let _TEMP71 = MIN_INCLUDED(SPC2)
          let _TEMP72 =  !_TEMP71
          let _TEMP73 = _TEMP70 && _TEMP72
          let _TEMP74 = _TEMP67 || _TEMP73
          if SDAI.IS_TRUE( _TEMP74 ) {
            return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
              SDAI.FALSE)))
          }
        }
        
        let _TEMP75 = MAX_EXISTS(SPC2)
        if SDAI.IS_TRUE( _TEMP75 ) {
          
          let _TEMP76 = SPC1?.GROUP_REF(eFINITE_REAL_INTERVAL.self)
          let _TEMP77 = _TEMP76?.MAX
          BND1 = _TEMP77
          
          let _TEMP78 = REAL_MAX(SPC2)
          BND2 = _TEMP78
          
          let _TEMP79 = BND1 > BND2
          let _TEMP80 = BND1 .==. BND2
          let _TEMP81 = MAX_INCLUDED(SPC1)
          let _TEMP82 = _TEMP80 && _TEMP81
          let _TEMP83 = MAX_INCLUDED(SPC2)
          let _TEMP84 =  !_TEMP83
          let _TEMP85 = _TEMP82 && _TEMP84
          let _TEMP86 = _TEMP79 || _TEMP85
          if SDAI.IS_TRUE( _TEMP86 ) {
            return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
              SDAI.FALSE)))
          }
        }
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE)))
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP87 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("REAL_INTERVAL_FROM_MIN"))
    if SDAI.IS_TRUE( _TEMP87 ) {
      
      let _TEMP88 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      if SDAI.IS_TRUE( _TEMP88 ) {
        
        let _TEMP89 = SPC2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP90 = _TEMP89?.SPACE_ID
        ES_VAL = _TEMP90
        
        let _TEMP91 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
        let _TEMP92 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_REALS)
        let _TEMP93 = _TEMP91 || _TEMP92
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP93))
      }
      
      let _TEMP94 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("REAL_INTERVAL_FROM_MIN"))
      if SDAI.IS_TRUE( _TEMP94 ) {
        
        let _TEMP95 = SPC1?.GROUP_REF(eREAL_INTERVAL_FROM_MIN.self)
        let _TEMP96 = _TEMP95?.MIN
        BND1 = _TEMP96
        
        let _TEMP97 = SPC2?.GROUP_REF(eREAL_INTERVAL_FROM_MIN.self)
        let _TEMP98 = _TEMP97?.MIN
        BND2 = _TEMP98
        
        let _TEMP99 = BND2 < BND1
        let _TEMP100 = BND2 .==. BND1
        let _TEMP101 = MIN_INCLUDED(SPC2)
        let _TEMP102 = MIN_INCLUDED(SPC1)
        let _TEMP103 =  !_TEMP102
        let _TEMP104 = _TEMP101 || _TEMP103
        let _TEMP105 = _TEMP100 && _TEMP104
        let _TEMP106 = _TEMP99 || _TEMP105
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP106))
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP107 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("REAL_INTERVAL_TO_MAX"))
    if SDAI.IS_TRUE( _TEMP107 ) {
      
      let _TEMP108 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      if SDAI.IS_TRUE( _TEMP108 ) {
        
        let _TEMP109 = SPC2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP110 = _TEMP109?.SPACE_ID
        ES_VAL = _TEMP110
        
        let _TEMP111 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
        let _TEMP112 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_REALS)
        let _TEMP113 = _TEMP111 || _TEMP112
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP113))
      }
      
      let _TEMP114 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("REAL_INTERVAL_TO_MAX"))
      if SDAI.IS_TRUE( _TEMP114 ) {
        
        let _TEMP115 = SPC1?.GROUP_REF(eREAL_INTERVAL_TO_MAX.self)
        let _TEMP116 = _TEMP115?.MAX
        BND1 = _TEMP116
        
        let _TEMP117 = SPC2?.GROUP_REF(eREAL_INTERVAL_TO_MAX.self)
        let _TEMP118 = _TEMP117?.MAX
        BND2 = _TEMP118
        
        let _TEMP119 = BND2 > BND1
        let _TEMP120 = BND2 .==. BND1
        let _TEMP121 = MAX_INCLUDED(SPC2)
        let _TEMP122 = MAX_INCLUDED(SPC1)
        let _TEMP123 =  !_TEMP122
        let _TEMP124 = _TEMP121 || _TEMP123
        let _TEMP125 = _TEMP120 && _TEMP124
        let _TEMP126 = _TEMP119 || _TEMP125
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP126))
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP127 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("CARTESIAN_COMPLEX_NUMBER_REGION"))
    if SDAI.IS_TRUE( _TEMP127 ) {
      
      let _TEMP128 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      if SDAI.IS_TRUE( _TEMP128 ) {
        
        let _TEMP129 = SPC2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP130 = _TEMP129?.SPACE_ID
        ES_VAL = _TEMP130
        
        let _TEMP131 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
        let _TEMP132 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_COMPLEX_NUMBERS)
        let _TEMP133 = _TEMP131 || _TEMP132
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP133))
      }
      
      let _TEMP134 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("CARTESIAN_COMPLEX_NUMBER_REGION"))
      if SDAI.IS_TRUE( _TEMP134 ) {
        
        let _TEMP135 = SPC1?.GROUP_REF(eCARTESIAN_COMPLEX_NUMBER_REGION.self)
        let _TEMP136 = _TEMP135?.REAL_CONSTRAINT
        let _TEMP137 = SPC2?.GROUP_REF(eCARTESIAN_COMPLEX_NUMBER_REGION.self)
        let _TEMP138 = _TEMP137?.REAL_CONSTRAINT
        let _TEMP139 = SUBSPACE_OF(SPACE1: eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP136), 
                                   SPACE2: eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP138))
        let _TEMP140 = SPC1?.GROUP_REF(eCARTESIAN_COMPLEX_NUMBER_REGION.self)
        let _TEMP141 = _TEMP140?.IMAG_CONSTRAINT
        let _TEMP142 = SPC2?.GROUP_REF(eCARTESIAN_COMPLEX_NUMBER_REGION.self)
        let _TEMP143 = _TEMP142?.IMAG_CONSTRAINT
        let _TEMP144 = SUBSPACE_OF(SPACE1: eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP141), 
                                   SPACE2: eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP143))
        let _TEMP145 = _TEMP139 && _TEMP144
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP145))
      }
      
      let _TEMP146 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("POLAR_COMPLEX_NUMBER_REGION"))
      if SDAI.IS_TRUE( _TEMP146 ) {
        
        let _TEMP147 = SPC2?.GROUP_REF(ePOLAR_COMPLEX_NUMBER_REGION.self)
        let _TEMP148 = _TEMP147?.CENTRE
        let _TEMP149 = ENCLOSE_CREGION_IN_PREGION(
          CRGN: eCARTESIAN_COMPLEX_NUMBER_REGION(/*eMATHS_SPACE*/SPC1), 
          CENTRE: _TEMP148)
        let _TEMP150 = SUBSPACE_OF(SPACE1: eMATHS_SPACE(/*ePOLAR_COMPLEX_NUMBER_REGION*/_TEMP149), 
                                   SPACE2: SPC2)
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP150))
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP151 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("POLAR_COMPLEX_NUMBER_REGION"))
    if SDAI.IS_TRUE( _TEMP151 ) {
      
      let _TEMP152 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      if SDAI.IS_TRUE( _TEMP152 ) {
        
        let _TEMP153 = SPC2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP154 = _TEMP153?.SPACE_ID
        ES_VAL = _TEMP154
        
        let _TEMP155 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_NUMBERS)
        let _TEMP156 = ES_VAL .==. SDAI.FORCE_OPTIONAL(ES_COMPLEX_NUMBERS)
        let _TEMP157 = _TEMP155 || _TEMP156
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP157))
      }
      
      let _TEMP158 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("CARTESIAN_COMPLEX_NUMBER_REGION"))
      if SDAI.IS_TRUE( _TEMP158 ) {
        
        let _TEMP159 = ENCLOSE_PREGION_IN_CREGION(ePOLAR_COMPLEX_NUMBER_REGION(/*eMATHS_SPACE*/SPC1))
        let _TEMP160 = SUBSPACE_OF(SPACE1: eMATHS_SPACE(/*eCARTESIAN_COMPLEX_NUMBER_REGION*/_TEMP159), 
                                   SPACE2: SPC2)
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP160))
      }
      
      let _TEMP161 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("POLAR_COMPLEX_NUMBER_REGION"))
      if SDAI.IS_TRUE( _TEMP161 ) {
        PRGN1 = ePOLAR_COMPLEX_NUMBER_REGION(/*eMATHS_SPACE*/SPC1)
        PRGN2 = ePOLAR_COMPLEX_NUMBER_REGION(/*eMATHS_SPACE*/SPC2)
        
        let _TEMP162 = PRGN1?.CENTRE
        let _TEMP163 = PRGN2?.CENTRE
        let _TEMP164 = _TEMP162 .==. _TEMP163
        if SDAI.IS_TRUE( _TEMP164 ) {
          
          let _TEMP165 = PRGN2?.DIRECTION_CONSTRAINT
          let _TEMP166 = _TEMP165?.MAX
          let _TEMP167 = _TEMP166 > SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
          if SDAI.IS_TRUE( _TEMP167 ) {
            
            let _TEMP168 = PRGN2?.DIRECTION_CONSTRAINT
            let _TEMP169 = _TEMP168?.MAX
            let _TEMP170 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
            let _TEMP171 = _TEMP169 - SDAI.FORCE_OPTIONAL(_TEMP170)
            let _TEMP172 = PRGN2?.DIRECTION_CONSTRAINT
            let _TEMP173 = _TEMP172?.MAX_CLOSURE
            let _TEMP174 = MAKE_FINITE_REAL_INTERVAL(
              MIN: SDAI.REAL( -SDAI.PI), 
              MINCLO: OPEN, MAX: _TEMP171, 
              MAXCLO: _TEMP173)
            AITV = _TEMP174
            
            let _TEMP175 = PRGN1?.DISTANCE_CONSTRAINT
            let _TEMP176 = PRGN2?.DISTANCE_CONSTRAINT
            let _TEMP177 = SUBSPACE_OF(
              SPACE1: eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP175), 
              SPACE2: eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP176))
            let _TEMP178 = PRGN1?.DIRECTION_CONSTRAINT
            let _TEMP179 = PRGN2?.DIRECTION_CONSTRAINT
            let _TEMP180 = SUBSPACE_OF(
              SPACE1: eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/_TEMP178), 
              SPACE2: eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/_TEMP179))
            let _TEMP181 = PRGN1?.DIRECTION_CONSTRAINT
            let _TEMP182 = SUBSPACE_OF(
              SPACE1: eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/_TEMP181), 
              SPACE2: eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITV))
            let _TEMP183 = _TEMP180 || _TEMP182
            let _TEMP184 = _TEMP177 && _TEMP183
            return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP184))
          }
          else {
            
            let _TEMP185 = PRGN1?.DISTANCE_CONSTRAINT
            let _TEMP186 = PRGN2?.DISTANCE_CONSTRAINT
            let _TEMP187 = SUBSPACE_OF(
              SPACE1: eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP185), 
              SPACE2: eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP186))
            let _TEMP188 = PRGN1?.DIRECTION_CONSTRAINT
            let _TEMP189 = PRGN2?.DIRECTION_CONSTRAINT
            let _TEMP190 = SUBSPACE_OF(
              SPACE1: eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/_TEMP188), 
              SPACE2: eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/_TEMP189))
            let _TEMP191 = _TEMP187 && _TEMP190
            return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP191))
          }
        }
        
        let _TEMP192 = PRGN2?.CENTRE
        let _TEMP193 = ENCLOSE_PREGION_IN_PREGION(
          PRGN: PRGN1, CENTRE: _TEMP192)
        let _TEMP194 = SUBSPACE_OF(SPACE1: eMATHS_SPACE(/*ePOLAR_COMPLEX_NUMBER_REGION*/_TEMP193), 
                                   SPACE2: eMATHS_SPACE(/*ePOLAR_COMPLEX_NUMBER_REGION*/PRGN2))
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP194))
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP195 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("FINITE_SPACE"))
    if SDAI.IS_TRUE( _TEMP195 ) {
      CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE))
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        SPC1?.GROUP_REF(eFINITE_SPACE.self)?.MEMBERS)) {
        for I in incrementControl {
          
          let _TEMP196 = SPC1?.GROUP_REF(eFINITE_SPACE.self)
          let _TEMP197 = _TEMP196?.MEMBERS
          let _TEMP198 = _TEMP197?[I]
          let _TEMP199 = MEMBER_OF(VAL: _TEMP198, 
                                   SPC: SPC2)
          let _TEMP200 = CUM && _TEMP199
          CUM = SDAI.UNWRAP(_TEMP200)
          
          let _TEMP201 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
          if SDAI.IS_TRUE( _TEMP201 ) {
            return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
              SDAI.FALSE)))
          }
        }
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
    }
    
    let _TEMP202 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("PRODUCT_SPACE"))
    if SDAI.IS_TRUE( _TEMP202 ) {
      
      let _TEMP203 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("PRODUCT_SPACE"))
      if SDAI.IS_TRUE( _TEMP203 ) {
        
        let _TEMP204 = SPACE_DIMENSION(sTUPLE_SPACE(/*eMATHS_SPACE*/SPC1))
        let _TEMP205 = SPACE_DIMENSION(sTUPLE_SPACE(/*eMATHS_SPACE*/SPC2))
        let _TEMP206 = _TEMP204 .==. _TEMP205
        if SDAI.IS_TRUE( _TEMP206 ) {
          CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE))
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*tNONNEGATIVE_INTEGER*/
            SPACE_DIMENSION(sTUPLE_SPACE(/*eMATHS_SPACE*/SPC1))) {
            for I in incrementControl {
              
              let _TEMP207 = FACTOR_SPACE(
                TSPACE: sTUPLE_SPACE(/*eMATHS_SPACE*/SPC1), 
                IDX: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/I))
              let _TEMP208 = FACTOR_SPACE(
                TSPACE: sTUPLE_SPACE(/*eMATHS_SPACE*/SPC2), 
                IDX: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/I))
              let _TEMP209 = SUBSPACE_OF(
                SPACE1: _TEMP207, SPACE2: _TEMP208)
              let _TEMP210 = CUM && _TEMP209
              CUM = SDAI.UNWRAP(_TEMP210)
              
              let _TEMP211 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
              if SDAI.IS_TRUE( _TEMP211 ) {
                return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                  SDAI.FALSE)))
              }
            }
          }
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
        }
      }
      
      let _TEMP212 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("EXTENDED_TUPLE_SPACE"))
      if SDAI.IS_TRUE( _TEMP212 ) {
        
        let _TEMP213 = SPACE_DIMENSION(sTUPLE_SPACE(/*eMATHS_SPACE*/SPC1))
        let _TEMP214 = SPACE_DIMENSION(sTUPLE_SPACE(/*eMATHS_SPACE*/SPC2))
        let _TEMP215 = _TEMP213 >= _TEMP214
        if SDAI.IS_TRUE( _TEMP215 ) {
          CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE))
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*tNONNEGATIVE_INTEGER*/
            SPACE_DIMENSION(sTUPLE_SPACE(/*eMATHS_SPACE*/SPC1))) {
            for I in incrementControl {
              
              let _TEMP216 = FACTOR_SPACE(
                TSPACE: sTUPLE_SPACE(/*eMATHS_SPACE*/SPC1), 
                IDX: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/I))
              let _TEMP217 = FACTOR_SPACE(
                TSPACE: sTUPLE_SPACE(/*eMATHS_SPACE*/SPC2), 
                IDX: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/I))
              let _TEMP218 = SUBSPACE_OF(
                SPACE1: _TEMP216, SPACE2: _TEMP217)
              let _TEMP219 = CUM && _TEMP218
              CUM = SDAI.UNWRAP(_TEMP219)
              
              let _TEMP220 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
              if SDAI.IS_TRUE( _TEMP220 ) {
                return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                  SDAI.FALSE)))
              }
            }
          }
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
        }
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP221 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("EXTENDED_TUPLE_SPACE"))
    if SDAI.IS_TRUE( _TEMP221 ) {
      
      let _TEMP222 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("EXTENDED_TUPLE_SPACE"))
      if SDAI.IS_TRUE( _TEMP222 ) {
        
        let _TEMP223 = SPACE_DIMENSION(sTUPLE_SPACE(/*eMATHS_SPACE*/SPC1))
        N = SDAI.INTEGER(/*tNONNEGATIVE_INTEGER*/_TEMP223)
        
        let _TEMP224 = SPACE_DIMENSION(sTUPLE_SPACE(/*eMATHS_SPACE*/SPC2))
        let _TEMP225 = N < _TEMP224
        if SDAI.IS_TRUE( _TEMP225 ) {
          
          let _TEMP226 = SPACE_DIMENSION(sTUPLE_SPACE(/*eMATHS_SPACE*/SPC2))
          N = SDAI.INTEGER(/*tNONNEGATIVE_INTEGER*/_TEMP226)
        }
        CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE))
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/N + SDAI.FORCE_OPTIONAL(
          SDAI.INTEGER(1))) {
          for I in incrementControl {
            
            let _TEMP227 = FACTOR_SPACE(
              TSPACE: sTUPLE_SPACE(/*eMATHS_SPACE*/SPC1), 
              IDX: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/I))
            let _TEMP228 = FACTOR_SPACE(
              TSPACE: sTUPLE_SPACE(/*eMATHS_SPACE*/SPC2), 
              IDX: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/I))
            let _TEMP229 = SUBSPACE_OF(
              SPACE1: _TEMP227, SPACE2: _TEMP228)
            let _TEMP230 = CUM && _TEMP229
            CUM = SDAI.UNWRAP(_TEMP230)
            
            let _TEMP231 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
            if SDAI.IS_TRUE( _TEMP231 ) {
              return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                SDAI.FALSE)))
            }
          }
        }
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    
    let _TEMP232 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("FUNCTION_SPACE"))
    if SDAI.IS_TRUE( _TEMP232 ) {
      
      let _TEMP233 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("ELEMENTARY_SPACE"))
      if SDAI.IS_TRUE( _TEMP233 ) {
        
        let _TEMP234 = SPC2?.GROUP_REF(eELEMENTARY_SPACE.self)
        let _TEMP235 = _TEMP234?.SPACE_ID
        let _TEMP236 = _TEMP235 .==. SDAI.FORCE_OPTIONAL(ES_MATHS_FUNCTIONS)
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP236))
      }
      
      let _TEMP237 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("FUNCTION_SPACE"))
      if SDAI.IS_TRUE( _TEMP237 ) {
        CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.TRUE))
        
        let _TEMP238 = SPC1?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP239 = _TEMP238?.DOMAIN_ARGUMENT
        SP1 = _TEMP239
        
        let _TEMP240 = SPC2?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP241 = _TEMP240?.DOMAIN_ARGUMENT
        SP2 = _TEMP241
        
        let _TEMP242 = SPC1?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP243 = _TEMP242?.DOMAIN_CONSTRAINT
        if let selector = _TEMP243 {
          switch selector {
          case SC_EQUAL:
            //BEGIN
            
            let _TEMP244 = SPC2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP245 = _TEMP244?.DOMAIN_CONSTRAINT
            if let selector = _TEMP245 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP246 = EQUAL_MATHS_SPACES(
                  SPC1: SP1, SPC2: SP2)
                let _TEMP247 = CUM && _TEMP246
                CUM = SDAI.UNWRAP(_TEMP247)

              case SC_SUBSPACE:
                
                let _TEMP248 = SUBSPACE_OF(
                  SPACE1: SP1, SPACE2: SP2)
                let _TEMP249 = CUM && _TEMP248
                CUM = SDAI.UNWRAP(_TEMP249)

              case SC_MEMBER:
                
                let _TEMP250 = MEMBER_OF(
                  VAL: SP1, SPC: SP2)
                let _TEMP251 = CUM && _TEMP250
                CUM = SDAI.UNWRAP(_TEMP251)

              default: break
              } //end switch
            }
            //END

          case SC_SUBSPACE:
            //BEGIN
            
            let _TEMP252 = SPC2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP253 = _TEMP252?.DOMAIN_CONSTRAINT
            if let selector = _TEMP253 {
              switch selector {
              case SC_EQUAL:
                return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                  SDAI.FALSE)))

              case SC_SUBSPACE:
                
                let _TEMP254 = SUBSPACE_OF(
                  SPACE1: SP1, SPACE2: SP2)
                let _TEMP255 = CUM && _TEMP254
                CUM = SDAI.UNWRAP(_TEMP255)

              case SC_MEMBER:
                //BEGIN
                
                let _TEMP256 = MEMBER_OF(
                  VAL: SP1, SPC: SP2)
                let _TEMP257 =  !_TEMP256
                if SDAI.IS_TRUE( _TEMP257 ) {
                  return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                    SDAI.FALSE)))
                }
                CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN))
                //END

              default: break
              } //end switch
            }
            //END

          case SC_MEMBER:
            //BEGIN
            
            let _TEMP258 = SPC2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP259 = _TEMP258?.DOMAIN_CONSTRAINT
            if let selector = _TEMP259 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP260 = SPACE_IS_SINGLETON(SP1)
                let _TEMP261 = CUM && _TEMP260
                let _TEMP262 = SINGLETON_MEMBER_OF(SP1)
                let _TEMP263 = EQUAL_MATHS_SPACES(
                  SPC1: eMATHS_SPACE(/*sMATHS_VALUE*/_TEMP262), 
                  SPC2: SP2)
                let _TEMP264 = _TEMP261 && _TEMP263
                CUM = SDAI.UNWRAP(_TEMP264)

              case SC_SUBSPACE:
                //BEGIN
                
                let _TEMP265 = MEMBER_OF(
                  VAL: SP2, SPC: SP1)
                let _TEMP266 =  !_TEMP265
                if SDAI.IS_TRUE( _TEMP266 ) {
                  return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                    SDAI.FALSE)))
                }
                CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN))
                //END

              case SC_MEMBER:
                
                let _TEMP267 = SUBSPACE_OF(
                  SPACE1: SP1, SPACE2: SP2)
                let _TEMP268 = CUM && _TEMP267
                CUM = SDAI.UNWRAP(_TEMP268)

              default: break
              } //end switch
            }
            //END

          default: break
          } //end switch
        }
        
        let _TEMP269 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
        if SDAI.IS_TRUE( _TEMP269 ) {
          return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
        }
        
        let _TEMP270 = SPC1?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP271 = _TEMP270?.RANGE_ARGUMENT
        SP1 = _TEMP271
        
        let _TEMP272 = SPC2?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP273 = _TEMP272?.RANGE_ARGUMENT
        SP2 = _TEMP273
        
        let _TEMP274 = SPC1?.GROUP_REF(eFUNCTION_SPACE.self)
        let _TEMP275 = _TEMP274?.RANGE_CONSTRAINT
        if let selector = _TEMP275 {
          switch selector {
          case SC_EQUAL:
            //BEGIN
            
            let _TEMP276 = SPC2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP277 = _TEMP276?.RANGE_CONSTRAINT
            if let selector = _TEMP277 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP278 = EQUAL_MATHS_SPACES(
                  SPC1: SP1, SPC2: SP2)
                let _TEMP279 = CUM && _TEMP278
                CUM = SDAI.UNWRAP(_TEMP279)

              case SC_SUBSPACE:
                
                let _TEMP280 = SUBSPACE_OF(
                  SPACE1: SP1, SPACE2: SP2)
                let _TEMP281 = CUM && _TEMP280
                CUM = SDAI.UNWRAP(_TEMP281)

              case SC_MEMBER:
                
                let _TEMP282 = MEMBER_OF(
                  VAL: SP1, SPC: SP2)
                let _TEMP283 = CUM && _TEMP282
                CUM = SDAI.UNWRAP(_TEMP283)

              default: break
              } //end switch
            }
            //END

          case SC_SUBSPACE:
            //BEGIN
            
            let _TEMP284 = SPC2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP285 = _TEMP284?.DOMAIN_CONSTRAINT
            if let selector = _TEMP285 {
              switch selector {
              case SC_EQUAL:
                return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                  SDAI.FALSE)))

              case SC_SUBSPACE:
                
                let _TEMP286 = SUBSPACE_OF(
                  SPACE1: SP1, SPACE2: SP2)
                let _TEMP287 = CUM && _TEMP286
                CUM = SDAI.UNWRAP(_TEMP287)

              case SC_MEMBER:
                //BEGIN
                
                let _TEMP288 = MEMBER_OF(
                  VAL: SP1, SPC: SP2)
                let _TEMP289 =  !_TEMP288
                if SDAI.IS_TRUE( _TEMP289 ) {
                  return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                    SDAI.FALSE)))
                }
                CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN))
                //END

              default: break
              } //end switch
            }
            //END

          case SC_MEMBER:
            //BEGIN
            
            let _TEMP290 = SPC2?.GROUP_REF(eFUNCTION_SPACE.self)
            let _TEMP291 = _TEMP290?.DOMAIN_CONSTRAINT
            if let selector = _TEMP291 {
              switch selector {
              case SC_EQUAL:
                
                let _TEMP292 = SPACE_IS_SINGLETON(SP1)
                let _TEMP293 = CUM && _TEMP292
                let _TEMP294 = SINGLETON_MEMBER_OF(SP1)
                let _TEMP295 = EQUAL_MATHS_SPACES(
                  SPC1: eMATHS_SPACE(/*sMATHS_VALUE*/_TEMP294), 
                  SPC2: SP2)
                let _TEMP296 = _TEMP293 && _TEMP295
                CUM = SDAI.UNWRAP(_TEMP296)

              case SC_SUBSPACE:
                //BEGIN
                
                let _TEMP297 = MEMBER_OF(
                  VAL: SP2, SPC: SP1)
                let _TEMP298 =  !_TEMP297
                if SDAI.IS_TRUE( _TEMP298 ) {
                  return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                    SDAI.FALSE)))
                }
                CUM = SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN))
                //END

              case SC_MEMBER:
                
                let _TEMP299 = SUBSPACE_OF(
                  SPACE1: SP1, SPACE2: SP2)
                let _TEMP300 = CUM && _TEMP299
                CUM = SDAI.UNWRAP(_TEMP300)

              default: break
              } //end switch
            }
            //END

          default: break
          } //end switch
        }
        return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
      }
      return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
    }
    return _subspace_of__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.UNKNOWN)))
  }

}

//MARK: - function result cache
private var _subspace_of__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

