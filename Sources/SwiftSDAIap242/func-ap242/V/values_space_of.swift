/* file: values_space_of.swift 	 generated: Tue Nov 16 05:35:44 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION values_space_of(
               expr : generic_expression
           ) : maths_space;

    LOCAL
      e_prefix  : STRING := 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.';
      typenames : SET OF STRING := TYPEOF( expr );
    END_LOCAL;
    IF ( schema_prefix + 'MATHS_VARIABLE' ) IN typenames THEN
      RETURN( expr\maths_variable.values_space );
    END_IF;
    IF ( e_prefix + 'EXPRESSION' ) IN typenames THEN
      IF ( e_prefix + 'NUMERIC_EXPRESSION' ) IN typenames THEN
        IF expr\numeric_expression.is_int THEN
          IF ( e_prefix + 'INT_LITERAL' ) IN typenames THEN
            RETURN( make_finite_space( [expr\int_literal.the_value] ) );
          ELSE
            RETURN( the_integers );
          END_IF;
        ELSE
          IF ( e_prefix + 'REAL_LITERAL' ) IN typenames THEN
            RETURN( make_finite_space( [expr\real_literal.the_value] ) );
          ELSE
            RETURN( the_reals );
          END_IF;
        END_IF;
      END_IF;
      IF ( e_prefix + 'BOOLEAN_EXPRESSION' ) IN typenames THEN
        IF ( e_prefix + 'BOOLEAN_LITERAL' ) IN typenames THEN
          RETURN( make_finite_space( [expr\boolean_literal.the_value] ) );
        ELSE
          RETURN( the_booleans );
        END_IF;
      END_IF;
      IF ( e_prefix + 'STRING_EXPRESSION' ) IN typenames THEN
        IF ( e_prefix + 'STRING_LITERAL' ) IN typenames THEN
          RETURN( make_finite_space( [expr\string_literal.the_value] ) );
        ELSE
          RETURN( the_strings );
        END_IF;
      END_IF;
      RETURN( ? );
    END_IF;
    IF ( schema_prefix + 'MATHS_FUNCTION' ) IN typenames THEN
      IF expression_is_constant( expr ) THEN
        RETURN( make_finite_space( [expr] ) );
      ELSE
        RETURN( make_function_space( sc_equal, expr\maths_function.domain, sc_equal, expr\maths_function.
            range ) );
      END_IF;
    END_IF;
    IF ( schema_prefix + 'FUNCTION_APPLICATION' ) IN typenames THEN
      RETURN( expr\function_application.func.range );
    END_IF;
    IF ( schema_prefix + 'MATHS_SPACE' ) IN typenames THEN
      IF expression_is_constant( expr ) THEN
        RETURN( make_finite_space( [expr] ) );
      ELSE
        RETURN( make_elementary_space( es_maths_spaces ) );
      END_IF;
    END_IF;
    IF ( schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION' ) IN typenames THEN
      RETURN( values_space_of( expr\unary_generic_expression.operand ) );
    END_IF;
    IF ( schema_prefix + 'COMPLEX_NUMBER_LITERAL' ) IN typenames THEN
      RETURN( make_finite_space( [expr] ) );
    END_IF;
    IF ( schema_prefix + 'LOGICAL_LITERAL' ) IN typenames THEN
      RETURN( make_finite_space( [expr\logical_literal.lit_value] ) );
    END_IF;
    IF ( schema_prefix + 'BINARY_LITERAL' ) IN typenames THEN
      RETURN( make_finite_space( [expr\binary_literal.lit_value] ) );
    END_IF;
    IF ( schema_prefix + 'MATHS_ENUM_LITERAL' ) IN typenames THEN
      RETURN( make_finite_space( [expr\maths_enum_literal.lit_value] ) );
    END_IF;
    IF ( schema_prefix + 'REAL_TUPLE_LITERAL' ) IN typenames THEN
      RETURN( make_finite_space( [expr\real_tuple_literal.lit_value] ) );
    END_IF;
    IF ( schema_prefix + 'INTEGER_TUPLE_LITERAL' ) IN typenames THEN
      RETURN( make_finite_space( [expr\integer_tuple_literal.lit_value] ) );
    END_IF;
    IF ( schema_prefix + 'ATOM_BASED_LITERAL' ) IN typenames THEN
      RETURN( make_finite_space( [expr\atom_based_literal.lit_value] ) );
    END_IF;
    IF ( schema_prefix + 'MATHS_TUPLE_LITERAL' ) IN typenames THEN
      RETURN( make_finite_space( [expr\maths_tuple_literal.lit_value] ) );
    END_IF;
    IF ( schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION' ) IN typenames THEN
      RETURN( drop_numeric_constraints( values_space_of( expr\partial_derivative_expression.derivand ) ) );
    END_IF;
    IF ( schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION' ) IN typenames THEN
      RETURN( drop_numeric_constraints( values_space_of( expr\definite_integral_expression.integrand ) ) );
    END_IF;
    RETURN( ? );

  END_FUNCTION; -- values_space_of (line:48619 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func VALUES_SPACE_OF(_ EXPR: eGENERIC_EXPRESSION? ) 
    -> eMATHS_SPACE? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( EXPR )
    if case .available(let _cached_value) = _values_space_of__cache.cachedValue(params: _params) {
      return _cached_value as? eMATHS_SPACE
    }

    var EXPR = EXPR; SDAI.TOUCH(var: &EXPR)

    //LOCAL
    var E_PREFIX: SDAI.STRING?  = SDAI.STRING("AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF."); SDAI.TOUCH(var: &E_PREFIX)
    var TYPENAMES: SDAI.SET<SDAI.STRING>?  = SDAI.TYPEOF(EXPR); SDAI.TOUCH(var: &TYPENAMES)
    //END_LOCAL

    
    let _TEMP1 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("MATHS_VARIABLE"))
    let _TEMP2 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP1))
    if SDAI.IS_TRUE( _TEMP2 ) {
      
      let _TEMP3 = EXPR?.GROUP_REF(eMATHS_VARIABLE.self)
      let _TEMP4 = _TEMP3?.VALUES_SPACE
      return _values_space_of__cache.updateCache(params: _params, value: _TEMP4)
    }
    
    let _TEMP5 = E_PREFIX + SDAI.FORCE_OPTIONAL(SDAI.STRING("EXPRESSION"))
    let _TEMP6 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP5))
    if SDAI.IS_TRUE( _TEMP6 ) {
      
      let _TEMP7 = E_PREFIX + SDAI.FORCE_OPTIONAL(SDAI.STRING("NUMERIC_EXPRESSION"))
      let _TEMP8 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP7))
      if SDAI.IS_TRUE( _TEMP8 ) {
        
        let _TEMP9 = EXPR?.GROUP_REF(eNUMERIC_EXPRESSION.self)
        let _TEMP10 = _TEMP9?.IS_INT
        if SDAI.IS_TRUE( _TEMP10 ) {
          
          let _TEMP11 = E_PREFIX + SDAI.FORCE_OPTIONAL(SDAI.STRING("INT_LITERAL"))
          let _TEMP12 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP11))
          if SDAI.IS_TRUE( _TEMP12 ) {
            
            let _TEMP13 = EXPR?.GROUP_REF(eINT_LITERAL.self)
            let _TEMP14 = _TEMP13?.THE_VALUE
            let _TEMP15 = SDAI.SET<sMATHS_VALUE>(([
              SDAI.AIE(sMATHS_VALUE(/*SDAI.INTEGER*/_TEMP14))] as [SDAI.AggregationInitializerElement<
              sMATHS_VALUE>]))
            let _TEMP16 = MAKE_FINITE_SPACE(_TEMP15)
            return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
              _TEMP16))
          }
          else {
            return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*
              eELEMENTARY_SPACE*/THE_INTEGERS))
          }
        }
        else {
          
          let _TEMP17 = E_PREFIX + SDAI.FORCE_OPTIONAL(SDAI.STRING("REAL_LITERAL"))
          let _TEMP18 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP17))
          if SDAI.IS_TRUE( _TEMP18 ) {
            
            let _TEMP19 = EXPR?.GROUP_REF(eREAL_LITERAL.self)
            let _TEMP20 = _TEMP19?.THE_VALUE
            let _TEMP21 = SDAI.SET<sMATHS_VALUE>(([
              SDAI.AIE(sMATHS_VALUE(/*SDAI.REAL*/_TEMP20))] as [SDAI.AggregationInitializerElement<
              sMATHS_VALUE>]))
            let _TEMP22 = MAKE_FINITE_SPACE(_TEMP21)
            return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
              _TEMP22))
          }
          else {
            return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*
              eELEMENTARY_SPACE*/THE_REALS))
          }
        }
      }
      
      let _TEMP23 = E_PREFIX + SDAI.FORCE_OPTIONAL(SDAI.STRING("BOOLEAN_EXPRESSION"))
      let _TEMP24 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP23))
      if SDAI.IS_TRUE( _TEMP24 ) {
        
        let _TEMP25 = E_PREFIX + SDAI.FORCE_OPTIONAL(SDAI.STRING("BOOLEAN_LITERAL"))
        let _TEMP26 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP25))
        if SDAI.IS_TRUE( _TEMP26 ) {
          
          let _TEMP27 = EXPR?.GROUP_REF(eBOOLEAN_LITERAL.self)
          let _TEMP28 = _TEMP27?.THE_VALUE
          let _TEMP29 = SDAI.SET<sMATHS_VALUE>(([
            SDAI.AIE(sMATHS_VALUE(/*SDAI.BOOLEAN*/_TEMP28))] as [SDAI.AggregationInitializerElement<
            sMATHS_VALUE>]))
          let _TEMP30 = MAKE_FINITE_SPACE(_TEMP29)
          return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
            _TEMP30))
        }
        else {
          return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eELEMENTARY_SPACE*/
            THE_BOOLEANS))
        }
      }
      
      let _TEMP31 = E_PREFIX + SDAI.FORCE_OPTIONAL(SDAI.STRING("STRING_EXPRESSION"))
      let _TEMP32 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP31))
      if SDAI.IS_TRUE( _TEMP32 ) {
        
        let _TEMP33 = E_PREFIX + SDAI.FORCE_OPTIONAL(SDAI.STRING("STRING_LITERAL"))
        let _TEMP34 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP33))
        if SDAI.IS_TRUE( _TEMP34 ) {
          
          let _TEMP35 = EXPR?.GROUP_REF(eSTRING_LITERAL.self)
          let _TEMP36 = _TEMP35?.THE_VALUE
          let _TEMP37 = SDAI.SET<sMATHS_VALUE>(([
            SDAI.AIE(sMATHS_VALUE(/*SDAI.STRING*/_TEMP36))] as [SDAI.AggregationInitializerElement<
            sMATHS_VALUE>]))
          let _TEMP38 = MAKE_FINITE_SPACE(_TEMP37)
          return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
            _TEMP38))
        }
        else {
          return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eELEMENTARY_SPACE*/
            THE_STRINGS))
        }
      }
      return _values_space_of__cache.updateCache(params: _params, value: (nil as eMATHS_SPACE?))
    }
    
    let _TEMP39 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("MATHS_FUNCTION"))
    let _TEMP40 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP39))
    if SDAI.IS_TRUE( _TEMP40 ) {
      
      let _TEMP41 = EXPRESSION_IS_CONSTANT(EXPR)
      if SDAI.IS_TRUE( _TEMP41 ) {
        
        let _TEMP42 = SDAI.SET<sMATHS_VALUE>(([
          SDAI.AIE(sMATHS_VALUE(/*eGENERIC_EXPRESSION*/EXPR))] as [SDAI.AggregationInitializerElement<
          sMATHS_VALUE>]))
        let _TEMP43 = MAKE_FINITE_SPACE(_TEMP42)
        return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
          _TEMP43))
      }
      else {
        
        let _TEMP44 = EXPR?.GROUP_REF(eMATHS_FUNCTION.self)
        let _TEMP45 = _TEMP44?.DOMAIN
        let _TEMP46 = EXPR?.GROUP_REF(eMATHS_FUNCTION.self)
        let _TEMP47 = _TEMP46?.RANGE
        let _TEMP48 = MAKE_FUNCTION_SPACE(
          DOMAIN_CONSTRAINT: SC_EQUAL, 
          DOMAIN_ARGUMENT: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP45), 
          RANGE_CONSTRAINT: SC_EQUAL, 
          RANGE_ARGUMENT: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP47))
        return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFUNCTION_SPACE*/
          _TEMP48))
      }
    }
    
    let _TEMP49 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("FUNCTION_APPLICATION"))
    let _TEMP50 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP49))
    if SDAI.IS_TRUE( _TEMP50 ) {
      
      let _TEMP51 = EXPR?.GROUP_REF(eFUNCTION_APPLICATION.self)
      let _TEMP52 = _TEMP51?.FUNC
      let _TEMP53 = _TEMP52?.RANGE
      return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP53))
    }
    
    let _TEMP54 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("MATHS_SPACE"))
    let _TEMP55 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP54))
    if SDAI.IS_TRUE( _TEMP55 ) {
      
      let _TEMP56 = EXPRESSION_IS_CONSTANT(EXPR)
      if SDAI.IS_TRUE( _TEMP56 ) {
        
        let _TEMP57 = SDAI.SET<sMATHS_VALUE>(([
          SDAI.AIE(sMATHS_VALUE(/*eGENERIC_EXPRESSION*/EXPR))] as [SDAI.AggregationInitializerElement<
          sMATHS_VALUE>]))
        let _TEMP58 = MAKE_FINITE_SPACE(_TEMP57)
        return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
          _TEMP58))
      }
      else {
        
        let _TEMP59 = MAKE_ELEMENTARY_SPACE(ES_MATHS_SPACES)
        return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eELEMENTARY_SPACE*/
          _TEMP59))
      }
    }
    
    let _TEMP60 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING(
      "DEPENDENT_VARIABLE_DEFINITION"))
    let _TEMP61 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP60))
    if SDAI.IS_TRUE( _TEMP61 ) {
      
      let _TEMP62 = EXPR?.GROUP_REF(eUNARY_GENERIC_EXPRESSION.self)
      let _TEMP63 = _TEMP62?.OPERAND
      let _TEMP64 = VALUES_SPACE_OF(_TEMP63)
      return _values_space_of__cache.updateCache(params: _params, value: _TEMP64)
    }
    
    let _TEMP65 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("COMPLEX_NUMBER_LITERAL"))
    let _TEMP66 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP65))
    if SDAI.IS_TRUE( _TEMP66 ) {
      
      let _TEMP67 = SDAI.SET<sMATHS_VALUE>(([
        SDAI.AIE(sMATHS_VALUE(/*eGENERIC_EXPRESSION*/EXPR))] as [SDAI.AggregationInitializerElement<
        sMATHS_VALUE>]))
      let _TEMP68 = MAKE_FINITE_SPACE(_TEMP67)
      return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
        _TEMP68))
    }
    
    let _TEMP69 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("LOGICAL_LITERAL"))
    let _TEMP70 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP69))
    if SDAI.IS_TRUE( _TEMP70 ) {
      
      let _TEMP71 = EXPR?.GROUP_REF(eLOGICAL_LITERAL.self)
      let _TEMP72 = _TEMP71?.LIT_VALUE
      let _TEMP73 = SDAI.SET<sMATHS_VALUE>(([
        SDAI.AIE(sMATHS_VALUE(/*SDAI.LOGICAL*/_TEMP72))] as [SDAI.AggregationInitializerElement<sMATHS_VALUE>]))
      let _TEMP74 = MAKE_FINITE_SPACE(_TEMP73)
      return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
        _TEMP74))
    }
    
    let _TEMP75 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("BINARY_LITERAL"))
    let _TEMP76 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP75))
    if SDAI.IS_TRUE( _TEMP76 ) {
      
      let _TEMP77 = EXPR?.GROUP_REF(eBINARY_LITERAL.self)
      let _TEMP78 = _TEMP77?.LIT_VALUE
      let _TEMP79 = SDAI.SET<sMATHS_VALUE>(([
        SDAI.AIE(sMATHS_VALUE(/*SDAI.BINARY*/_TEMP78))] as [SDAI.AggregationInitializerElement<sMATHS_VALUE>]))
      let _TEMP80 = MAKE_FINITE_SPACE(_TEMP79)
      return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
        _TEMP80))
    }
    
    let _TEMP81 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("MATHS_ENUM_LITERAL"))
    let _TEMP82 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP81))
    if SDAI.IS_TRUE( _TEMP82 ) {
      
      let _TEMP83 = EXPR?.GROUP_REF(eMATHS_ENUM_LITERAL.self)
      let _TEMP84 = _TEMP83?.LIT_VALUE
      let _TEMP85 = SDAI.SET<sMATHS_VALUE>(([
        SDAI.AIE(sMATHS_VALUE(/*sMATHS_ENUM_ATOM*/_TEMP84))] as [SDAI.AggregationInitializerElement<
        sMATHS_VALUE>]))
      let _TEMP86 = MAKE_FINITE_SPACE(_TEMP85)
      return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
        _TEMP86))
    }
    
    let _TEMP87 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("REAL_TUPLE_LITERAL"))
    let _TEMP88 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP87))
    if SDAI.IS_TRUE( _TEMP88 ) {
      
      let _TEMP89 = EXPR?.GROUP_REF(eREAL_TUPLE_LITERAL.self)
      let _TEMP90 = _TEMP89?.LIT_VALUE
      let _TEMP91 = SDAI.SET<sMATHS_VALUE>(([
        SDAI.AIE(sMATHS_VALUE(/*SDAI.LIST<SDAI.REAL>*/_TEMP90))] as [SDAI.AggregationInitializerElement<
        sMATHS_VALUE>]))
      let _TEMP92 = MAKE_FINITE_SPACE(_TEMP91)
      return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
        _TEMP92))
    }
    
    let _TEMP93 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("INTEGER_TUPLE_LITERAL"))
    let _TEMP94 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP93))
    if SDAI.IS_TRUE( _TEMP94 ) {
      
      let _TEMP95 = EXPR?.GROUP_REF(eINTEGER_TUPLE_LITERAL.self)
      let _TEMP96 = _TEMP95?.LIT_VALUE
      let _TEMP97 = SDAI.SET<sMATHS_VALUE>(([
        SDAI.AIE(sMATHS_VALUE(/*SDAI.LIST<SDAI.INTEGER>*/_TEMP96))] as [SDAI.AggregationInitializerElement<
        sMATHS_VALUE>]))
      let _TEMP98 = MAKE_FINITE_SPACE(_TEMP97)
      return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
        _TEMP98))
    }
    
    let _TEMP99 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("ATOM_BASED_LITERAL"))
    let _TEMP100 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP99))
    if SDAI.IS_TRUE( _TEMP100 ) {
      
      let _TEMP101 = EXPR?.GROUP_REF(eATOM_BASED_LITERAL.self)
      let _TEMP102 = _TEMP101?.LIT_VALUE
      let _TEMP103 = SDAI.SET<sMATHS_VALUE>(([
        SDAI.AIE(sMATHS_VALUE(/*sATOM_BASED_VALUE*/_TEMP102))] as [SDAI.AggregationInitializerElement<
        sMATHS_VALUE>]))
      let _TEMP104 = MAKE_FINITE_SPACE(_TEMP103)
      return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
        _TEMP104))
    }
    
    let _TEMP105 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("MATHS_TUPLE_LITERAL"))
    let _TEMP106 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP105))
    if SDAI.IS_TRUE( _TEMP106 ) {
      
      let _TEMP107 = EXPR?.GROUP_REF(eMATHS_TUPLE_LITERAL.self)
      let _TEMP108 = _TEMP107?.LIT_VALUE
      let _TEMP109 = SDAI.SET<sMATHS_VALUE>(([
        SDAI.AIE(sMATHS_VALUE(/*SDAI.LIST<sMATHS_VALUE>*/_TEMP108))] as [SDAI.AggregationInitializerElement<
        sMATHS_VALUE>]))
      let _TEMP110 = MAKE_FINITE_SPACE(_TEMP109)
      return _values_space_of__cache.updateCache(params: _params, value: eMATHS_SPACE(/*eFINITE_SPACE*/
        _TEMP110))
    }
    
    let _TEMP111 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING(
      "PARTIAL_DERIVATIVE_EXPRESSION"))
    let _TEMP112 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP111))
    if SDAI.IS_TRUE( _TEMP112 ) {
      
      let _TEMP113 = EXPR?.GROUP_REF(ePARTIAL_DERIVATIVE_EXPRESSION.self)
      let _TEMP114 = _TEMP113?.DERIVAND
      let _TEMP115 = VALUES_SPACE_OF(_TEMP114)
      let _TEMP116 = DROP_NUMERIC_CONSTRAINTS(_TEMP115)
      return _values_space_of__cache.updateCache(params: _params, value: _TEMP116)
    }
    
    let _TEMP117 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING(
      "DEFINITE_INTEGRAL_EXPRESSION"))
    let _TEMP118 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP117))
    if SDAI.IS_TRUE( _TEMP118 ) {
      
      let _TEMP119 = EXPR?.GROUP_REF(eDEFINITE_INTEGRAL_EXPRESSION.self)
      let _TEMP120 = _TEMP119?.INTEGRAND
      let _TEMP121 = VALUES_SPACE_OF(_TEMP120)
      let _TEMP122 = DROP_NUMERIC_CONSTRAINTS(_TEMP121)
      return _values_space_of__cache.updateCache(params: _params, value: _TEMP122)
    }
    return _values_space_of__cache.updateCache(params: _params, value: (nil as eMATHS_SPACE?))
  }

}

//MARK: - function result cache
private var _values_space_of__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

