/* file: validate_countersink_radii.swift 	 generated: Sat Aug 14 13:46:02 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION validate_countersink_radii(
               cskhole : solid_with_stepped_round_hole_and_conical_transitions
           ) : BOOLEAN;

    LOCAL
      j       : INTEGER;
      n       : INTEGER := 1 + cskhole\solid_with_stepped_round_hole.segments;
      smaller : positive_length_measure;
      larger  : positive_length_measure;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF( cskhole.conical_transitions ) BY 1;
      IF ( ( cskhole.conical_transitions[i].transition_number = 1 ) AND ( cskhole.conical_transitions[i].
          cone_apex_angle < 0 ) ) XOR ( ( cskhole.conical_transitions[i].transition_number = n ) AND ( 
          cskhole.conical_transitions[i].cone_apex_angle > 0 ) ) THEN
        RETURN( FALSE );
      ELSE
        IF ( cskhole.conical_transitions[i].transition_number <> 1 ) AND ( cskhole.conical_transitions[i].
            transition_number <> n ) THEN

          BEGIN
            j := cskhole.conical_transitions[i].transition_number;
            IF cskhole\solid_with_stepped_round_hole.segment_radii[j] > cskhole\solid_with_stepped_round_hole
                .segment_radii[j - 1] THEN

              BEGIN
                IF cskhole.conical_transitions[i].cone_apex_angle > 0 THEN
                  RETURN( FALSE );
                END_IF;
                larger := cskhole\solid_with_stepped_round_hole.segment_radii[j];
                smaller := cskhole\solid_with_stepped_round_hole.segment_radii[j - 1];
              END;
            ELSE

              BEGIN
                IF cskhole.conical_transitions[i].cone_apex_angle < 0 THEN
                  RETURN( FALSE );
                END_IF;
                larger := cskhole\solid_with_stepped_round_hole.segment_radii[j - 1];
                smaller := cskhole\solid_with_stepped_round_hole.segment_radii[j];
              END;
            END_IF;
            IF ( cskhole.conical_transitions[i].cone_base_radius > larger ) OR ( cskhole.conical_transitions[
                i].cone_base_radius < smaller ) THEN
              RETURN( FALSE );
            END_IF;
          END;
        END_IF;
      END_IF;
    END_REPEAT;
    RETURN( TRUE );

  END_FUNCTION; -- validate_countersink_radii (line:48199 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func VALIDATE_COUNTERSINK_RADII(_ CSKHOLE: eSOLID_WITH_STEPPED_ROUND_HOLE_AND_CONICAL_TRANSITIONS? ) 
    -> SDAI.BOOLEAN? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( CSKHOLE )
    if case .available(let _cached_value) = _validate_countersink_radii__cache.cachedValue(params: _params) {
      return _cached_value as? SDAI.BOOLEAN
    }

    var CSKHOLE = CSKHOLE; SDAI.TOUCH(var: &CSKHOLE)

    //LOCAL
    var J: SDAI.INTEGER? 
    var N: SDAI.INTEGER?  = SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) + CSKHOLE?.GROUP_REF(
                            eSOLID_WITH_STEPPED_ROUND_HOLE.self)?.SEGMENTS; SDAI.TOUCH(var: &N)
    var SMALLER: tPOSITIVE_LENGTH_MEASURE? 
    var LARGER: tPOSITIVE_LENGTH_MEASURE? 
    //END_LOCAL

    if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
      CSKHOLE?.CONICAL_TRANSITIONS)) {
      for I in incrementControl {
        
        let _TEMP1 = CSKHOLE?.CONICAL_TRANSITIONS
        let _TEMP2 = _TEMP1?[I]
        let _TEMP3 = _TEMP2?.TRANSITION_NUMBER
        let _TEMP4 = _TEMP3 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
        let _TEMP5 = CSKHOLE?.CONICAL_TRANSITIONS
        let _TEMP6 = _TEMP5?[I]
        let _TEMP7 = _TEMP6?.CONE_APEX_ANGLE
        let _TEMP8 = _TEMP7 < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        let _TEMP9 = _TEMP4 && _TEMP8
        let _TEMP10 = CSKHOLE?.CONICAL_TRANSITIONS
        let _TEMP11 = _TEMP10?[I]
        let _TEMP12 = _TEMP11?.TRANSITION_NUMBER
        let _TEMP13 = _TEMP12 .==. N
        let _TEMP14 = CSKHOLE?.CONICAL_TRANSITIONS
        let _TEMP15 = _TEMP14?[I]
        let _TEMP16 = _TEMP15?.CONE_APEX_ANGLE
        let _TEMP17 = _TEMP16 > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        let _TEMP18 = _TEMP13 && _TEMP17
        let _TEMP19 = _TEMP9 .!=. _TEMP18
        if SDAI.IS_TRUE( _TEMP19 ) {
          return _validate_countersink_radii__cache.updateCache(params: _params, value: SDAI.BOOLEAN(
            SDAI.FALSE))
        }
        else {
          
          let _TEMP20 = CSKHOLE?.CONICAL_TRANSITIONS
          let _TEMP21 = _TEMP20?[I]
          let _TEMP22 = _TEMP21?.TRANSITION_NUMBER
          let _TEMP23 = _TEMP22 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          let _TEMP24 = CSKHOLE?.CONICAL_TRANSITIONS
          let _TEMP25 = _TEMP24?[I]
          let _TEMP26 = _TEMP25?.TRANSITION_NUMBER
          let _TEMP27 = _TEMP26 .!=. N
          let _TEMP28 = _TEMP23 && _TEMP27
          if SDAI.IS_TRUE( _TEMP28 ) {
            //BEGIN
            
            let _TEMP29 = CSKHOLE?.CONICAL_TRANSITIONS
            let _TEMP30 = _TEMP29?[I]
            let _TEMP31 = _TEMP30?.TRANSITION_NUMBER
            J = SDAI.INTEGER(/*tPOSITIVE_INTEGER*/_TEMP31)
            
            let _TEMP32 = CSKHOLE?.GROUP_REF(eSOLID_WITH_STEPPED_ROUND_HOLE.self)
            let _TEMP33 = _TEMP32?.SEGMENT_RADII
            let _TEMP34 = _TEMP33?[J]
            let _TEMP35 = CSKHOLE?.GROUP_REF(eSOLID_WITH_STEPPED_ROUND_HOLE.self)
            let _TEMP36 = _TEMP35?.SEGMENT_RADII
            let _TEMP37 = J - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
            let _TEMP38 = _TEMP36?[_TEMP37]
            let _TEMP39 = _TEMP34 > _TEMP38
            if SDAI.IS_TRUE( _TEMP39 ) {
              //BEGIN
              
              let _TEMP40 = CSKHOLE?.CONICAL_TRANSITIONS
              let _TEMP41 = _TEMP40?[I]
              let _TEMP42 = _TEMP41?.CONE_APEX_ANGLE
              let _TEMP43 = _TEMP42 > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
              if SDAI.IS_TRUE( _TEMP43 ) {
                return _validate_countersink_radii__cache.updateCache(params: _params, value: SDAI.BOOLEAN(
                  SDAI.FALSE))
              }
              
              let _TEMP44 = CSKHOLE?.GROUP_REF(eSOLID_WITH_STEPPED_ROUND_HOLE.self)
              let _TEMP45 = _TEMP44?.SEGMENT_RADII
              let _TEMP46 = _TEMP45?[J]
              LARGER = _TEMP46
              
              let _TEMP47 = CSKHOLE?.GROUP_REF(eSOLID_WITH_STEPPED_ROUND_HOLE.self)
              let _TEMP48 = _TEMP47?.SEGMENT_RADII
              let _TEMP49 = J - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
              let _TEMP50 = _TEMP48?[_TEMP49]
              SMALLER = _TEMP50
              //END
            }
            else {
              //BEGIN
              
              let _TEMP51 = CSKHOLE?.CONICAL_TRANSITIONS
              let _TEMP52 = _TEMP51?[I]
              let _TEMP53 = _TEMP52?.CONE_APEX_ANGLE
              let _TEMP54 = _TEMP53 < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
              if SDAI.IS_TRUE( _TEMP54 ) {
                return _validate_countersink_radii__cache.updateCache(params: _params, value: SDAI.BOOLEAN(
                  SDAI.FALSE))
              }
              
              let _TEMP55 = CSKHOLE?.GROUP_REF(eSOLID_WITH_STEPPED_ROUND_HOLE.self)
              let _TEMP56 = _TEMP55?.SEGMENT_RADII
              let _TEMP57 = J - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
              let _TEMP58 = _TEMP56?[_TEMP57]
              LARGER = _TEMP58
              
              let _TEMP59 = CSKHOLE?.GROUP_REF(eSOLID_WITH_STEPPED_ROUND_HOLE.self)
              let _TEMP60 = _TEMP59?.SEGMENT_RADII
              let _TEMP61 = _TEMP60?[J]
              SMALLER = _TEMP61
              //END
            }
            
            let _TEMP62 = CSKHOLE?.CONICAL_TRANSITIONS
            let _TEMP63 = _TEMP62?[I]
            let _TEMP64 = _TEMP63?.CONE_BASE_RADIUS
            let _TEMP65 = _TEMP64 > LARGER
            let _TEMP66 = CSKHOLE?.CONICAL_TRANSITIONS
            let _TEMP67 = _TEMP66?[I]
            let _TEMP68 = _TEMP67?.CONE_BASE_RADIUS
            let _TEMP69 = _TEMP68 < SMALLER
            let _TEMP70 = _TEMP65 || _TEMP69
            if SDAI.IS_TRUE( _TEMP70 ) {
              return _validate_countersink_radii__cache.updateCache(params: _params, value: SDAI.BOOLEAN(
                SDAI.FALSE))
            }
            //END
          }
        }
      }
    }
    return _validate_countersink_radii__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
  }

}

//MARK: - function result cache
private var _validate_countersink_radii__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

