/* file: dependently_instantiated.swift 	 generated: Tue Nov 16 05:35:44 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION dependently_instantiated(
               set_of_input_instances : SET OF GENERIC:igen;
               set_of_input_types : SET OF STRING;
               previous_in_chain : LIST OF GENERIC:cgen
           ) : BOOLEAN;

    FUNCTION is_referenced_by_outer_world(
                 subject : GENERIC:cgen;
                 in_chain : LIST OF GENERIC:cgen
             ) : BOOLEAN;

      LOCAL
        set_of_referring_instances    : SET OF GENERIC:cgen;
        number_of_referring_instances : INTEGER;
        child                         : GENERIC:cgen;
        set_of_types                  : SET OF STRING;
      END_LOCAL;
      IF subject IN succeededs THEN
        RETURN( TRUE );
      END_IF;
      IF subject IN dead_ends THEN
        RETURN( FALSE );
      END_IF;
      set_of_referring_instances := bag_to_set( USEDIN( subject, '' ) );
      IF NOT EXISTS( set_of_referring_instances ) THEN
        dead_ends := dead_ends + subject;
        RETURN( FALSE );
      END_IF;
      set_of_referring_instances := set_of_referring_instances - ( dead_ends + in_chain );
      number_of_referring_instances := SIZEOF( set_of_referring_instances );
      REPEAT j := 1 TO number_of_referring_instances BY 1;
        child := set_of_referring_instances[j];
        set_of_types := TYPEOF( child );
        IF NOT ( set_of_types <= set_of_input_types ) THEN
          succeededs := succeededs + in_chain + subject + child;
          RETURN( TRUE );
        END_IF;
        IF is_referenced_by_outer_world( child, in_chain + subject ) THEN
          RETURN( TRUE );
        END_IF;
      END_REPEAT;
      dead_ends := dead_ends + subject;
      RETURN( FALSE );

    END_FUNCTION; -- is_referenced_by_outer_world (line:37565 file:ap242ed2_mim_lf_v1.101.TY.exp)

    LOCAL
      succeededs                : SET OF GENERIC:cgen := [];
      dead_ends                 : SET OF GENERIC:cgen := [];
      number_of_input_instances : INTEGER;
      input_instance_cgen       : GENERIC:cgen;
    END_LOCAL;
    IF NOT EXISTS( set_of_input_instances ) THEN
      RETURN( FALSE );
    END_IF;
    number_of_input_instances := SIZEOF( set_of_input_instances );
    set_of_input_types := set_of_input_types + 'GENERIC';
    REPEAT i := 1 TO number_of_input_instances BY 1;
      input_instance_cgen := set_of_input_instances[i];
      IF NOT is_referenced_by_outer_world( input_instance_cgen, previous_in_chain ) THEN
        RETURN( FALSE );
      END_IF;
    END_REPEAT;
    RETURN( TRUE );

  END_FUNCTION; -- dependently_instantiated (line:37551 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func DEPENDENTLY_INSTANTIATED<gIGEN: SDAIGenericType, gCGEN: SDAIGenericType>(
    SET_OF_INPUT_INSTANCES: SDAI.SET<gIGEN>? , SET_OF_INPUT_TYPES: SDAI.SET<SDAI.STRING>? , 
    PREVIOUS_IN_CHAIN: SDAI.LIST<gCGEN>? ) 
    -> SDAI.BOOLEAN? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( SET_OF_INPUT_INSTANCES, SET_OF_INPUT_TYPES, 
      PREVIOUS_IN_CHAIN )
    if case .available(let _cached_value) = _dependently_instantiated__cache.cachedValue(params: _params) {
      return _cached_value as? SDAI.BOOLEAN
    }

    var SET_OF_INPUT_INSTANCES = SET_OF_INPUT_INSTANCES; SDAI.TOUCH(var: &SET_OF_INPUT_INSTANCES)
    var SET_OF_INPUT_TYPES = SET_OF_INPUT_TYPES; SDAI.TOUCH(var: &SET_OF_INPUT_TYPES)
    var PREVIOUS_IN_CHAIN = PREVIOUS_IN_CHAIN; SDAI.TOUCH(var: &PREVIOUS_IN_CHAIN)

    //NESTED FUNCTION
    func IS_REFERENCED_BY_OUTER_WORLD(
      SUBJECT: gCGEN? , IN_CHAIN: SDAI.LIST<gCGEN>? ) 
      -> SDAI.BOOLEAN? {

      var SUBJECT = SUBJECT; SDAI.TOUCH(var: &SUBJECT)
      var IN_CHAIN = IN_CHAIN; SDAI.TOUCH(var: &IN_CHAIN)

      //LOCAL
      var SET_OF_REFERRING_INSTANCES: SDAI.SET<gCGEN>? 
      var NUMBER_OF_REFERRING_INSTANCES: SDAI.INTEGER? 
      var CHILD: gCGEN? 
      var SET_OF_TYPES: SDAI.SET<SDAI.STRING>? 
      //END_LOCAL

      
      let _TEMP1 = SDAI.aggregate(SUCCEEDEDS, contains: SUBJECT)
      if SDAI.IS_TRUE( _TEMP1 ) {
        return SDAI.BOOLEAN(SDAI.TRUE)
      }
      
      let _TEMP2 = SDAI.aggregate(DEAD_ENDS, contains: SUBJECT)
      if SDAI.IS_TRUE( _TEMP2 ) {
        return SDAI.BOOLEAN(SDAI.FALSE)
      }
      
      let _TEMP3 = SDAI.USEDIN(T: SUBJECT)
      let _TEMP4 = BAG_TO_SET(_TEMP3)
      SET_OF_REFERRING_INSTANCES = SDAI.SET<gCGEN>(generic: /*SDAI.SET<gINTYPE>*/_TEMP4)
      
      let _TEMP5 = SDAI.EXISTS(SET_OF_REFERRING_INSTANCES)
      let _TEMP6 =  !_TEMP5
      if SDAI.IS_TRUE( _TEMP6 ) {
        
        let _TEMP7 = DEAD_ENDS + SUBJECT
        DEAD_ENDS = _TEMP7
        return SDAI.BOOLEAN(SDAI.FALSE)
      }
      
      let _TEMP8 = DEAD_ENDS + IN_CHAIN
      let _TEMP9 = SET_OF_REFERRING_INSTANCES - _TEMP8
      SET_OF_REFERRING_INSTANCES = _TEMP9
      
      let _TEMP10 = SDAI.SIZEOF(SET_OF_REFERRING_INSTANCES)
      NUMBER_OF_REFERRING_INSTANCES = 
        _TEMP10
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
        NUMBER_OF_REFERRING_INSTANCES) {
        for J in incrementControl {
          
          let _TEMP11 = SET_OF_REFERRING_INSTANCES?[J]
          CHILD = _TEMP11
          
          let _TEMP12 = SDAI.TYPEOF(CHILD)
          SET_OF_TYPES = _TEMP12
          
          let _TEMP13 = SET_OF_TYPES <= SET_OF_INPUT_TYPES
          let _TEMP14 =  !_TEMP13
          if SDAI.IS_TRUE( _TEMP14 ) {
            
            let _TEMP15 = SUCCEEDEDS + IN_CHAIN
            let _TEMP16 = _TEMP15 + SUBJECT
            let _TEMP17 = _TEMP16 + CHILD
            SUCCEEDEDS = _TEMP17
            return SDAI.BOOLEAN(SDAI.TRUE)
          }
          
          let _TEMP18 = IN_CHAIN + SUBJECT
          let _TEMP19 = IS_REFERENCED_BY_OUTER_WORLD(
            SUBJECT: CHILD, IN_CHAIN: _TEMP18)
          if SDAI.IS_TRUE( _TEMP19 ) {
            return SDAI.BOOLEAN(SDAI.TRUE)
          }
        }
      }
      
      let _TEMP20 = DEAD_ENDS + SUBJECT
      DEAD_ENDS = _TEMP20
      return SDAI.BOOLEAN(SDAI.FALSE)
    } //END FUNCTION IS_REFERENCED_BY_OUTER_WORLD

    //LOCAL
    var SUCCEEDEDS: SDAI.SET<gCGEN>?  = SDAI.SET<gCGEN>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &SUCCEEDEDS)
    var DEAD_ENDS: SDAI.SET<gCGEN>?  = SDAI.SET<gCGEN>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &DEAD_ENDS)
    var NUMBER_OF_INPUT_INSTANCES: SDAI.INTEGER? 
    var INPUT_INSTANCE_CGEN: gCGEN? 
    //END_LOCAL

    
    let _TEMP1 = SDAI.EXISTS(SET_OF_INPUT_INSTANCES)
    let _TEMP2 =  !_TEMP1
    if SDAI.IS_TRUE( _TEMP2 ) {
      return _dependently_instantiated__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP3 = SDAI.SIZEOF(SET_OF_INPUT_INSTANCES)
    NUMBER_OF_INPUT_INSTANCES = _TEMP3
    
    let _TEMP4 = SET_OF_INPUT_TYPES + SDAI.FORCE_OPTIONAL(SDAI.STRING("GENERIC"))
    SET_OF_INPUT_TYPES = _TEMP4
    if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
      NUMBER_OF_INPUT_INSTANCES) {
      for I in incrementControl {
        
        let _TEMP5 = SET_OF_INPUT_INSTANCES?[I]
        INPUT_INSTANCE_CGEN = gCGEN(fromGeneric: /*gIGEN*/_TEMP5)
        
        let _TEMP6 = IS_REFERENCED_BY_OUTER_WORLD(
          SUBJECT: INPUT_INSTANCE_CGEN, 
          IN_CHAIN: PREVIOUS_IN_CHAIN)
        let _TEMP7 =  !_TEMP6
        if SDAI.IS_TRUE( _TEMP7 ) {
          return _dependently_instantiated__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
        }
      }
    }
    return _dependently_instantiated__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
  }

}

//MARK: - function result cache
private var _dependently_instantiated__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

