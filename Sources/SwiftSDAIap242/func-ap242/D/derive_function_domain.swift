/* file: derive_function_domain.swift 	 generated: Sun Oct 31 15:32:10 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION derive_function_domain(
               func : maths_function
           ) : tuple_space;

    LOCAL
      typenames  : SET OF STRING := stripped_typeof( func );
      tspace     : tuple_space := make_listed_product_space( [] );
      shape      : LIST OF positive_integer;
      sidxs      : LIST OF INTEGER := [0];
      itvl       : finite_integer_interval;
      factors    : LIST OF finite_integer_interval := [];
      is_uniform : BOOLEAN := TRUE;
    END_LOCAL;
    IF 'FINITE_FUNCTION' IN typenames THEN
      RETURN( derive_finite_function_domain( func\finite_function.pairs ) );
    END_IF;
    IF 'CONSTANT_FUNCTION' IN typenames THEN
      RETURN( domain_from( func\constant_function.source_of_domain ) );
    END_IF;
    IF 'SELECTOR_FUNCTION' IN typenames THEN
      RETURN( domain_from( func\selector_function.source_of_domain ) );
    END_IF;
    IF 'ELEMENTARY_FUNCTION' IN typenames THEN
      RETURN( derive_elementary_function_domain( func\elementary_function.func_id ) );
    END_IF;
    IF 'RESTRICTION_FUNCTION' IN typenames THEN
      RETURN( one_tuples_of( func\restriction_function.operand ) );
    END_IF;
    IF 'REPACKAGING_FUNCTION' IN typenames THEN
      IF func\repackaging_function.input_repack = ro_nochange THEN
        RETURN( func\repackaging_function.operand.domain );
      END_IF;
      IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
        RETURN( factor1( func\repackaging_function.operand.domain ) );
      END_IF;
      IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
        RETURN( one_tuples_of( func\repackaging_function.operand.domain ) );
      END_IF;
      RETURN( ? );
    END_IF;
    IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
      shape := shape_of_array( func\unary_generic_expression.operand );
      sidxs := func\reindexed_array_function.starting_indices;
      REPEAT i := 1 TO SIZEOF( shape ) BY 1;
        itvl := make_finite_integer_interval( sidxs[i], ( sidxs[i] + shape[i] ) - 1 );
        INSERT( factors, itvl, i - 1 );
        IF shape[i] <> shape[1] THEN
          is_uniform := FALSE;
        END_IF;
      END_REPEAT;
      IF is_uniform THEN
        RETURN( make_uniform_product_space( factors[1], SIZEOF( shape ) ) );
      END_IF;
      RETURN( make_listed_product_space( factors ) );
    END_IF;
    IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
      RETURN( func\series_composed_function.operands[1].domain );
    END_IF;
    IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
      RETURN( domain_from( func\parallel_composed_function.source_of_domain ) );
    END_IF;
    IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
      shape := func\explicit_table_function.shape;
      sidxs[1] := func\explicit_table_function.index_base;
      REPEAT i := 1 TO SIZEOF( shape ) BY 1;
        itvl := make_finite_integer_interval( sidxs[1], ( sidxs[1] + shape[i] ) - 1 );
        INSERT( factors, itvl, i - 1 );
        IF shape[i] <> shape[1] THEN
          is_uniform := FALSE;
        END_IF;
      END_REPEAT;
      IF is_uniform THEN
        RETURN( make_uniform_product_space( factors[1], SIZEOF( shape ) ) );
      END_IF;
      RETURN( make_listed_product_space( factors ) );
    END_IF;
    IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
      RETURN( one_tuples_of( make_uniform_product_space( factor1( func\homogeneous_linear_function.mat.range ), 
          func\homogeneous_linear_function.mat\explicit_table_function.shape[func\homogeneous_linear_function
          .sum_index] ) ) );
    END_IF;
    IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
      RETURN( one_tuples_of( make_uniform_product_space( factor1( func\general_linear_function.mat.range ), 
          func\general_linear_function.mat\explicit_table_function.shape[func\general_linear_function.
          sum_index] - 1 ) ) );
    END_IF;
    IF 'B_SPLINE_BASIS' IN typenames THEN
      RETURN( one_tuples_of( make_finite_real_interval( func\b_spline_basis.repeated_knots[func\
          b_spline_basis.order], closed, func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis + 1], 
          closed ) ) );
    END_IF;
    IF 'B_SPLINE_FUNCTION' IN typenames THEN
      REPEAT i := 1 TO SIZEOF( func\b_spline_function.basis ) BY 1;
        tspace := assoc_product_space( tspace, func\b_spline_function.basis[i].domain );
      END_REPEAT;
      RETURN( one_tuples_of( tspace ) );
    END_IF;
    IF 'RATIONALIZE_FUNCTION' IN typenames THEN
      RETURN( func\rationalize_function.fun.domain );
    END_IF;
    IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
      RETURN( func\partial_derivative_function.derivand.domain );
    END_IF;
    IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
      RETURN( derive_definite_integral_domain( func ) );
    END_IF;
    IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
      REPEAT i := 1 TO SIZEOF( func\abstracted_expression_function.variables ) BY 1;
        tspace := assoc_product_space( tspace, one_tuples_of( values_space_of( func\
            abstracted_expression_function.variables[i] ) ) );
      END_REPEAT;
      RETURN( tspace );
    END_IF;
    IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
      RETURN( values_space_of( func\expression_denoted_function.expr )\function_space.domain_argument );
    END_IF;
    IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
      RETURN( one_tuples_of( make_listed_product_space( [] ) ) );
    END_IF;
    IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
      RETURN( func\imported_curve_function.parametric_domain );
    END_IF;
    IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
      RETURN( func\imported_surface_function.parametric_domain );
    END_IF;
    IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
      RETURN( func\imported_volume_function.parametric_domain );
    END_IF;
    IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
      RETURN( func\application_defined_function.explicit_domain );
    END_IF;
    RETURN( ? );

  END_FUNCTION; -- derive_function_domain (line:38102 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func DERIVE_FUNCTION_DOMAIN(_ FUNC: eMATHS_FUNCTION? ) 
    -> sTUPLE_SPACE? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( FUNC )
    if case .available(let _cached_value) = _derive_function_domain__cache.cachedValue(params: _params) {
      return _cached_value as? sTUPLE_SPACE
    }

    var FUNC = FUNC; SDAI.TOUCH(var: &FUNC)

    //LOCAL
    var TYPENAMES: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(FUNC); SDAI.TOUCH(var: &TYPENAMES)
    var TSPACE: sTUPLE_SPACE?  = sTUPLE_SPACE(/*eLISTED_PRODUCT_SPACE*/MAKE_LISTED_PRODUCT_SPACE(
                                 SDAI.LIST<eMATHS_SPACE>(SDAI.EMPLY_AGGREGATE))); SDAI.TOUCH(var: &TSPACE)
    var SHAPE: SDAI.LIST<tPOSITIVE_INTEGER>? 
    var SIDXS: SDAI.LIST<SDAI.INTEGER>?  = SDAI.LIST<SDAI.INTEGER>(([
                                           SDAI.AIE(SDAI.INTEGER(0))] as [SDAI.AggregationInitializerElement<
                                           SDAI.INTEGER>])); SDAI.TOUCH(var: &SIDXS)
    var ITVL: eFINITE_INTEGER_INTERVAL? 
    var FACTORS: SDAI.LIST<eFINITE_INTEGER_INTERVAL>?  = SDAI.LIST<eFINITE_INTEGER_INTERVAL>(
                                                         SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &FACTORS)
    var IS_UNIFORM: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.TRUE); SDAI.TOUCH(var: &IS_UNIFORM)
    //END_LOCAL

    
    let _TEMP1 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("FINITE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP1 ) {
      
      let _TEMP2 = FUNC?.GROUP_REF(eFINITE_FUNCTION.self)
      let _TEMP3 = _TEMP2?.PAIRS
      let _TEMP4 = DERIVE_FINITE_FUNCTION_DOMAIN(_TEMP3)
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP4)
    }
    
    let _TEMP5 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("CONSTANT_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP5 ) {
      
      let _TEMP6 = FUNC?.GROUP_REF(eCONSTANT_FUNCTION.self)
      let _TEMP7 = _TEMP6?.SOURCE_OF_DOMAIN
      let _TEMP8 = DOMAIN_FROM(_TEMP7)
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP8)
    }
    
    let _TEMP9 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("SELECTOR_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP9 ) {
      
      let _TEMP10 = FUNC?.GROUP_REF(eSELECTOR_FUNCTION.self)
      let _TEMP11 = _TEMP10?.SOURCE_OF_DOMAIN
      let _TEMP12 = DOMAIN_FROM(_TEMP11)
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP12)
    }
    
    let _TEMP13 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("ELEMENTARY_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP13 ) {
      
      let _TEMP14 = FUNC?.GROUP_REF(eELEMENTARY_FUNCTION.self)
      let _TEMP15 = _TEMP14?.FUNC_ID
      let _TEMP16 = DERIVE_ELEMENTARY_FUNCTION_DOMAIN(_TEMP15)
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP16)
    }
    
    let _TEMP17 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("RESTRICTION_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP17 ) {
      
      let _TEMP18 = FUNC?.GROUP_REF(eRESTRICTION_FUNCTION.self)
      let _TEMP19 = _TEMP18?.OPERAND
      let _TEMP20 = ONE_TUPLES_OF(_TEMP19)
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP20)
    }
    
    let _TEMP21 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("REPACKAGING_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP21 ) {
      
      let _TEMP22 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
      let _TEMP23 = _TEMP22?.INPUT_REPACK
      let _TEMP24 = _TEMP23 .==. SDAI.FORCE_OPTIONAL(RO_NOCHANGE)
      if SDAI.IS_TRUE( _TEMP24 ) {
        
        let _TEMP25 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
        let _TEMP26 = _TEMP25?.OPERAND
        let _TEMP27 = _TEMP26?.DOMAIN
        return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP27)
      }
      
      let _TEMP28 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
      let _TEMP29 = _TEMP28?.INPUT_REPACK
      let _TEMP30 = _TEMP29 .==. SDAI.FORCE_OPTIONAL(RO_WRAP_AS_TUPLE)
      if SDAI.IS_TRUE( _TEMP30 ) {
        
        let _TEMP31 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
        let _TEMP32 = _TEMP31?.OPERAND
        let _TEMP33 = _TEMP32?.DOMAIN
        let _TEMP34 = FACTOR1(_TEMP33)
        return _derive_function_domain__cache.updateCache(params: _params, value: sTUPLE_SPACE(/*eMATHS_SPACE*/
          _TEMP34))
      }
      
      let _TEMP35 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
      let _TEMP36 = _TEMP35?.INPUT_REPACK
      let _TEMP37 = _TEMP36 .==. SDAI.FORCE_OPTIONAL(RO_UNWRAP_TUPLE)
      if SDAI.IS_TRUE( _TEMP37 ) {
        
        let _TEMP38 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
        let _TEMP39 = _TEMP38?.OPERAND
        let _TEMP40 = _TEMP39?.DOMAIN
        let _TEMP41 = ONE_TUPLES_OF(eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP40))
        return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP41)
      }
      return _derive_function_domain__cache.updateCache(params: _params, value: (nil as sTUPLE_SPACE?))
    }
    
    let _TEMP42 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("REINDEXED_ARRAY_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP42 ) {
      
      let _TEMP43 = FUNC?.GROUP_REF(eUNARY_GENERIC_EXPRESSION.self)
      let _TEMP44 = _TEMP43?.OPERAND
      let _TEMP45 = SHAPE_OF_ARRAY(eMATHS_FUNCTION(/*eGENERIC_EXPRESSION*/_TEMP44))
      SHAPE = _TEMP45
      
      let _TEMP46 = FUNC?.GROUP_REF(eREINDEXED_ARRAY_FUNCTION.self)
      let _TEMP47 = _TEMP46?.STARTING_INDICES
      SIDXS = SDAI.LIST<SDAI.INTEGER>(/*SDAI.LIST<SDAI.INTEGER>[1:nil] */_TEMP47)
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        SHAPE)) {
        for I in incrementControl {
          
          let _TEMP48 = SIDXS?[I]
          let _TEMP49 = SIDXS?[I]
          let _TEMP50 = SHAPE?[I]
          let _TEMP51 = _TEMP49 + _TEMP50
          let _TEMP52 = _TEMP51 - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          let _TEMP53 = MAKE_FINITE_INTEGER_INTERVAL(
            MIN: _TEMP48, MAX: _TEMP52)
          ITVL = _TEMP53
          SDAI.INSERT( L: &FACTORS, E: ITVL, P: SDAI.FORCE_OPTIONAL(I) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) )
          
          let _TEMP54 = SHAPE?[I]
          let _TEMP55 = SHAPE?[1]
          let _TEMP56 = _TEMP54 .!=. _TEMP55
          if SDAI.IS_TRUE( _TEMP56 ) {
            IS_UNIFORM = SDAI.BOOLEAN(SDAI.FALSE)
          }
        }
      }
      if SDAI.IS_TRUE( IS_UNIFORM ) {
        
        let _TEMP57 = FACTORS?[1]
        let _TEMP58 = SDAI.SIZEOF(SHAPE)
        let _TEMP59 = MAKE_UNIFORM_PRODUCT_SPACE(
          BASE: eMATHS_SPACE(/*eFINITE_INTEGER_INTERVAL*/_TEMP57), 
          EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/_TEMP58))
        return _derive_function_domain__cache.updateCache(params: _params, value: sTUPLE_SPACE(/*
          eUNIFORM_PRODUCT_SPACE*/_TEMP59))
      }
      
      let _TEMP60 = MAKE_LISTED_PRODUCT_SPACE(SDAI.LIST<eMATHS_SPACE>(/*SDAI.LIST<eFINITE_INTEGER_INTERVAL>*/
        FACTORS))
      return _derive_function_domain__cache.updateCache(params: _params, value: sTUPLE_SPACE(/*
        eLISTED_PRODUCT_SPACE*/_TEMP60))
    }
    
    let _TEMP61 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("SERIES_COMPOSED_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP61 ) {
      
      let _TEMP62 = FUNC?.GROUP_REF(eSERIES_COMPOSED_FUNCTION.self)
      let _TEMP63 = _TEMP62?.OPERANDS
      let _TEMP64 = _TEMP63?[1]
      let _TEMP65 = _TEMP64?.DOMAIN
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP65)
    }
    
    let _TEMP66 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("PARALLEL_COMPOSED_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP66 ) {
      
      let _TEMP67 = FUNC?.GROUP_REF(ePARALLEL_COMPOSED_FUNCTION.self)
      let _TEMP68 = _TEMP67?.SOURCE_OF_DOMAIN
      let _TEMP69 = DOMAIN_FROM(_TEMP68)
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP69)
    }
    
    let _TEMP70 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("EXPLICIT_TABLE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP70 ) {
      
      let _TEMP71 = FUNC?.GROUP_REF(eEXPLICIT_TABLE_FUNCTION.self)
      let _TEMP72 = _TEMP71?.SHAPE
      SHAPE = SDAI.LIST<tPOSITIVE_INTEGER>(/*SDAI.LIST<tPOSITIVE_INTEGER>[1:nil] */_TEMP72)
      
      let _TEMP73 = FUNC?.GROUP_REF(eEXPLICIT_TABLE_FUNCTION.self)
      let _TEMP74 = _TEMP73?.INDEX_BASE
      SIDXS?[1] = SDAI.INTEGER(/*tZERO_OR_ONE*/_TEMP74)
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        SHAPE)) {
        for I in incrementControl {
          
          let _TEMP75 = SIDXS?[1]
          let _TEMP76 = SIDXS?[1]
          let _TEMP77 = SHAPE?[I]
          let _TEMP78 = _TEMP76 + _TEMP77
          let _TEMP79 = _TEMP78 - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          let _TEMP80 = MAKE_FINITE_INTEGER_INTERVAL(
            MIN: _TEMP75, MAX: _TEMP79)
          ITVL = _TEMP80
          SDAI.INSERT( L: &FACTORS, E: ITVL, P: SDAI.FORCE_OPTIONAL(I) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) )
          
          let _TEMP81 = SHAPE?[I]
          let _TEMP82 = SHAPE?[1]
          let _TEMP83 = _TEMP81 .!=. _TEMP82
          if SDAI.IS_TRUE( _TEMP83 ) {
            IS_UNIFORM = SDAI.BOOLEAN(SDAI.FALSE)
          }
        }
      }
      if SDAI.IS_TRUE( IS_UNIFORM ) {
        
        let _TEMP84 = FACTORS?[1]
        let _TEMP85 = SDAI.SIZEOF(SHAPE)
        let _TEMP86 = MAKE_UNIFORM_PRODUCT_SPACE(
          BASE: eMATHS_SPACE(/*eFINITE_INTEGER_INTERVAL*/_TEMP84), 
          EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/_TEMP85))
        return _derive_function_domain__cache.updateCache(params: _params, value: sTUPLE_SPACE(/*
          eUNIFORM_PRODUCT_SPACE*/_TEMP86))
      }
      
      let _TEMP87 = MAKE_LISTED_PRODUCT_SPACE(SDAI.LIST<eMATHS_SPACE>(/*SDAI.LIST<eFINITE_INTEGER_INTERVAL>*/
        FACTORS))
      return _derive_function_domain__cache.updateCache(params: _params, value: sTUPLE_SPACE(/*
        eLISTED_PRODUCT_SPACE*/_TEMP87))
    }
    
    let _TEMP88 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("HOMOGENEOUS_LINEAR_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP88 ) {
      
      let _TEMP89 = FUNC?.GROUP_REF(eHOMOGENEOUS_LINEAR_FUNCTION.self)
      let _TEMP90 = _TEMP89?.MAT
      let _TEMP91 = _TEMP90?.RANGE
      let _TEMP92 = FACTOR1(_TEMP91)
      let _TEMP93 = FUNC?.GROUP_REF(eHOMOGENEOUS_LINEAR_FUNCTION.self)
      let _TEMP94 = _TEMP93?.MAT
      let _TEMP95 = _TEMP94?.GROUP_REF(eEXPLICIT_TABLE_FUNCTION.self)
      let _TEMP96 = _TEMP95?.SHAPE
      let _TEMP97 = FUNC?.GROUP_REF(eHOMOGENEOUS_LINEAR_FUNCTION.self)
      let _TEMP98 = _TEMP97?.SUM_INDEX
      let _TEMP99 = _TEMP96?[_TEMP98]
      let _TEMP100 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: _TEMP92, EXPONENT: _TEMP99)
      let _TEMP101 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP100))
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP101)
    }
    
    let _TEMP102 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("GENERAL_LINEAR_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP102 ) {
      
      let _TEMP103 = FUNC?.GROUP_REF(eGENERAL_LINEAR_FUNCTION.self)
      let _TEMP104 = _TEMP103?.MAT
      let _TEMP105 = _TEMP104?.RANGE
      let _TEMP106 = FACTOR1(_TEMP105)
      let _TEMP107 = FUNC?.GROUP_REF(eGENERAL_LINEAR_FUNCTION.self)
      let _TEMP108 = _TEMP107?.MAT
      let _TEMP109 = _TEMP108?.GROUP_REF(eEXPLICIT_TABLE_FUNCTION.self)
      let _TEMP110 = _TEMP109?.SHAPE
      let _TEMP111 = FUNC?.GROUP_REF(eGENERAL_LINEAR_FUNCTION.self)
      let _TEMP112 = _TEMP111?.SUM_INDEX
      let _TEMP113 = _TEMP110?[_TEMP112]
      let _TEMP114 = _TEMP113 - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      let _TEMP115 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: _TEMP106, EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/_TEMP114))
      let _TEMP116 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP115))
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP116)
    }
    
    let _TEMP117 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("B_SPLINE_BASIS"))
    if SDAI.IS_TRUE( _TEMP117 ) {
      
      let _TEMP118 = FUNC?.GROUP_REF(eB_SPLINE_BASIS.self)
      let _TEMP119 = _TEMP118?.REPEATED_KNOTS
      let _TEMP120 = FUNC?.GROUP_REF(eB_SPLINE_BASIS.self)
      let _TEMP121 = _TEMP120?.ORDER
      let _TEMP122 = _TEMP119?[_TEMP121]
      let _TEMP123 = FUNC?.GROUP_REF(eB_SPLINE_BASIS.self)
      let _TEMP124 = _TEMP123?.REPEATED_KNOTS
      let _TEMP125 = FUNC?.GROUP_REF(eB_SPLINE_BASIS.self)
      let _TEMP126 = _TEMP125?.NUM_BASIS
      let _TEMP127 = _TEMP126 + SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      let _TEMP128 = _TEMP124?[_TEMP127]
      let _TEMP129 = MAKE_FINITE_REAL_INTERVAL(
        MIN: _TEMP122, MINCLO: CLOSED, 
        MAX: _TEMP128, MAXCLO: CLOSED)
      let _TEMP130 = ONE_TUPLES_OF(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/_TEMP129))
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP130)
    }
    
    let _TEMP131 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("B_SPLINE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP131 ) {
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        FUNC?.GROUP_REF(eB_SPLINE_FUNCTION.self)?.BASIS)) {
        for I in incrementControl {
          
          let _TEMP132 = FUNC?.GROUP_REF(eB_SPLINE_FUNCTION.self)
          let _TEMP133 = _TEMP132?.BASIS
          let _TEMP134 = _TEMP133?[I]
          let _TEMP135 = _TEMP134?.DOMAIN
          let _TEMP136 = ASSOC_PRODUCT_SPACE(
            TS1: TSPACE, TS2: _TEMP135)
          TSPACE = _TEMP136
        }
      }
      
      let _TEMP137 = ONE_TUPLES_OF(eMATHS_SPACE(/*sTUPLE_SPACE*/TSPACE))
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP137)
    }
    
    let _TEMP138 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("RATIONALIZE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP138 ) {
      
      let _TEMP139 = FUNC?.GROUP_REF(eRATIONALIZE_FUNCTION.self)
      let _TEMP140 = _TEMP139?.FUN
      let _TEMP141 = _TEMP140?.DOMAIN
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP141)
    }
    
    let _TEMP142 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("PARTIAL_DERIVATIVE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP142 ) {
      
      let _TEMP143 = FUNC?.GROUP_REF(ePARTIAL_DERIVATIVE_FUNCTION.self)
      let _TEMP144 = _TEMP143?.DERIVAND
      let _TEMP145 = _TEMP144?.DOMAIN
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP145)
    }
    
    let _TEMP146 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("DEFINITE_INTEGRAL_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP146 ) {
      
      let _TEMP147 = DERIVE_DEFINITE_INTEGRAL_DOMAIN(eDEFINITE_INTEGRAL_FUNCTION(/*eMATHS_FUNCTION*/FUNC))
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP147)
    }
    
    let _TEMP148 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("ABSTRACTED_EXPRESSION_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP148 ) {
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        FUNC?.GROUP_REF(eABSTRACTED_EXPRESSION_FUNCTION.self)?.VARIABLES)) {
        for I in incrementControl {
          
          let _TEMP149 = FUNC?.GROUP_REF(eABSTRACTED_EXPRESSION_FUNCTION.self)
          let _TEMP150 = _TEMP149?.VARIABLES
          let _TEMP151 = _TEMP150?[I]
          let _TEMP152 = VALUES_SPACE_OF(eGENERIC_EXPRESSION(/*eGENERIC_VARIABLE*/_TEMP151))
          let _TEMP153 = ONE_TUPLES_OF(_TEMP152)
          let _TEMP154 = ASSOC_PRODUCT_SPACE(
            TS1: TSPACE, TS2: _TEMP153)
          TSPACE = _TEMP154
        }
      }
      return _derive_function_domain__cache.updateCache(params: _params, value: TSPACE)
    }
    
    let _TEMP155 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("EXPRESSION_DENOTED_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP155 ) {
      
      let _TEMP156 = FUNC?.GROUP_REF(eEXPRESSION_DENOTED_FUNCTION.self)
      let _TEMP157 = _TEMP156?.EXPR
      let _TEMP158 = VALUES_SPACE_OF(_TEMP157)
      let _TEMP159 = _TEMP158?.GROUP_REF(eFUNCTION_SPACE.self)
      let _TEMP160 = _TEMP159?.DOMAIN_ARGUMENT
      return _derive_function_domain__cache.updateCache(params: _params, value: sTUPLE_SPACE(/*eMATHS_SPACE*/
        _TEMP160))
    }
    
    let _TEMP161 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("IMPORTED_POINT_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP161 ) {
      
      let _TEMP162 = SDAI.LIST<eMATHS_SPACE>(SDAI.EMPLY_AGGREGATE)
      let _TEMP163 = MAKE_LISTED_PRODUCT_SPACE(_TEMP162)
      let _TEMP164 = ONE_TUPLES_OF(eMATHS_SPACE(/*eLISTED_PRODUCT_SPACE*/_TEMP163))
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP164)
    }
    
    let _TEMP165 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("IMPORTED_CURVE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP165 ) {
      
      let _TEMP166 = FUNC?.GROUP_REF(eIMPORTED_CURVE_FUNCTION.self)
      let _TEMP167 = _TEMP166?.PARAMETRIC_DOMAIN
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP167)
    }
    
    let _TEMP168 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("IMPORTED_SURFACE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP168 ) {
      
      let _TEMP169 = FUNC?.GROUP_REF(eIMPORTED_SURFACE_FUNCTION.self)
      let _TEMP170 = _TEMP169?.PARAMETRIC_DOMAIN
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP170)
    }
    
    let _TEMP171 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("IMPORTED_VOLUME_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP171 ) {
      
      let _TEMP172 = FUNC?.GROUP_REF(eIMPORTED_VOLUME_FUNCTION.self)
      let _TEMP173 = _TEMP172?.PARAMETRIC_DOMAIN
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP173)
    }
    
    let _TEMP174 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("APPLICATION_DEFINED_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP174 ) {
      
      let _TEMP175 = FUNC?.GROUP_REF(eAPPLICATION_DEFINED_FUNCTION.self)
      let _TEMP176 = _TEMP175?.EXPLICIT_DOMAIN
      return _derive_function_domain__cache.updateCache(params: _params, value: _TEMP176)
    }
    return _derive_function_domain__cache.updateCache(params: _params, value: (nil as sTUPLE_SPACE?))
  }

}

//MARK: - function result cache
private var _derive_function_domain__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

