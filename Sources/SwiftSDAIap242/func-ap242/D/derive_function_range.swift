/* file: derive_function_range.swift 	 generated: Tue Nov 16 05:35:44 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION derive_function_range(
               func : maths_function
           ) : tuple_space;

    LOCAL
      typenames : SET OF STRING := stripped_typeof( func );
      tspace    : tuple_space := make_listed_product_space( [] );
      m         : nonnegative_integer := 0;
      n         : nonnegative_integer := 0;
      temp      : INTEGER := 0;
    END_LOCAL;
    IF 'FINITE_FUNCTION' IN typenames THEN
      RETURN( derive_finite_function_range( func\finite_function.pairs ) );
    END_IF;
    IF 'CONSTANT_FUNCTION' IN typenames THEN
      RETURN( one_tuples_of( make_finite_space( [func\constant_function.sole_output] ) ) );
    END_IF;
    IF 'SELECTOR_FUNCTION' IN typenames THEN
      tspace := func.domain;
      IF ( space_dimension( tspace ) = 1 ) AND ( ( schema_prefix + 'TUPLE_SPACE' ) IN TYPEOF( tspace ) )
          THEN
        tspace := factor1( tspace );
      END_IF;
      RETURN( one_tuples_of( factor_space( tspace, func\selector_function.selector ) ) );
    END_IF;
    IF 'ELEMENTARY_FUNCTION' IN typenames THEN
      RETURN( derive_elementary_function_range( func\elementary_function.func_id ) );
    END_IF;
    IF 'RESTRICTION_FUNCTION' IN typenames THEN
      RETURN( one_tuples_of( func\restriction_function.operand ) );
    END_IF;
    IF 'REPACKAGING_FUNCTION' IN typenames THEN
      tspace := func\repackaging_function.operand.range;
      IF func\repackaging_function.output_repack = ro_wrap_as_tuple THEN
        tspace := one_tuples_of( tspace );
      END_IF;
      IF func\repackaging_function.output_repack = ro_unwrap_tuple THEN
        tspace := factor1( tspace );
      END_IF;
      IF func\repackaging_function.selected_output > 0 THEN
        tspace := one_tuples_of( factor_space( tspace, func\repackaging_function.selected_output ) );
      END_IF;
      RETURN( tspace );
    END_IF;
    IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
      RETURN( func\unary_generic_expression.operand\maths_function.range );
    END_IF;
    IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
      RETURN( func\series_composed_function.operands[SIZEOF( func\series_composed_function.operands )].range );
    END_IF;
    IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
      RETURN( func\parallel_composed_function.final_function.range );
    END_IF;
    IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
      IF 'LISTED_REAL_DATA' IN typenames THEN
        RETURN( one_tuples_of( the_reals ) );
      END_IF;
      IF 'LISTED_INTEGER_DATA' IN typenames THEN
        RETURN( one_tuples_of( the_integers ) );
      END_IF;
      IF 'LISTED_LOGICAL_DATA' IN typenames THEN
        RETURN( one_tuples_of( the_logicals ) );
      END_IF;
      IF 'LISTED_STRING_DATA' IN typenames THEN
        RETURN( one_tuples_of( the_strings ) );
      END_IF;
      IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames THEN
        RETURN( one_tuples_of( the_complex_numbers ) );
      END_IF;
      IF 'LISTED_DATA' IN typenames THEN
        RETURN( one_tuples_of( func\listed_data.value_range ) );
      END_IF;
      IF 'EXTERNALLY_LISTED_DATA' IN typenames THEN
        RETURN( one_tuples_of( func\externally_listed_data.value_range ) );
      END_IF;
      IF 'LINEARIZED_TABLE_FUNCTION' IN typenames THEN
        RETURN( func\linearized_table_function.source.range );
      END_IF;
      IF 'BASIC_SPARSE_MATRIX' IN typenames THEN
        RETURN( func\basic_sparse_matrix.val.range );
      END_IF;
      RETURN( ? );
    END_IF;
    IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
      RETURN( one_tuples_of( make_uniform_product_space( factor1( func\homogeneous_linear_function.mat.range ), 
          func\homogeneous_linear_function.mat\explicit_table_function.shape[3 - func\
          homogeneous_linear_function.sum_index] ) ) );
    END_IF;
    IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
      RETURN( one_tuples_of( make_uniform_product_space( factor1( func\general_linear_function.mat.range ), 
          func\general_linear_function.mat\explicit_table_function.shape[3 - func\general_linear_function.
          sum_index] ) ) );
    END_IF;
    IF 'B_SPLINE_BASIS' IN typenames THEN
      RETURN( one_tuples_of( make_uniform_product_space( the_reals, func\b_spline_basis.num_basis ) ) );
    END_IF;
    IF 'B_SPLINE_FUNCTION' IN typenames THEN
      tspace := factor1( func\b_spline_function.coef.domain );
      m := SIZEOF( func\b_spline_function.basis );
      n := space_dimension( tspace );
      IF m = n THEN
        RETURN( one_tuples_of( the_reals ) );
      END_IF;
      IF m = ( n - 1 ) THEN
        RETURN( one_tuples_of( make_uniform_product_space( the_reals, factor_space( tspace, n )\
            finite_integer_interval.size ) ) );
      END_IF;
      tspace := extract_factors( tspace, m + 1, n );
      RETURN( one_tuples_of( make_function_space( sc_equal, tspace, sc_subspace, number_superspace_of( func\
          b_spline_function.coef.range ) ) ) );
    END_IF;
    IF 'RATIONALIZE_FUNCTION' IN typenames THEN
      tspace := factor1( func\rationalize_function.fun.range );
      n := space_dimension( tspace );
      RETURN( one_tuples_of( make_uniform_product_space( number_superspace_of( factor1( tspace ) ), n - 1 ) ) );
    END_IF;
    IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
      RETURN( drop_numeric_constraints( func\partial_derivative_function.derivand.range ) );
    END_IF;
    IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
      RETURN( drop_numeric_constraints( func\definite_integral_function.integrand.range ) );
    END_IF;
    IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
      RETURN( one_tuples_of( values_space_of( func\abstracted_expression_function.expr ) ) );
    END_IF;
    IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
      RETURN( values_space_of( func\expression_denoted_function.expr )\function_space.range_argument );
    END_IF;
    IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
      temp := dimension_of( func\imported_point_function.geometry );
      RETURN( one_tuples_of( make_uniform_product_space( the_reals, temp ) ) );
    END_IF;
    IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
      temp := dimension_of( func\imported_curve_function.geometry );
      RETURN( one_tuples_of( make_uniform_product_space( the_reals, temp ) ) );
    END_IF;
    IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
      temp := dimension_of( func\imported_surface_function.geometry );
      RETURN( one_tuples_of( make_uniform_product_space( the_reals, temp ) ) );
    END_IF;
    IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
      temp := dimension_of( func\imported_volume_function.geometry );
      RETURN( one_tuples_of( make_uniform_product_space( the_reals, temp ) ) );
    END_IF;
    IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
      RETURN( func\application_defined_function.explicit_range );
    END_IF;
    RETURN( ? );

  END_FUNCTION; -- derive_function_range (line:38279 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func DERIVE_FUNCTION_RANGE(_ FUNC: eMATHS_FUNCTION? ) 
    -> sTUPLE_SPACE? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( FUNC )
    if case .available(let _cached_value) = _derive_function_range__cache.cachedValue(params: _params) {
      return _cached_value as? sTUPLE_SPACE
    }

    var FUNC = FUNC; SDAI.TOUCH(var: &FUNC)

    //LOCAL
    var TYPENAMES: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(FUNC); SDAI.TOUCH(var: &TYPENAMES)
    var TSPACE: sTUPLE_SPACE?  = sTUPLE_SPACE(/*eLISTED_PRODUCT_SPACE*/MAKE_LISTED_PRODUCT_SPACE(
                                 SDAI.LIST<eMATHS_SPACE>(SDAI.EMPLY_AGGREGATE))); SDAI.TOUCH(var: &TSPACE)
    var M: tNONNEGATIVE_INTEGER?  = tNONNEGATIVE_INTEGER(0); SDAI.TOUCH(var: &M)
    var N: tNONNEGATIVE_INTEGER?  = tNONNEGATIVE_INTEGER(0); SDAI.TOUCH(var: &N)
    var TEMP: SDAI.INTEGER?  = SDAI.INTEGER(0); SDAI.TOUCH(var: &TEMP)
    //END_LOCAL

    
    let _TEMP1 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("FINITE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP1 ) {
      
      let _TEMP2 = FUNC?.GROUP_REF(eFINITE_FUNCTION.self)
      let _TEMP3 = _TEMP2?.PAIRS
      let _TEMP4 = DERIVE_FINITE_FUNCTION_RANGE(_TEMP3)
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP4)
    }
    
    let _TEMP5 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("CONSTANT_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP5 ) {
      
      let _TEMP6 = FUNC?.GROUP_REF(eCONSTANT_FUNCTION.self)
      let _TEMP7 = _TEMP6?.SOLE_OUTPUT
      let _TEMP8 = SDAI.SET<sMATHS_VALUE>(([
        SDAI.AIE(_TEMP7)] as [SDAI.AggregationInitializerElement<sMATHS_VALUE>]))
      let _TEMP9 = MAKE_FINITE_SPACE(_TEMP8)
      let _TEMP10 = ONE_TUPLES_OF(eMATHS_SPACE(/*eFINITE_SPACE*/_TEMP9))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP10)
    }
    
    let _TEMP11 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("SELECTOR_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP11 ) {
      
      let _TEMP12 = FUNC?.DOMAIN
      TSPACE = _TEMP12
      
      let _TEMP13 = SPACE_DIMENSION(TSPACE)
      let _TEMP14 = _TEMP13 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      let _TEMP15 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("TUPLE_SPACE"))
      let _TEMP16 = SDAI.TYPEOF(TSPACE)
      let _TEMP17 = SDAI.aggregate(_TEMP16, contains: SDAI.STRING(/*SDAI.INTEGER*/_TEMP15))
      let _TEMP18 = _TEMP14 && _TEMP17
      if SDAI.IS_TRUE( _TEMP18 ) {
        
        let _TEMP19 = FACTOR1(TSPACE)
        TSPACE = sTUPLE_SPACE(/*eMATHS_SPACE*/_TEMP19)
      }
      
      let _TEMP20 = FUNC?.GROUP_REF(eSELECTOR_FUNCTION.self)
      let _TEMP21 = _TEMP20?.SELECTOR
      let _TEMP22 = FACTOR_SPACE(TSPACE: TSPACE, 
                                 IDX: tPOSITIVE_INTEGER(/*tINPUT_SELECTOR*/_TEMP21))
      let _TEMP23 = ONE_TUPLES_OF(_TEMP22)
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP23)
    }
    
    let _TEMP24 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("ELEMENTARY_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP24 ) {
      
      let _TEMP25 = FUNC?.GROUP_REF(eELEMENTARY_FUNCTION.self)
      let _TEMP26 = _TEMP25?.FUNC_ID
      let _TEMP27 = DERIVE_ELEMENTARY_FUNCTION_RANGE(_TEMP26)
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP27)
    }
    
    let _TEMP28 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("RESTRICTION_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP28 ) {
      
      let _TEMP29 = FUNC?.GROUP_REF(eRESTRICTION_FUNCTION.self)
      let _TEMP30 = _TEMP29?.OPERAND
      let _TEMP31 = ONE_TUPLES_OF(_TEMP30)
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP31)
    }
    
    let _TEMP32 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("REPACKAGING_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP32 ) {
      
      let _TEMP33 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
      let _TEMP34 = _TEMP33?.OPERAND
      let _TEMP35 = _TEMP34?.RANGE
      TSPACE = _TEMP35
      
      let _TEMP36 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
      let _TEMP37 = _TEMP36?.OUTPUT_REPACK
      let _TEMP38 = _TEMP37 .==. SDAI.FORCE_OPTIONAL(RO_WRAP_AS_TUPLE)
      if SDAI.IS_TRUE( _TEMP38 ) {
        
        let _TEMP39 = ONE_TUPLES_OF(eMATHS_SPACE(/*sTUPLE_SPACE*/TSPACE))
        TSPACE = _TEMP39
      }
      
      let _TEMP40 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
      let _TEMP41 = _TEMP40?.OUTPUT_REPACK
      let _TEMP42 = _TEMP41 .==. SDAI.FORCE_OPTIONAL(RO_UNWRAP_TUPLE)
      if SDAI.IS_TRUE( _TEMP42 ) {
        
        let _TEMP43 = FACTOR1(TSPACE)
        TSPACE = sTUPLE_SPACE(/*eMATHS_SPACE*/_TEMP43)
      }
      
      let _TEMP44 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
      let _TEMP45 = _TEMP44?.SELECTED_OUTPUT
      let _TEMP46 = _TEMP45 > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP46 ) {
        
        let _TEMP47 = FUNC?.GROUP_REF(eREPACKAGING_FUNCTION.self)
        let _TEMP48 = _TEMP47?.SELECTED_OUTPUT
        let _TEMP49 = FACTOR_SPACE(TSPACE: TSPACE, 
                                   IDX: tPOSITIVE_INTEGER(/*tNONNEGATIVE_INTEGER*/_TEMP48))
        let _TEMP50 = ONE_TUPLES_OF(_TEMP49)
        TSPACE = _TEMP50
      }
      return _derive_function_range__cache.updateCache(params: _params, value: TSPACE)
    }
    
    let _TEMP51 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("REINDEXED_ARRAY_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP51 ) {
      
      let _TEMP52 = FUNC?.GROUP_REF(eUNARY_GENERIC_EXPRESSION.self)
      let _TEMP53 = _TEMP52?.OPERAND
      let _TEMP54 = _TEMP53?.GROUP_REF(eMATHS_FUNCTION.self)
      let _TEMP55 = _TEMP54?.RANGE
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP55)
    }
    
    let _TEMP56 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("SERIES_COMPOSED_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP56 ) {
      
      let _TEMP57 = FUNC?.GROUP_REF(eSERIES_COMPOSED_FUNCTION.self)
      let _TEMP58 = _TEMP57?.OPERANDS
      let _TEMP59 = FUNC?.GROUP_REF(eSERIES_COMPOSED_FUNCTION.self)
      let _TEMP60 = _TEMP59?.OPERANDS
      let _TEMP61 = SDAI.SIZEOF(_TEMP60)
      let _TEMP62 = _TEMP58?[_TEMP61]
      let _TEMP63 = _TEMP62?.RANGE
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP63)
    }
    
    let _TEMP64 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("PARALLEL_COMPOSED_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP64 ) {
      
      let _TEMP65 = FUNC?.GROUP_REF(ePARALLEL_COMPOSED_FUNCTION.self)
      let _TEMP66 = _TEMP65?.FINAL_FUNCTION
      let _TEMP67 = _TEMP66?.RANGE
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP67)
    }
    
    let _TEMP68 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("EXPLICIT_TABLE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP68 ) {
      
      let _TEMP69 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("LISTED_REAL_DATA"))
      if SDAI.IS_TRUE( _TEMP69 ) {
        
        let _TEMP70 = ONE_TUPLES_OF(eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_REALS))
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP70)
      }
      
      let _TEMP71 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("LISTED_INTEGER_DATA"))
      if SDAI.IS_TRUE( _TEMP71 ) {
        
        let _TEMP72 = ONE_TUPLES_OF(eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_INTEGERS))
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP72)
      }
      
      let _TEMP73 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("LISTED_LOGICAL_DATA"))
      if SDAI.IS_TRUE( _TEMP73 ) {
        
        let _TEMP74 = ONE_TUPLES_OF(eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_LOGICALS))
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP74)
      }
      
      let _TEMP75 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("LISTED_STRING_DATA"))
      if SDAI.IS_TRUE( _TEMP75 ) {
        
        let _TEMP76 = ONE_TUPLES_OF(eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_STRINGS))
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP76)
      }
      
      let _TEMP77 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("LISTED_COMPLEX_NUMBER_DATA"))
      if SDAI.IS_TRUE( _TEMP77 ) {
        
        let _TEMP78 = ONE_TUPLES_OF(eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_COMPLEX_NUMBERS))
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP78)
      }
      
      let _TEMP79 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("LISTED_DATA"))
      if SDAI.IS_TRUE( _TEMP79 ) {
        
        let _TEMP80 = FUNC?.GROUP_REF(eLISTED_DATA.self)
        let _TEMP81 = _TEMP80?.VALUE_RANGE
        let _TEMP82 = ONE_TUPLES_OF(_TEMP81)
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP82)
      }
      
      let _TEMP83 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("EXTERNALLY_LISTED_DATA"))
      if SDAI.IS_TRUE( _TEMP83 ) {
        
        let _TEMP84 = FUNC?.GROUP_REF(eEXTERNALLY_LISTED_DATA.self)
        let _TEMP85 = _TEMP84?.VALUE_RANGE
        let _TEMP86 = ONE_TUPLES_OF(_TEMP85)
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP86)
      }
      
      let _TEMP87 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("LINEARIZED_TABLE_FUNCTION"))
      if SDAI.IS_TRUE( _TEMP87 ) {
        
        let _TEMP88 = FUNC?.GROUP_REF(eLINEARIZED_TABLE_FUNCTION.self)
        let _TEMP89 = _TEMP88?.SOURCE
        let _TEMP90 = _TEMP89?.RANGE
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP90)
      }
      
      let _TEMP91 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("BASIC_SPARSE_MATRIX"))
      if SDAI.IS_TRUE( _TEMP91 ) {
        
        let _TEMP92 = FUNC?.GROUP_REF(eBASIC_SPARSE_MATRIX.self)
        let _TEMP93 = _TEMP92?.VAL
        let _TEMP94 = _TEMP93?.RANGE
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP94)
      }
      return _derive_function_range__cache.updateCache(params: _params, value: (nil as sTUPLE_SPACE?))
    }
    
    let _TEMP95 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("HOMOGENEOUS_LINEAR_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP95 ) {
      
      let _TEMP96 = FUNC?.GROUP_REF(eHOMOGENEOUS_LINEAR_FUNCTION.self)
      let _TEMP97 = _TEMP96?.MAT
      let _TEMP98 = _TEMP97?.RANGE
      let _TEMP99 = FACTOR1(_TEMP98)
      let _TEMP100 = FUNC?.GROUP_REF(eHOMOGENEOUS_LINEAR_FUNCTION.self)
      let _TEMP101 = _TEMP100?.MAT
      let _TEMP102 = _TEMP101?.GROUP_REF(eEXPLICIT_TABLE_FUNCTION.self)
      let _TEMP103 = _TEMP102?.SHAPE
      let _TEMP104 = FUNC?.GROUP_REF(eHOMOGENEOUS_LINEAR_FUNCTION.self)
      let _TEMP105 = _TEMP104?.SUM_INDEX
      let _TEMP106 = SDAI.FORCE_OPTIONAL(SDAI.INTEGER(3)) - _TEMP105
      let _TEMP107 = _TEMP103?[_TEMP106]
      let _TEMP108 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: _TEMP99, EXPONENT: _TEMP107)
      let _TEMP109 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP108))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP109)
    }
    
    let _TEMP110 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("GENERAL_LINEAR_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP110 ) {
      
      let _TEMP111 = FUNC?.GROUP_REF(eGENERAL_LINEAR_FUNCTION.self)
      let _TEMP112 = _TEMP111?.MAT
      let _TEMP113 = _TEMP112?.RANGE
      let _TEMP114 = FACTOR1(_TEMP113)
      let _TEMP115 = FUNC?.GROUP_REF(eGENERAL_LINEAR_FUNCTION.self)
      let _TEMP116 = _TEMP115?.MAT
      let _TEMP117 = _TEMP116?.GROUP_REF(eEXPLICIT_TABLE_FUNCTION.self)
      let _TEMP118 = _TEMP117?.SHAPE
      let _TEMP119 = FUNC?.GROUP_REF(eGENERAL_LINEAR_FUNCTION.self)
      let _TEMP120 = _TEMP119?.SUM_INDEX
      let _TEMP121 = SDAI.FORCE_OPTIONAL(SDAI.INTEGER(3)) - _TEMP120
      let _TEMP122 = _TEMP118?[_TEMP121]
      let _TEMP123 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: _TEMP114, EXPONENT: _TEMP122)
      let _TEMP124 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP123))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP124)
    }
    
    let _TEMP125 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("B_SPLINE_BASIS"))
    if SDAI.IS_TRUE( _TEMP125 ) {
      
      let _TEMP126 = FUNC?.GROUP_REF(eB_SPLINE_BASIS.self)
      let _TEMP127 = _TEMP126?.NUM_BASIS
      let _TEMP128 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_REALS), 
        EXPONENT: _TEMP127)
      let _TEMP129 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP128))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP129)
    }
    
    let _TEMP130 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("B_SPLINE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP130 ) {
      
      let _TEMP131 = FUNC?.GROUP_REF(eB_SPLINE_FUNCTION.self)
      let _TEMP132 = _TEMP131?.COEF
      let _TEMP133 = _TEMP132?.DOMAIN
      let _TEMP134 = FACTOR1(_TEMP133)
      TSPACE = sTUPLE_SPACE(/*eMATHS_SPACE*/_TEMP134)
      
      let _TEMP135 = FUNC?.GROUP_REF(eB_SPLINE_FUNCTION.self)
      let _TEMP136 = _TEMP135?.BASIS
      let _TEMP137 = SDAI.SIZEOF(_TEMP136)
      M = tNONNEGATIVE_INTEGER(/*SDAI.INTEGER*/_TEMP137)
      
      let _TEMP138 = SPACE_DIMENSION(TSPACE)
      N = _TEMP138
      
      let _TEMP139 = M .==. N
      if SDAI.IS_TRUE( _TEMP139 ) {
        
        let _TEMP140 = ONE_TUPLES_OF(eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_REALS))
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP140)
      }
      
      let _TEMP141 = N - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      let _TEMP142 = M .==. _TEMP141
      if SDAI.IS_TRUE( _TEMP142 ) {
        
        let _TEMP143 = FACTOR_SPACE(
          TSPACE: TSPACE, IDX: tPOSITIVE_INTEGER(/*tNONNEGATIVE_INTEGER*/N))
        let _TEMP144 = _TEMP143?.GROUP_REF(eFINITE_INTEGER_INTERVAL.self)
        let _TEMP145 = _TEMP144?.SIZE
        let _TEMP146 = MAKE_UNIFORM_PRODUCT_SPACE(
          BASE: eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_REALS), 
          EXPONENT: _TEMP145)
        let _TEMP147 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP146))
        return _derive_function_range__cache.updateCache(params: _params, value: _TEMP147)
      }
      
      let _TEMP148 = M + SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      let _TEMP149 = EXTRACT_FACTORS(
        TSPACE: TSPACE, M: _TEMP148, 
        N: SDAI.INTEGER(/*tNONNEGATIVE_INTEGER*/N))
      TSPACE = _TEMP149
      
      let _TEMP150 = FUNC?.GROUP_REF(eB_SPLINE_FUNCTION.self)
      let _TEMP151 = _TEMP150?.COEF
      let _TEMP152 = _TEMP151?.RANGE
      let _TEMP153 = NUMBER_SUPERSPACE_OF(eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP152))
      let _TEMP154 = MAKE_FUNCTION_SPACE(
        DOMAIN_CONSTRAINT: SC_EQUAL, 
        DOMAIN_ARGUMENT: eMATHS_SPACE(/*sTUPLE_SPACE*/TSPACE), 
        RANGE_CONSTRAINT: SC_SUBSPACE, 
        RANGE_ARGUMENT: eMATHS_SPACE(/*eELEMENTARY_SPACE*/_TEMP153))
      let _TEMP155 = ONE_TUPLES_OF(eMATHS_SPACE(/*eFUNCTION_SPACE*/_TEMP154))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP155)
    }
    
    let _TEMP156 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("RATIONALIZE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP156 ) {
      
      let _TEMP157 = FUNC?.GROUP_REF(eRATIONALIZE_FUNCTION.self)
      let _TEMP158 = _TEMP157?.FUN
      let _TEMP159 = _TEMP158?.RANGE
      let _TEMP160 = FACTOR1(_TEMP159)
      TSPACE = sTUPLE_SPACE(/*eMATHS_SPACE*/_TEMP160)
      
      let _TEMP161 = SPACE_DIMENSION(TSPACE)
      N = _TEMP161
      
      let _TEMP162 = FACTOR1(TSPACE)
      let _TEMP163 = NUMBER_SUPERSPACE_OF(_TEMP162)
      let _TEMP164 = N - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      let _TEMP165 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: eMATHS_SPACE(/*eELEMENTARY_SPACE*/_TEMP163), 
        EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/_TEMP164))
      let _TEMP166 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP165))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP166)
    }
    
    let _TEMP167 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("PARTIAL_DERIVATIVE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP167 ) {
      
      let _TEMP168 = FUNC?.GROUP_REF(ePARTIAL_DERIVATIVE_FUNCTION.self)
      let _TEMP169 = _TEMP168?.DERIVAND
      let _TEMP170 = _TEMP169?.RANGE
      let _TEMP171 = DROP_NUMERIC_CONSTRAINTS(eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP170))
      return _derive_function_range__cache.updateCache(params: _params, value: sTUPLE_SPACE(/*eMATHS_SPACE*/
        _TEMP171))
    }
    
    let _TEMP172 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("DEFINITE_INTEGRAL_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP172 ) {
      
      let _TEMP173 = FUNC?.GROUP_REF(eDEFINITE_INTEGRAL_FUNCTION.self)
      let _TEMP174 = _TEMP173?.INTEGRAND
      let _TEMP175 = _TEMP174?.RANGE
      let _TEMP176 = DROP_NUMERIC_CONSTRAINTS(eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP175))
      return _derive_function_range__cache.updateCache(params: _params, value: sTUPLE_SPACE(/*eMATHS_SPACE*/
        _TEMP176))
    }
    
    let _TEMP177 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("ABSTRACTED_EXPRESSION_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP177 ) {
      
      let _TEMP178 = FUNC?.GROUP_REF(eABSTRACTED_EXPRESSION_FUNCTION.self)
      let _TEMP179 = _TEMP178?.EXPR
      let _TEMP180 = VALUES_SPACE_OF(_TEMP179)
      let _TEMP181 = ONE_TUPLES_OF(_TEMP180)
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP181)
    }
    
    let _TEMP182 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("EXPRESSION_DENOTED_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP182 ) {
      
      let _TEMP183 = FUNC?.GROUP_REF(eEXPRESSION_DENOTED_FUNCTION.self)
      let _TEMP184 = _TEMP183?.EXPR
      let _TEMP185 = VALUES_SPACE_OF(_TEMP184)
      let _TEMP186 = _TEMP185?.GROUP_REF(eFUNCTION_SPACE.self)
      let _TEMP187 = _TEMP186?.RANGE_ARGUMENT
      return _derive_function_range__cache.updateCache(params: _params, value: sTUPLE_SPACE(/*eMATHS_SPACE*/
        _TEMP187))
    }
    
    let _TEMP188 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("IMPORTED_POINT_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP188 ) {
      
      let _TEMP189 = FUNC?.GROUP_REF(eIMPORTED_POINT_FUNCTION.self)
      let _TEMP190 = _TEMP189?.GEOMETRY
      let _TEMP191 = DIMENSION_OF(eGEOMETRIC_REPRESENTATION_ITEM(/*ePOINT*/_TEMP190))
      TEMP = SDAI.INTEGER(/*tDIMENSION_COUNT*/_TEMP191)
      
      let _TEMP192 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_REALS), 
        EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/TEMP))
      let _TEMP193 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP192))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP193)
    }
    
    let _TEMP194 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("IMPORTED_CURVE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP194 ) {
      
      let _TEMP195 = FUNC?.GROUP_REF(eIMPORTED_CURVE_FUNCTION.self)
      let _TEMP196 = _TEMP195?.GEOMETRY
      let _TEMP197 = DIMENSION_OF(eGEOMETRIC_REPRESENTATION_ITEM(/*eCURVE*/_TEMP196))
      TEMP = SDAI.INTEGER(/*tDIMENSION_COUNT*/_TEMP197)
      
      let _TEMP198 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_REALS), 
        EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/TEMP))
      let _TEMP199 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP198))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP199)
    }
    
    let _TEMP200 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("IMPORTED_SURFACE_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP200 ) {
      
      let _TEMP201 = FUNC?.GROUP_REF(eIMPORTED_SURFACE_FUNCTION.self)
      let _TEMP202 = _TEMP201?.GEOMETRY
      let _TEMP203 = DIMENSION_OF(eGEOMETRIC_REPRESENTATION_ITEM(/*eSURFACE*/_TEMP202))
      TEMP = SDAI.INTEGER(/*tDIMENSION_COUNT*/_TEMP203)
      
      let _TEMP204 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_REALS), 
        EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/TEMP))
      let _TEMP205 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP204))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP205)
    }
    
    let _TEMP206 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("IMPORTED_VOLUME_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP206 ) {
      
      let _TEMP207 = FUNC?.GROUP_REF(eIMPORTED_VOLUME_FUNCTION.self)
      let _TEMP208 = _TEMP207?.GEOMETRY
      let _TEMP209 = DIMENSION_OF(eGEOMETRIC_REPRESENTATION_ITEM(/*eVOLUME*/_TEMP208))
      TEMP = SDAI.INTEGER(/*tDIMENSION_COUNT*/_TEMP209)
      
      let _TEMP210 = MAKE_UNIFORM_PRODUCT_SPACE(
        BASE: eMATHS_SPACE(/*eELEMENTARY_SPACE*/THE_REALS), 
        EXPONENT: tPOSITIVE_INTEGER(/*SDAI.INTEGER*/TEMP))
      let _TEMP211 = ONE_TUPLES_OF(eMATHS_SPACE(/*eUNIFORM_PRODUCT_SPACE*/_TEMP210))
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP211)
    }
    
    let _TEMP212 = SDAI.aggregate(TYPENAMES, contains: SDAI.STRING("APPLICATION_DEFINED_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP212 ) {
      
      let _TEMP213 = FUNC?.GROUP_REF(eAPPLICATION_DEFINED_FUNCTION.self)
      let _TEMP214 = _TEMP213?.EXPLICIT_RANGE
      return _derive_function_range__cache.updateCache(params: _params, value: _TEMP214)
    }
    return _derive_function_range__cache.updateCache(params: _params, value: (nil as sTUPLE_SPACE?))
  }

}

//MARK: - function result cache
private var _derive_function_range__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

