/* file: equal_maths_values.swift 	 generated: Sat Aug 14 13:46:02 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION equal_maths_values(
               val1, val2 : maths_value
           ) : LOGICAL;

    FUNCTION mem_of_vs(
                 val1, val2 : maths_value
             ) : LOGICAL;
      IF NOT has_values_space( val2 ) THEN
        RETURN( UNKNOWN );
      END_IF;
      IF NOT member_of( val1, values_space_of( val2 ) ) THEN
        RETURN( FALSE );
      END_IF;
      RETURN( UNKNOWN );

    END_FUNCTION; -- mem_of_vs (line:40397 file:ap242ed2_mim_lf_v1.101.TY.exp)

    LOCAL
      types1 : SET OF STRING;
      types2 : SET OF STRING;
      list1  : LIST OF maths_value;
      list2  : LIST OF maths_value;
      cum    : LOGICAL := TRUE;
    END_LOCAL;
    IF ( NOT EXISTS( val1 ) ) OR ( NOT EXISTS( val2 ) ) THEN
      RETURN( FALSE );
    END_IF;
    IF val1 = val2 THEN
      RETURN( TRUE );
    END_IF;
    types1 := stripped_typeof( val1 );
    types2 := stripped_typeof( val2 );
    IF ( 'MATHS_ATOM' IN types1 ) OR ( 'COMPLEX_NUMBER_LITERAL' IN types1 ) THEN
      IF 'MATHS_ATOM' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      IF 'COMPLEX_NUMBER_LITERAL' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      IF 'LIST' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      IF 'MATHS_SPACE' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      IF 'MATHS_FUNCTION' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      IF 'GENERIC_EXPRESSION' IN types2 THEN
        RETURN( mem_of_vs( val1, val2 ) );
      END_IF;
      RETURN( UNKNOWN );
    END_IF;
    IF ( 'MATHS_ATOM' IN types2 ) OR ( 'COMPLEX_NUMBER_LITERAL' IN types2 ) THEN
      RETURN( equal_maths_values( val2, val1 ) );
    END_IF;
    IF 'LIST' IN types1 THEN
      IF 'LIST' IN types2 THEN
        list1 := val1;
        list2 := val2;
        IF SIZEOF( list1 ) <> SIZEOF( list2 ) THEN
          RETURN( FALSE );
        END_IF;
        REPEAT i := 1 TO SIZEOF( list1 ) BY 1;
          cum := cum AND equal_maths_values( list1[i], list2[i] );
          IF cum = FALSE THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        RETURN( cum );
      END_IF;
      IF 'MATHS_SPACE' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      IF 'MATHS_FUNCTION' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      IF 'GENERIC_EXPRESSION' IN types2 THEN
        RETURN( mem_of_vs( val1, val2 ) );
      END_IF;
      RETURN( UNKNOWN );
    END_IF;
    IF 'LIST' IN types2 THEN
      RETURN( equal_maths_values( val2, val1 ) );
    END_IF;
    IF 'MATHS_SPACE' IN types1 THEN
      IF 'MATHS_SPACE' IN types2 THEN
        RETURN( equal_maths_spaces( val1, val2 ) );
      END_IF;
      IF 'MATHS_FUNCTION' IN types2 THEN
        RETURN( FALSE );
      END_IF;
      IF 'GENERIC_EXPRESSION' IN types2 THEN
        RETURN( mem_of_vs( val1, val2 ) );
      END_IF;
      RETURN( UNKNOWN );
    END_IF;
    IF 'MATHS_SPACE' IN types2 THEN
      RETURN( equal_maths_values( val2, val1 ) );
    END_IF;
    IF 'MATHS_FUNCTION' IN types1 THEN
      IF 'MATHS_FUNCTION' IN types2 THEN
        RETURN( equal_maths_functions( val1, val2 ) );
      END_IF;
      IF 'GENERIC_EXPRESSION' IN types2 THEN
        RETURN( mem_of_vs( val1, val2 ) );
      END_IF;
      RETURN( UNKNOWN );
    END_IF;
    IF 'MATHS_FUNCTION' IN types2 THEN
      RETURN( equal_maths_values( val2, val1 ) );
    END_IF;
    IF ( 'GENERIC_EXPRESSION' IN types1 ) AND ( 'GENERIC_EXPRESSION' IN types2 ) THEN
      IF ( NOT has_values_space( val1 ) ) OR ( NOT has_values_space( val2 ) ) THEN
        RETURN( UNKNOWN );
      END_IF;
      IF NOT compatible_spaces( values_space_of( val1 ), values_space_of( val2 ) ) THEN
        RETURN( FALSE );
      END_IF;
    END_IF;
    RETURN( UNKNOWN );

  END_FUNCTION; -- equal_maths_values (line:40395 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func EQUAL_MATHS_VALUES(VAL1: sMATHS_VALUE? , VAL2: sMATHS_VALUE? ) 
    -> SDAI.LOGICAL {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( VAL1, VAL2 )
    if case .available(let _cached_value) = _equal_maths_values__cache.cachedValue(params: _params) {
      return _cached_value as! SDAI.LOGICAL
    }

    var VAL1 = VAL1; SDAI.TOUCH(var: &VAL1)
    var VAL2 = VAL2; SDAI.TOUCH(var: &VAL2)

    //NESTED FUNCTION
    func MEM_OF_VS(VAL1: sMATHS_VALUE? , VAL2: sMATHS_VALUE? ) 
      -> SDAI.LOGICAL {

      var VAL1 = VAL1; SDAI.TOUCH(var: &VAL1)
      var VAL2 = VAL2; SDAI.TOUCH(var: &VAL2)

      
      let _TEMP1 = HAS_VALUES_SPACE(eGENERIC_EXPRESSION(/*sMATHS_VALUE*/VAL2))
      let _TEMP2 =  !_TEMP1
      if SDAI.IS_TRUE( _TEMP2 ) {
        return SDAI.LOGICAL(SDAI.UNKNOWN)
      }
      
      let _TEMP3 = VALUES_SPACE_OF(eGENERIC_EXPRESSION(/*sMATHS_VALUE*/VAL2))
      let _TEMP4 = MEMBER_OF(VAL: VAL1, 
                             SPC: _TEMP3)
      let _TEMP5 =  !_TEMP4
      if SDAI.IS_TRUE( _TEMP5 ) {
        return SDAI.LOGICAL(SDAI.FALSE)
      }
      return SDAI.LOGICAL(SDAI.UNKNOWN)
    } //END FUNCTION MEM_OF_VS

    //LOCAL
    var TYPES1: SDAI.SET<SDAI.STRING>? 
    var TYPES2: SDAI.SET<SDAI.STRING>? 
    var LIST1: SDAI.LIST<sMATHS_VALUE>? 
    var LIST2: SDAI.LIST<sMATHS_VALUE>? 
    var CUM: SDAI.LOGICAL = SDAI.LOGICAL(SDAI.TRUE); SDAI.TOUCH(var: &CUM)
    //END_LOCAL

    
    let _TEMP1 = SDAI.EXISTS(VAL1)
    let _TEMP2 =  !_TEMP1
    let _TEMP3 = SDAI.EXISTS(VAL2)
    let _TEMP4 =  !_TEMP3
    let _TEMP5 = _TEMP2 || _TEMP4
    if SDAI.IS_TRUE( _TEMP5 ) {
      return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
    }
    
    let _TEMP6 = VAL1 .==. VAL2
    if SDAI.IS_TRUE( _TEMP6 ) {
      return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.TRUE))
    }
    
    let _TEMP7 = STRIPPED_TYPEOF(VAL1)
    TYPES1 = _TEMP7
    
    let _TEMP8 = STRIPPED_TYPEOF(VAL2)
    TYPES2 = _TEMP8
    
    let _TEMP9 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("MATHS_ATOM"))
    let _TEMP10 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("COMPLEX_NUMBER_LITERAL"))
    let _TEMP11 = _TEMP9 || _TEMP10
    if SDAI.IS_TRUE( _TEMP11 ) {
      
      let _TEMP12 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_ATOM"))
      if SDAI.IS_TRUE( _TEMP12 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
      }
      
      let _TEMP13 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("COMPLEX_NUMBER_LITERAL"))
      if SDAI.IS_TRUE( _TEMP13 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
      }
      
      let _TEMP14 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("LIST"))
      if SDAI.IS_TRUE( _TEMP14 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
      }
      
      let _TEMP15 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_SPACE"))
      if SDAI.IS_TRUE( _TEMP15 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
      }
      
      let _TEMP16 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_FUNCTION"))
      if SDAI.IS_TRUE( _TEMP16 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
      }
      
      let _TEMP17 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("GENERIC_EXPRESSION"))
      if SDAI.IS_TRUE( _TEMP17 ) {
        
        let _TEMP18 = MEM_OF_VS(VAL1: VAL1, 
                                VAL2: VAL2)
        return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP18)
      }
      return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.UNKNOWN))
    }
    
    let _TEMP19 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_ATOM"))
    let _TEMP20 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("COMPLEX_NUMBER_LITERAL"))
    let _TEMP21 = _TEMP19 || _TEMP20
    if SDAI.IS_TRUE( _TEMP21 ) {
      
      let _TEMP22 = EQUAL_MATHS_VALUES(
        VAL1: VAL2, VAL2: VAL1)
      return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP22)
    }
    
    let _TEMP23 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("LIST"))
    if SDAI.IS_TRUE( _TEMP23 ) {
      
      let _TEMP24 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("LIST"))
      if SDAI.IS_TRUE( _TEMP24 ) {
        LIST1 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/VAL1)
        LIST2 = SDAI.LIST<sMATHS_VALUE>(/*sMATHS_VALUE*/VAL2)
        
        let _TEMP25 = SDAI.SIZEOF(LIST1)
        let _TEMP26 = SDAI.SIZEOF(LIST2)
        let _TEMP27 = _TEMP25 .!=. _TEMP26
        if SDAI.IS_TRUE( _TEMP27 ) {
          return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
        }
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
          SDAI.SIZEOF(LIST1)) {
          for I in incrementControl {
            
            let _TEMP28 = LIST1?[I]
            let _TEMP29 = LIST2?[I]
            let _TEMP30 = EQUAL_MATHS_VALUES(
              VAL1: _TEMP28, VAL2: _TEMP29)
            let _TEMP31 = CUM && _TEMP30
            CUM = SDAI.UNWRAP(_TEMP31)
            
            let _TEMP32 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
            if SDAI.IS_TRUE( _TEMP32 ) {
              return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
            }
          }
        }
        return _equal_maths_values__cache.updateCache(params: _params, value: CUM)
      }
      
      let _TEMP33 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_SPACE"))
      if SDAI.IS_TRUE( _TEMP33 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
      }
      
      let _TEMP34 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_FUNCTION"))
      if SDAI.IS_TRUE( _TEMP34 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
      }
      
      let _TEMP35 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("GENERIC_EXPRESSION"))
      if SDAI.IS_TRUE( _TEMP35 ) {
        
        let _TEMP36 = MEM_OF_VS(VAL1: VAL1, 
                                VAL2: VAL2)
        return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP36)
      }
      return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.UNKNOWN))
    }
    
    let _TEMP37 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("LIST"))
    if SDAI.IS_TRUE( _TEMP37 ) {
      
      let _TEMP38 = EQUAL_MATHS_VALUES(
        VAL1: VAL2, VAL2: VAL1)
      return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP38)
    }
    
    let _TEMP39 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("MATHS_SPACE"))
    if SDAI.IS_TRUE( _TEMP39 ) {
      
      let _TEMP40 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_SPACE"))
      if SDAI.IS_TRUE( _TEMP40 ) {
        
        let _TEMP41 = EQUAL_MATHS_SPACES(
          SPC1: eMATHS_SPACE(/*sMATHS_VALUE*/VAL1), 
          SPC2: eMATHS_SPACE(/*sMATHS_VALUE*/VAL2))
        return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP41)
      }
      
      let _TEMP42 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_FUNCTION"))
      if SDAI.IS_TRUE( _TEMP42 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
      }
      
      let _TEMP43 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("GENERIC_EXPRESSION"))
      if SDAI.IS_TRUE( _TEMP43 ) {
        
        let _TEMP44 = MEM_OF_VS(VAL1: VAL1, 
                                VAL2: VAL2)
        return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP44)
      }
      return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.UNKNOWN))
    }
    
    let _TEMP45 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_SPACE"))
    if SDAI.IS_TRUE( _TEMP45 ) {
      
      let _TEMP46 = EQUAL_MATHS_VALUES(
        VAL1: VAL2, VAL2: VAL1)
      return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP46)
    }
    
    let _TEMP47 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("MATHS_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP47 ) {
      
      let _TEMP48 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_FUNCTION"))
      if SDAI.IS_TRUE( _TEMP48 ) {
        
        let _TEMP49 = EQUAL_MATHS_FUNCTIONS(
          FUN1: eMATHS_FUNCTION(/*sMATHS_VALUE*/VAL1), 
          FUN2: eMATHS_FUNCTION(/*sMATHS_VALUE*/VAL2))
        return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP49)
      }
      
      let _TEMP50 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("GENERIC_EXPRESSION"))
      if SDAI.IS_TRUE( _TEMP50 ) {
        
        let _TEMP51 = MEM_OF_VS(VAL1: VAL1, 
                                VAL2: VAL2)
        return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP51)
      }
      return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.UNKNOWN))
    }
    
    let _TEMP52 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("MATHS_FUNCTION"))
    if SDAI.IS_TRUE( _TEMP52 ) {
      
      let _TEMP53 = EQUAL_MATHS_VALUES(
        VAL1: VAL2, VAL2: VAL1)
      return _equal_maths_values__cache.updateCache(params: _params, value: _TEMP53)
    }
    
    let _TEMP54 = SDAI.aggregate(TYPES1, contains: SDAI.STRING("GENERIC_EXPRESSION"))
    let _TEMP55 = SDAI.aggregate(TYPES2, contains: SDAI.STRING("GENERIC_EXPRESSION"))
    let _TEMP56 = _TEMP54 && _TEMP55
    if SDAI.IS_TRUE( _TEMP56 ) {
      
      let _TEMP57 = HAS_VALUES_SPACE(eGENERIC_EXPRESSION(/*sMATHS_VALUE*/VAL1))
      let _TEMP58 =  !_TEMP57
      let _TEMP59 = HAS_VALUES_SPACE(eGENERIC_EXPRESSION(/*sMATHS_VALUE*/VAL2))
      let _TEMP60 =  !_TEMP59
      let _TEMP61 = _TEMP58 || _TEMP60
      if SDAI.IS_TRUE( _TEMP61 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.UNKNOWN))
      }
      
      let _TEMP62 = VALUES_SPACE_OF(eGENERIC_EXPRESSION(/*sMATHS_VALUE*/VAL1))
      let _TEMP63 = VALUES_SPACE_OF(eGENERIC_EXPRESSION(/*sMATHS_VALUE*/VAL2))
      let _TEMP64 = COMPATIBLE_SPACES(
        SP1: _TEMP62, SP2: _TEMP63)
      let _TEMP65 =  !_TEMP64
      if SDAI.IS_TRUE( _TEMP65 ) {
        return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.FALSE))
      }
    }
    return _equal_maths_values__cache.updateCache(params: _params, value: SDAI.LOGICAL(SDAI.UNKNOWN))
  }

}

//MARK: - function result cache
private var _equal_maths_values__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

