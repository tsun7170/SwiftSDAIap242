/* file: enclose_pregion_in_pregion.swift 	 generated: Sun Oct 31 15:32:10 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION enclose_pregion_in_pregion(
               prgn : polar_complex_number_region;
               centre : complex_number_literal
           ) : polar_complex_number_region;

    FUNCTION angle(
                 a : REAL
             ) : REAL;
      REPEAT WHILE a > PI;
        a := a - ( 2 * PI );
      END_REPEAT;
      REPEAT WHILE a <= ( -PI );
        a := a + ( 2 * PI );
      END_REPEAT;
      RETURN( a );

    END_FUNCTION; -- angle (line:39305 file:ap242ed2_mim_lf_v1.101.TY.exp)

    FUNCTION strictly_in(
                 a : REAL;
                 aitv : finite_real_interval
             ) : LOGICAL;
      a := angle( a );
      RETURN( ( ( aitv.min < a ) AND ( a < aitv.max ) ) OR ( ( aitv.min < ( a + ( 2 * PI ) ) ) AND ( ( a + ( 
          2 * PI ) ) < aitv.max ) ) );

    END_FUNCTION; -- strictly_in (line:39326 file:ap242ed2_mim_lf_v1.101.TY.exp)

    PROCEDURE angle_range(
                  VAR amin : REAL;
                  VAR amax : REAL      );
      amin := angle( amin );
      IF amin = PI THEN
        amin := -PI;
      END_IF;
      amax := angle( amax );
      IF amax <= amin THEN
        amax := amax + ( 2 * PI );
      END_IF;

    END_PROCEDURE; -- angle_range (line:39314 file:ap242ed2_mim_lf_v1.101.TY.exp)

    PROCEDURE find_aminmax(
                  ab : REAL;
                  a0 : REAL;
                  a1 : REAL;
                  a2 : REAL;
                  a3 : REAL;
                  in0 : BOOLEAN;
                  in1 : BOOLEAN;
                  in2 : BOOLEAN;
                  in3 : BOOLEAN;
                  VAR amin : REAL;
                  VAR amax : REAL;
                  VAR amin_in : BOOLEAN;
                  VAR amax_in : BOOLEAN      );

      LOCAL
        a : REAL;
      END_LOCAL;
      amin := angle( a0 - ab );
      amin_in := in0;
      amax := amin;
      amax_in := in0;
      a := angle( a1 - ab );
      IF a = amin THEN
        amin_in := amin_in OR in1;
      END_IF;
      IF a < amin THEN
        amin := a;
        amin_in := in1;
      END_IF;
      IF a = amax THEN
        amax_in := amax_in OR in1;
      END_IF;
      IF a > amax THEN
        amax := a;
        amax_in := in1;
      END_IF;
      a := angle( a2 - ab );
      IF a = amin THEN
        amin_in := amin_in OR in2;
      END_IF;
      IF a < amin THEN
        amin := a;
        amin_in := in2;
      END_IF;
      IF a = amax THEN
        amax_in := amax_in OR in2;
      END_IF;
      IF a > amax THEN
        amax := a;
        amax_in := in2;
      END_IF;
      a := angle( a3 - ab );
      IF a = amin THEN
        amin_in := amin_in OR in3;
      END_IF;
      IF a < amin THEN
        amin := a;
        amin_in := in3;
      END_IF;
      IF a = amax THEN
        amax_in := amax_in OR in3;
      END_IF;
      IF a > amax THEN
        amax := a;
        amax_in := in3;
      END_IF;
      amin := amin + ab;
      amax := amax + ab;
      angle_range( amin, amax );

    END_PROCEDURE; -- find_aminmax (line:39331 file:ap242ed2_mim_lf_v1.101.TY.exp)

    LOCAL
      ritp    : real_interval;
      ritv    : real_interval;
      aitp    : finite_real_interval;
      aitv    : finite_real_interval;
      xp      : REAL := 0;
      yp      : REAL := 0;
      xc      : REAL := 0;
      yc      : REAL := 0;
      rmax    : REAL := 0;
      rmin    : REAL := 0;
      amin    : REAL := 0;
      amax    : REAL := 0;
      rc      : REAL := 0;
      acp     : REAL := 0;
      apc     : REAL := 0;
      rmax_in : BOOLEAN := FALSE;
      rmin_in : BOOLEAN := FALSE;
      amin_in : BOOLEAN := FALSE;
      amax_in : BOOLEAN := FALSE;
      rmxp    : REAL := 0;
      rmnp    : REAL := 0;
      x       : REAL := 0;
      y       : REAL := 0;
      r       : REAL := 0;
      a       : REAL := 0;
      ab      : REAL := 0;
      r0      : REAL := 0;
      a0      : REAL := 0;
      r1      : REAL := 0;
      a1      : REAL := 0;
      r2      : REAL := 0;
      a2      : REAL := 0;
      r3      : REAL := 0;
      a3      : REAL := 0;
      in0     : BOOLEAN := FALSE;
      in1     : BOOLEAN := FALSE;
      in2     : BOOLEAN := FALSE;
      in3     : BOOLEAN := FALSE;
      inn     : BOOLEAN := FALSE;
      minclo  : open_closed := open;
      maxclo  : open_closed := open;
    END_LOCAL;
    IF ( NOT EXISTS( prgn ) ) OR ( NOT EXISTS( centre ) ) THEN
      RETURN( ? );
    END_IF;
    xp := prgn.centre.real_part;
    yp := prgn.centre.imag_part;
    ritp := prgn.distance_constraint;
    aitp := prgn.direction_constraint;
    xc := centre.real_part;
    yc := centre.imag_part;
    IF ( xc = xp ) AND ( yc = yp ) THEN
      RETURN( prgn );
    END_IF;
    rc := SQRT( ( ( xp - xc ) ** 2 ) + ( ( yp - yc ) ** 2 ) );
    acp := atan2( yp - yc, xp - xc );
    apc := atan2( yc - yp, xc - xp );
    rmnp := real_min( ritp );
    IF max_exists( ritp ) THEN
      rmxp := real_max( ritp );
      IF ( aitp.max - aitp.min ) = ( 2 * PI ) THEN
        inn := NOT max_included( aitp );
        a := angle( aitp.min );
        rmax := rc + rmxp;
        rmax_in := max_included( ritp );
        IF inn AND ( acp = a ) THEN
          rmax_in := FALSE;
        END_IF;
        IF rc > rmxp THEN
          a0 := ASIN( rmxp / rc );
          amin := angle( acp - a0 );
          amin_in := max_included( ritp );
          IF amin = PI THEN
            amin := -PI;
          END_IF;
          amax := angle( acp + a0 );
          amax_in := amin_in;
          IF amax < amin THEN
            amax := amax + ( 2 * PI );
          END_IF;
          rmin := rc - rmxp;
          rmin_in := amin_in;
          IF inn THEN
            IF apc = a THEN
              rmin_in := FALSE;
            END_IF;
            IF angle( amin + ( 0.5 * PI ) ) = a THEN
              amin_in := FALSE;
            END_IF;
            IF angle( amax - ( 0.5 * PI ) ) = a THEN
              amax_in := FALSE;
            END_IF;
          END_IF;
        ELSE
          IF rc = rmxp THEN
            amin := angle( acp - ( 0.5 * PI ) );
            amin_in := FALSE;
            IF amin = PI THEN
              amin := -PI;
            END_IF;
            amax := angle( acp + ( 0.5 * PI ) );
            amax_in := FALSE;
            IF amax < amin THEN
              amax := amax + ( 2 * PI );
            END_IF;
            rmin := 0;
            rmin_in := max_included( ritp );
            IF inn AND ( apc = a ) THEN
              rmin_in := FALSE;
            END_IF;
          ELSE
            IF rc > rmnp THEN
              IF inn AND ( apc = a ) THEN
                rmin := 0;
                rmin_in := FALSE;
                amin := aitp.min;
                amin_in := FALSE;
                amax := aitp.max;
                amax_in := FALSE;
              ELSE
                rmin := 0;
                rmin_in := TRUE;
                amin := -PI;
                amin_in := FALSE;
                amax := PI;
                amax_in := TRUE;
              END_IF;
            ELSE
              rmin := rmnp - rc;
              rmin_in := min_included( ritp );
              amin := -PI;
              amin_in := FALSE;
              amax := PI;
              amax_in := TRUE;
              IF inn THEN
                IF apc = a THEN
                  rmin_in := FALSE;
                  amin := aitp.min;
                  amin_in := FALSE;
                  amax := aitp.max;
                  amax_in := FALSE;
                ELSE
                  IF acp = a THEN
                    amin := aitp.min;
                    amin_in := FALSE;
                    amax := aitp.max;
                    amax_in := FALSE;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      ELSE
        x := ( xp + ( rmxp * COS( aitp.min ) ) ) - xc;
        y := ( yp + ( rmxp * SIN( aitp.min ) ) ) - yc;
        r0 := SQRT( ( x ** 2 ) + ( y ** 2 ) );
        in0 := max_included( ritp ) AND min_included( aitp );
        IF r0 <> 0 THEN
          a0 := atan2( y, x );
        END_IF;
        x := ( xp + ( rmxp * COS( aitp.max ) ) ) - xc;
        y := ( yp + ( rmxp * SIN( aitp.max ) ) ) - yc;
        r1 := SQRT( ( x ** 2 ) + ( y ** 2 ) );
        in1 := max_included( ritp ) AND max_included( aitp );
        IF r1 <> 0 THEN
          a1 := atan2( y, x );
        END_IF;
        x := ( xp + ( rmnp * COS( aitp.max ) ) ) - xc;
        y := ( yp + ( rmnp * SIN( aitp.max ) ) ) - yc;
        r2 := SQRT( ( x ** 2 ) + ( y ** 2 ) );
        in2 := min_included( ritp ) AND max_included( aitp );
        IF r2 <> 0 THEN
          a2 := atan2( y, x );
        ELSE
          a2 := a1;
          in2 := in1;
        END_IF;
        IF r1 = 0 THEN
          a1 := a2;
          in1 := in2;
        END_IF;
        x := ( xp + ( rmnp * COS( aitp.min ) ) ) - xc;
        y := ( yp + ( rmnp * SIN( aitp.min ) ) ) - yc;
        r3 := SQRT( ( x ** 2 ) + ( y ** 2 ) );
        in3 := min_included( ritp ) AND min_included( aitp );
        IF r3 <> 0 THEN
          a3 := atan2( y, x );
        ELSE
          a3 := a0;
          in3 := in0;
        END_IF;
        IF r0 = 0 THEN
          a0 := a3;
          in0 := in3;
        END_IF;
        IF rmnp = 0 THEN
          in2 := min_included( ritp );
          in3 := in2;
        END_IF;
        IF ( apc = angle( aitp.min ) ) OR ( acp = angle( aitp.min ) ) THEN
          in0 := min_included( aitp );
          in3 := in0;
        ELSE
          IF ( apc = angle( aitp.max ) ) OR ( acp = angle( aitp.max ) ) THEN
            in1 := max_included( aitp );
            in2 := in1;
          END_IF;
        END_IF;
        IF strictly_in( acp, aitp ) THEN
          rmax := rc + rmxp;
          rmax_in := max_included( ritp );
        ELSE
          rmax := r0;
          rmax_in := in0;
          IF rmax = r1 THEN
            rmax_in := rmax_in OR in1;
          END_IF;
          IF rmax < r1 THEN
            rmax := r1;
            rmax_in := in1;
          END_IF;
          IF rmax = r2 THEN
            rmax_in := rmax_in OR in2;
          END_IF;
          IF rmax < r2 THEN
            rmax := r2;
            rmax_in := in2;
          END_IF;
          IF rmax = r3 THEN
            rmax_in := rmax_in OR in3;
          END_IF;
          IF rmax < r3 THEN
            rmax := r3;
            rmax_in := in3;
          END_IF;
        END_IF;
        IF strictly_in( apc, aitp ) THEN
          IF rc >= rmxp THEN
            rmin := rc - rmxp;
            rmin_in := max_included( ritp );
          ELSE
            IF rc <= rmnp THEN
              rmin := rmnp - rc;
              rmin_in := min_included( ritp );
            ELSE
              rmin := 0;
              rmin_in := TRUE;
            END_IF;
          END_IF;
        ELSE
          rmin := r0;
          rmin_in := in0;
          a := apc - aitp.min;
          r := rc * COS( a );
          IF ( rmnp < r ) AND ( r < rmxp ) THEN
            rmin := rc * SIN( ABS( a ) );
            rmin_in := min_included( aitp );
          END_IF;
          a := apc - aitp.max;
          r := rc * COS( a );
          IF ( rmnp < r ) AND ( r < rmxp ) THEN
            r := rc * SIN( ABS( a ) );
            inn := max_included( aitp );
            IF r = rmin THEN
              rmin_in := rmin_in OR inn;
            END_IF;
            IF r < rmin THEN
              rmin := r;
              rmin_in := inn;
            END_IF;
          END_IF;
          IF r1 = rmin THEN
            rmin_in := rmin_in OR in1;
          END_IF;
          IF r1 < rmin THEN
            rmin := r1;
            rmin_in := in1;
          END_IF;
          IF r2 = rmin THEN
            rmin_in := rmin_in OR in2;
          END_IF;
          IF r2 < rmin THEN
            rmin := r2;
            rmin_in := in2;
          END_IF;
          IF r3 = rmin THEN
            rmin_in := rmin_in OR in3;
          END_IF;
          IF r3 < rmin THEN
            rmin := r3;
            rmin_in := in3;
          END_IF;
        END_IF;
        IF rc >= rmxp THEN
          ab := acp;
          find_aminmax( ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in );
          a := ACOS( rmxp / rc );
          IF strictly_in( apc - a, aitp ) THEN
            amin := ab - ASIN( rmxp / rc );
            amin_in := max_included( ritp );
          END_IF;
          IF strictly_in( apc + a, aitp ) THEN
            amax := ab + ASIN( rmxp / rc );
            amax_in := max_included( ritp );
          END_IF;
          angle_range( amin, amax );
        ELSE
          IF rc > rmnp THEN
            ab := angle( 0.5 * ( aitp.min + aitp.max ) );
            find_aminmax( ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in );
          ELSE
            ab := angle( 0.5 * ( aitp.min + aitp.max ) );
            a0 := angle( a0 - ab );
            a1 := angle( a1 - ab );
            a2 := angle( a2 - ab );
            a3 := angle( a3 - ab );
            IF a3 > a2 THEN
              a2 := a2 + ( 2 * PI );
            END_IF;
            IF a0 > a1 THEN
              a0 := a0 + ( 2 * PI );
            END_IF;
            IF a3 < a0 THEN
              amin := a3;
              amin_in := in3;
            ELSE
              amin := a0;
              amin_in := in0;
            END_IF;
            IF a2 > a1 THEN
              amax := a2;
              amax_in := in2;
            ELSE
              amax := a1;
              amax_in := in1;
            END_IF;
            IF ( ( amax - amin ) > ( 2 * PI ) ) OR ( ( ( amax - amin ) = ( 2 * PI ) ) AND ( amin_in OR 
                amax_in ) ) THEN
              amin := -PI;
              amin_in := FALSE;
              amax := PI;
              amax_in := TRUE;
            ELSE
              amin := amin + ab;
              amax := amax + ab;
              angle_range( amin, amax );
            END_IF;
          END_IF;
        END_IF;
      END_IF;
      IF rmin_in THEN
        minclo := closed;
      END_IF;
      IF rmax_in THEN
        maxclo := closed;
      END_IF;
      ritv := make_finite_real_interval( rmin, minclo, rmax, maxclo );
    ELSE
      IF ( rc > rmnp ) AND strictly_in( apc, aitp ) THEN
        RETURN( ? );
      END_IF;
      IF ( aitp.max - aitp.min ) = ( 2 * PI ) THEN
        a := angle( aitp.min );
        IF rc > rmnp THEN
          IF max_included( aitp ) THEN
            RETURN( ? );
          END_IF;
          rmin := 0;
          rmin_in := FALSE;
          amin := aitp.min;
          amin_in := FALSE;
          amax := aitp.max;
          amax_in := FALSE;
        ELSE
          rmin := rmnp - rc;
          rmin_in := min_included( ritp );
          amin := -PI;
          amin_in := FALSE;
          amax := PI;
          amax_in := TRUE;
          IF NOT max_included( aitp ) THEN
            IF apc = a THEN
              rmin_in := FALSE;
              amin := aitp.min;
              amin_in := FALSE;
              amax := aitp.max;
              amax_in := FALSE;
            ELSE
              IF acp = a THEN
                amin := aitp.min;
                amin_in := FALSE;
                amax := aitp.max;
                amax_in := FALSE;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      ELSE
        a0 := angle( aitp.min );
        in0 := FALSE;
        a1 := angle( aitp.max );
        in1 := FALSE;
        x := ( xp + ( rmnp * COS( aitp.max ) ) ) - xc;
        y := ( yp + ( rmnp * SIN( aitp.max ) ) ) - yc;
        r2 := SQRT( ( x ** 2 ) + ( y ** 2 ) );
        in2 := min_included( ritp ) AND max_included( aitp );
        IF r2 <> 0 THEN
          a2 := atan2( y, x );
        ELSE
          a2 := a1;
          in2 := in1;
        END_IF;
        x := ( xp + ( rmnp * COS( aitp.min ) ) ) - xc;
        y := ( yp + ( rmnp * SIN( aitp.min ) ) ) - yc;
        r3 := SQRT( ( x ** 2 ) + ( y ** 2 ) );
        in3 := min_included( ritp ) AND min_included( aitp );
        IF r3 <> 0 THEN
          a3 := atan2( y, x );
        ELSE
          a3 := a0;
          in3 := in0;
        END_IF;
        IF rmnp = 0 THEN
          in2 := min_included( ritp );
          in3 := in2;
        END_IF;
        IF ( apc = angle( aitp.min ) ) OR ( acp = angle( aitp.min ) ) THEN
          in0 := min_included( aitp );
          in3 := in0;
        ELSE
          IF ( apc = angle( aitp.max ) ) OR ( acp = angle( aitp.max ) ) THEN
            in1 := max_included( aitp );
            in2 := in1;
          END_IF;
        END_IF;
        IF strictly_in( apc, aitp ) THEN
          rmin := rmnp - rc;
          rmin_in := min_included( ritp );
        ELSE
          rmin := r2;
          rmin_in := in2;
          a := apc - aitp.min;
          r := rc * COS( a );
          IF rmnp < r THEN
            rmin := rc * SIN( ABS( a ) );
            rmin_in := min_included( aitp );
          END_IF;
          a := apc - aitp.max;
          r := rc * COS( a );
          IF rmnp < r THEN
            r := rc * SIN( ABS( a ) );
            inn := max_included( aitp );
            IF r = rmin THEN
              rmin_in := rmin_in OR inn;
            END_IF;
            IF r < rmin THEN
              rmin := r;
              rmin_in := inn;
            END_IF;
          END_IF;
          IF r3 = rmin THEN
            rmin_in := rmin_in OR in3;
          END_IF;
          IF r3 < rmin THEN
            rmin := r3;
            rmin_in := in3;
          END_IF;
        END_IF;
        ab := angle( 0.5 * ( aitp.min + aitp.max ) );
        IF rc > rmnp THEN
          find_aminmax( ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in );
        ELSE
          a0 := angle( a0 - ab );
          a1 := angle( a1 - ab );
          a2 := angle( a2 - ab );
          a3 := angle( a3 - ab );
          IF a3 > a2 THEN
            a2 := a2 + ( 2 * PI );
          END_IF;
          IF a0 > a1 THEN
            a0 := a0 + ( 2 * PI );
          END_IF;
          IF a3 < a0 THEN
            amin := a3;
            amin_in := in3;
          ELSE
            amin := a0;
            amin_in := in0;
          END_IF;
          IF a2 > a1 THEN
            amax := a2;
            amax_in := in2;
          ELSE
            amax := a1;
            amax_in := in1;
          END_IF;
          IF ( ( amax - amin ) > ( 2 * PI ) ) OR ( ( ( amax - amin ) = ( 2 * PI ) ) AND ( amin_in OR amax_in ) )
              THEN
            amin := -PI;
            amin_in := FALSE;
            amax := PI;
            amax_in := TRUE;
            IF ( rmin = 0 ) AND rmin_in THEN
              RETURN( ? );
            END_IF;
          ELSE
            amin := amin + ab;
            amax := amax + ab;
            angle_range( amin, amax );
          END_IF;
        END_IF;
      END_IF;
      IF rmin_in THEN
        minclo := closed;
      END_IF;
      ritv := make_real_interval_from_min( rmin, minclo );
    END_IF;
    minclo := open;
    maxclo := open;
    IF amin_in THEN
      minclo := closed;
    END_IF;
    IF amax_in THEN
      maxclo := closed;
    END_IF;
    aitv := make_finite_real_interval( amin, minclo, amax, maxclo );
    RETURN( make_polar_complex_number_region( centre, ritv, aitv ) );

  END_FUNCTION; -- enclose_pregion_in_pregion (line:39302 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func ENCLOSE_PREGION_IN_PREGION(PRGN: ePOLAR_COMPLEX_NUMBER_REGION? , CENTRE: eCOMPLEX_NUMBER_LITERAL? ) 
    -> ePOLAR_COMPLEX_NUMBER_REGION? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( PRGN, CENTRE )
    if case .available(let _cached_value) = _enclose_pregion_in_pregion__cache.cachedValue(params: _params) {
      return _cached_value as? ePOLAR_COMPLEX_NUMBER_REGION
    }

    var PRGN = PRGN; SDAI.TOUCH(var: &PRGN)
    var CENTRE = CENTRE; SDAI.TOUCH(var: &CENTRE)

    //NESTED FUNCTION
    func ANGLE(_ A: SDAI.REAL? ) -> SDAI.REAL? {

      var A = A; SDAI.TOUCH(var: &A)

      while !SDAI.IS_TRUE(( A > SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI)) )) {
        
        let _TEMP1 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP2 = A - SDAI.FORCE_OPTIONAL(_TEMP1)
        A = _TEMP2
      }
      while !SDAI.IS_TRUE(( A <= SDAI.FORCE_OPTIONAL(SDAI.REAL( -SDAI.PI)) )) {
        
        let _TEMP3 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP4 = A + SDAI.FORCE_OPTIONAL(_TEMP3)
        A = _TEMP4
      }
      return A
    } //END FUNCTION ANGLE

    //NESTED FUNCTION
    func STRICTLY_IN(A: SDAI.REAL? , AITV: eFINITE_REAL_INTERVAL? ) 
      -> SDAI.LOGICAL {

      var A = A; SDAI.TOUCH(var: &A)
      var AITV = AITV; SDAI.TOUCH(var: &AITV)

      
      let _TEMP1 = ANGLE(A)
      A = _TEMP1
      
      let _TEMP2 = AITV?.MIN
      let _TEMP3 = _TEMP2 < A
      let _TEMP4 = AITV?.MAX
      let _TEMP5 = A < _TEMP4
      let _TEMP6 = _TEMP3 && _TEMP5
      let _TEMP7 = AITV?.MIN
      let _TEMP8 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
      let _TEMP9 = A + SDAI.FORCE_OPTIONAL(_TEMP8)
      let _TEMP10 = _TEMP7 < _TEMP9
      let _TEMP11 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
      let _TEMP12 = A + SDAI.FORCE_OPTIONAL(_TEMP11)
      let _TEMP13 = AITV?.MAX
      let _TEMP14 = _TEMP12 < _TEMP13
      let _TEMP15 = _TEMP10 && _TEMP14
      let _TEMP16 = _TEMP6 || _TEMP15
      return SDAI.UNWRAP(_TEMP16)
    } //END FUNCTION STRICTLY_IN

    //NESTED PROCEDURE
    func ANGLE_RANGE(AMIN: inout SDAI.REAL? , AMAX: inout SDAI.REAL? ) {

      
      let _TEMP1 = ANGLE(AMIN)
      AMIN = _TEMP1
      
      let _TEMP2 = AMIN .==. SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
      if SDAI.IS_TRUE( _TEMP2 ) {
        AMIN = SDAI.REAL( -SDAI.PI)
      }
      
      let _TEMP3 = ANGLE(AMAX)
      AMAX = _TEMP3
      
      let _TEMP4 = AMAX <= AMIN
      if SDAI.IS_TRUE( _TEMP4 ) {
        
        let _TEMP5 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP6 = AMAX + SDAI.FORCE_OPTIONAL(_TEMP5)
        AMAX = _TEMP6
      }
    } //END PROCEDURE ANGLE_RANGE

    //NESTED PROCEDURE
    func FIND_AMINMAX(AB: SDAI.REAL? , A0: SDAI.REAL? , A1: SDAI.REAL? , 
                      A2: SDAI.REAL? , A3: SDAI.REAL? , IN0: SDAI.BOOLEAN? , 
                      IN1: SDAI.BOOLEAN? , IN2: SDAI.BOOLEAN? , IN3: SDAI.BOOLEAN? , 
                      AMIN: inout SDAI.REAL? , AMAX: inout SDAI.REAL? , AMIN_IN: inout SDAI.BOOLEAN? , 
                      AMAX_IN: inout SDAI.BOOLEAN? ) {

      var AB = AB; SDAI.TOUCH(var: &AB)
      var A0 = A0; SDAI.TOUCH(var: &A0)
      var A1 = A1; SDAI.TOUCH(var: &A1)
      var A2 = A2; SDAI.TOUCH(var: &A2)
      var A3 = A3; SDAI.TOUCH(var: &A3)
      var IN0 = IN0; SDAI.TOUCH(var: &IN0)
      var IN1 = IN1; SDAI.TOUCH(var: &IN1)
      var IN2 = IN2; SDAI.TOUCH(var: &IN2)
      var IN3 = IN3; SDAI.TOUCH(var: &IN3)

      //LOCAL
      var A: SDAI.REAL? 

      
      let _TEMP1 = A0 - AB
      let _TEMP2 = ANGLE(_TEMP1)
      AMIN = _TEMP2
      AMIN_IN = IN0
      AMAX = AMIN
      AMAX_IN = IN0
      
      let _TEMP3 = A1 - AB
      let _TEMP4 = ANGLE(_TEMP3)
      A = _TEMP4
      
      let _TEMP5 = A .==. AMIN
      if SDAI.IS_TRUE( _TEMP5 ) {
        
        let _TEMP6 = AMIN_IN || IN1
        AMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP6)
      }
      
      let _TEMP7 = A < AMIN
      if SDAI.IS_TRUE( _TEMP7 ) {
        AMIN = A
        AMIN_IN = IN1
      }
      
      let _TEMP8 = A .==. AMAX
      if SDAI.IS_TRUE( _TEMP8 ) {
        
        let _TEMP9 = AMAX_IN || IN1
        AMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP9)
      }
      
      let _TEMP10 = A > AMAX
      if SDAI.IS_TRUE( _TEMP10 ) {
        AMAX = A
        AMAX_IN = IN1
      }
      
      let _TEMP11 = A2 - AB
      let _TEMP12 = ANGLE(_TEMP11)
      A = _TEMP12
      
      let _TEMP13 = A .==. AMIN
      if SDAI.IS_TRUE( _TEMP13 ) {
        
        let _TEMP14 = AMIN_IN || IN2
        AMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP14)
      }
      
      let _TEMP15 = A < AMIN
      if SDAI.IS_TRUE( _TEMP15 ) {
        AMIN = A
        AMIN_IN = IN2
      }
      
      let _TEMP16 = A .==. AMAX
      if SDAI.IS_TRUE( _TEMP16 ) {
        
        let _TEMP17 = AMAX_IN || IN2
        AMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP17)
      }
      
      let _TEMP18 = A > AMAX
      if SDAI.IS_TRUE( _TEMP18 ) {
        AMAX = A
        AMAX_IN = IN2
      }
      
      let _TEMP19 = A3 - AB
      let _TEMP20 = ANGLE(_TEMP19)
      A = _TEMP20
      
      let _TEMP21 = A .==. AMIN
      if SDAI.IS_TRUE( _TEMP21 ) {
        
        let _TEMP22 = AMIN_IN || IN3
        AMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP22)
      }
      
      let _TEMP23 = A < AMIN
      if SDAI.IS_TRUE( _TEMP23 ) {
        AMIN = A
        AMIN_IN = IN3
      }
      
      let _TEMP24 = A .==. AMAX
      if SDAI.IS_TRUE( _TEMP24 ) {
        
        let _TEMP25 = AMAX_IN || IN3
        AMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP25)
      }
      
      let _TEMP26 = A > AMAX
      if SDAI.IS_TRUE( _TEMP26 ) {
        AMAX = A
        AMAX_IN = IN3
      }
      
      let _TEMP27 = AMIN + AB
      AMIN = _TEMP27
      
      let _TEMP28 = AMAX + AB
      AMAX = _TEMP28
      ANGLE_RANGE( AMIN: &AMIN, AMAX: &AMAX )
    } //END PROCEDURE FIND_AMINMAX

    //LOCAL
    var RITP: sREAL_INTERVAL? 
    var RITV: sREAL_INTERVAL? 
    var AITP: eFINITE_REAL_INTERVAL? 
    var AITV: eFINITE_REAL_INTERVAL? 
    var XP: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &XP)
    var YP: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &YP)
    var XC: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &XC)
    var YC: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &YC)
    var RMAX: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &RMAX)
    var RMIN: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &RMIN)
    var AMIN: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &AMIN)
    var AMAX: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &AMAX)
    var RC: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &RC)
    var ACP: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &ACP)
    var APC: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &APC)
    var RMAX_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &RMAX_IN)
    var RMIN_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &RMIN_IN)
    var AMIN_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &AMIN_IN)
    var AMAX_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &AMAX_IN)
    var RMXP: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &RMXP)
    var RMNP: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &RMNP)
    var X: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &X)
    var Y: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &Y)
    var R: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &R)
    var A: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &A)
    var AB: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &AB)
    var R0: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &R0)
    var A0: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &A0)
    var R1: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &R1)
    var A1: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &A1)
    var R2: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &R2)
    var A2: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &A2)
    var R3: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &R3)
    var A3: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &A3)
    var IN0: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &IN0)
    var IN1: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &IN1)
    var IN2: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &IN2)
    var IN3: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &IN3)
    var INN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &INN)
    var MINCLO: nOPEN_CLOSED?  = OPEN; SDAI.TOUCH(var: &MINCLO)
    var MAXCLO: nOPEN_CLOSED?  = OPEN; SDAI.TOUCH(var: &MAXCLO)
    //END_LOCAL

    
    let _TEMP1 = SDAI.EXISTS(PRGN)
    let _TEMP2 =  !_TEMP1
    let _TEMP3 = SDAI.EXISTS(CENTRE)
    let _TEMP4 =  !_TEMP3
    let _TEMP5 = _TEMP2 || _TEMP4
    if SDAI.IS_TRUE( _TEMP5 ) {
      return _enclose_pregion_in_pregion__cache.updateCache(params: _params, value: (nil as 
        ePOLAR_COMPLEX_NUMBER_REGION?))
    }
    
    let _TEMP6 = PRGN?.CENTRE
    let _TEMP7 = _TEMP6?.REAL_PART
    XP = _TEMP7
    
    let _TEMP8 = PRGN?.CENTRE
    let _TEMP9 = _TEMP8?.IMAG_PART
    YP = _TEMP9
    
    let _TEMP10 = PRGN?.DISTANCE_CONSTRAINT
    RITP = _TEMP10
    
    let _TEMP11 = PRGN?.DIRECTION_CONSTRAINT
    AITP = _TEMP11
    
    let _TEMP12 = CENTRE?.REAL_PART
    XC = _TEMP12
    
    let _TEMP13 = CENTRE?.IMAG_PART
    YC = _TEMP13
    
    let _TEMP14 = XC .==. XP
    let _TEMP15 = YC .==. YP
    let _TEMP16 = _TEMP14 && _TEMP15
    if SDAI.IS_TRUE( _TEMP16 ) {
      return _enclose_pregion_in_pregion__cache.updateCache(params: _params, value: PRGN)
    }
    
    let _TEMP17 = XP - XC
    let _TEMP18 = _TEMP17 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
    let _TEMP19 = YP - YC
    let _TEMP20 = _TEMP19 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
    let _TEMP21 = _TEMP18 + _TEMP20
    let _TEMP22 = SDAI.SQRT(_TEMP21)
    RC = _TEMP22
    
    let _TEMP23 = YP - YC
    let _TEMP24 = XP - XC
    let _TEMP25 = ATAN2(Y: _TEMP23, 
                        X: _TEMP24)
    ACP = _TEMP25
    
    let _TEMP26 = YC - YP
    let _TEMP27 = XC - XP
    let _TEMP28 = ATAN2(Y: _TEMP26, 
                        X: _TEMP27)
    APC = _TEMP28
    
    let _TEMP29 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
    RMNP = _TEMP29
    
    let _TEMP30 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
    if SDAI.IS_TRUE( _TEMP30 ) {
      
      let _TEMP31 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
      RMXP = _TEMP31
      
      let _TEMP32 = AITP?.MAX
      let _TEMP33 = AITP?.MIN
      let _TEMP34 = _TEMP32 - _TEMP33
      let _TEMP35 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
      let _TEMP36 = _TEMP34 .==. SDAI.FORCE_OPTIONAL(_TEMP35)
      if SDAI.IS_TRUE( _TEMP36 ) {
        
        let _TEMP37 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
        let _TEMP38 =  !_TEMP37
        INN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP38)
        
        let _TEMP39 = AITP?.MIN
        let _TEMP40 = ANGLE(_TEMP39)
        A = _TEMP40
        
        let _TEMP41 = RC + RMXP
        RMAX = _TEMP41
        
        let _TEMP42 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
        RMAX_IN = _TEMP42
        
        let _TEMP43 = ACP .==. A
        let _TEMP44 = INN && _TEMP43
        if SDAI.IS_TRUE( _TEMP44 ) {
          RMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
        }
        
        let _TEMP45 = RC > RMXP
        if SDAI.IS_TRUE( _TEMP45 ) {
          
          let _TEMP46 = RMXP / RC
          let _TEMP47 = SDAI.ASIN(_TEMP46)
          A0 = _TEMP47
          
          let _TEMP48 = ACP - A0
          let _TEMP49 = ANGLE(_TEMP48)
          AMIN = _TEMP49
          
          let _TEMP50 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
          AMIN_IN = _TEMP50
          
          let _TEMP51 = AMIN .==. SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
          if SDAI.IS_TRUE( _TEMP51 ) {
            AMIN = SDAI.REAL( -SDAI.PI)
          }
          
          let _TEMP52 = ACP + A0
          let _TEMP53 = ANGLE(_TEMP52)
          AMAX = _TEMP53
          AMAX_IN = AMIN_IN
          
          let _TEMP54 = AMAX < AMIN
          if SDAI.IS_TRUE( _TEMP54 ) {
            
            let _TEMP55 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
            let _TEMP56 = AMAX + SDAI.FORCE_OPTIONAL(_TEMP55)
            AMAX = _TEMP56
          }
          
          let _TEMP57 = RC - RMXP
          RMIN = _TEMP57
          RMIN_IN = AMIN_IN
          if SDAI.IS_TRUE( INN ) {
            
            let _TEMP58 = APC .==. A
            if SDAI.IS_TRUE( _TEMP58 ) {
              RMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
            }
            
            let _TEMP59 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
            let _TEMP60 = AMIN + SDAI.FORCE_OPTIONAL(_TEMP59)
            let _TEMP61 = ANGLE(_TEMP60)
            let _TEMP62 = _TEMP61 .==. A
            if SDAI.IS_TRUE( _TEMP62 ) {
              AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
            }
            
            let _TEMP63 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
            let _TEMP64 = AMAX - SDAI.FORCE_OPTIONAL(_TEMP63)
            let _TEMP65 = ANGLE(_TEMP64)
            let _TEMP66 = _TEMP65 .==. A
            if SDAI.IS_TRUE( _TEMP66 ) {
              AMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
            }
          }
        }
        else {
          
          let _TEMP67 = RC .==. RMXP
          if SDAI.IS_TRUE( _TEMP67 ) {
            
            let _TEMP68 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
            let _TEMP69 = ACP - SDAI.FORCE_OPTIONAL(_TEMP68)
            let _TEMP70 = ANGLE(_TEMP69)
            AMIN = _TEMP70
            AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
            
            let _TEMP71 = AMIN .==. SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
            if SDAI.IS_TRUE( _TEMP71 ) {
              AMIN = SDAI.REAL( -SDAI.PI)
            }
            
            let _TEMP72 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
            let _TEMP73 = ACP + SDAI.FORCE_OPTIONAL(_TEMP72)
            let _TEMP74 = ANGLE(_TEMP73)
            AMAX = _TEMP74
            AMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
            
            let _TEMP75 = AMAX < AMIN
            if SDAI.IS_TRUE( _TEMP75 ) {
              
              let _TEMP76 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
              let _TEMP77 = AMAX + SDAI.FORCE_OPTIONAL(_TEMP76)
              AMAX = _TEMP77
            }
            RMIN = SDAI.REAL(0)
            
            let _TEMP78 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
            RMIN_IN = _TEMP78
            
            let _TEMP79 = APC .==. A
            let _TEMP80 = INN && _TEMP79
            if SDAI.IS_TRUE( _TEMP80 ) {
              RMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
            }
          }
          else {
            
            let _TEMP81 = RC > RMNP
            if SDAI.IS_TRUE( _TEMP81 ) {
              
              let _TEMP82 = APC .==. A
              let _TEMP83 = INN && _TEMP82
              if SDAI.IS_TRUE( _TEMP83 ) {
                RMIN = SDAI.REAL(0)
                RMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
                
                let _TEMP84 = AITP?.MIN
                AMIN = _TEMP84
                AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
                
                let _TEMP85 = AITP?.MAX
                AMAX = _TEMP85
                AMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
              }
              else {
                RMIN = SDAI.REAL(0)
                RMIN_IN = SDAI.BOOLEAN(SDAI.TRUE)
                AMIN = SDAI.REAL( -SDAI.PI)
                AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
                AMAX = SDAI.REAL(SDAI.PI)
                AMAX_IN = SDAI.BOOLEAN(SDAI.TRUE)
              }
            }
            else {
              
              let _TEMP86 = RMNP - RC
              RMIN = _TEMP86
              
              let _TEMP87 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
              RMIN_IN = _TEMP87
              AMIN = SDAI.REAL( -SDAI.PI)
              AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
              AMAX = SDAI.REAL(SDAI.PI)
              AMAX_IN = SDAI.BOOLEAN(SDAI.TRUE)
              if SDAI.IS_TRUE( INN ) {
                
                let _TEMP88 = APC .==. A
                if SDAI.IS_TRUE( _TEMP88 ) {
                  RMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
                  
                  let _TEMP89 = AITP?.MIN
                  AMIN = _TEMP89
                  AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
                  
                  let _TEMP90 = AITP?.MAX
                  AMAX = _TEMP90
                  AMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
                }
                else {
                  
                  let _TEMP91 = ACP .==. A
                  if SDAI.IS_TRUE( _TEMP91 ) {
                    
                    let _TEMP92 = AITP?.MIN
                    AMIN = _TEMP92
                    AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
                    
                    let _TEMP93 = AITP?.MAX
                    AMAX = _TEMP93
                    AMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
                  }
                }
              }
            }
          }
        }
      }
      else {
        
        let _TEMP94 = AITP?.MIN
        let _TEMP95 = SDAI.COS(_TEMP94)
        let _TEMP96 = RMXP * _TEMP95
        let _TEMP97 = XP + _TEMP96
        let _TEMP98 = _TEMP97 - XC
        X = _TEMP98
        
        let _TEMP99 = AITP?.MIN
        let _TEMP100 = SDAI.SIN(_TEMP99)
        let _TEMP101 = RMXP * _TEMP100
        let _TEMP102 = YP + _TEMP101
        let _TEMP103 = _TEMP102 - YC
        Y = _TEMP103
        
        let _TEMP104 = X ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP105 = Y ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP106 = _TEMP104 + _TEMP105
        let _TEMP107 = SDAI.SQRT(_TEMP106)
        R0 = _TEMP107
        
        let _TEMP108 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
        let _TEMP109 = MIN_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
        let _TEMP110 = _TEMP108 && _TEMP109
        IN0 = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP110)
        
        let _TEMP111 = R0 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP111 ) {
          
          let _TEMP112 = ATAN2(Y: Y, 
                               X: X)
          A0 = _TEMP112
        }
        
        let _TEMP113 = AITP?.MAX
        let _TEMP114 = SDAI.COS(_TEMP113)
        let _TEMP115 = RMXP * _TEMP114
        let _TEMP116 = XP + _TEMP115
        let _TEMP117 = _TEMP116 - XC
        X = _TEMP117
        
        let _TEMP118 = AITP?.MAX
        let _TEMP119 = SDAI.SIN(_TEMP118)
        let _TEMP120 = RMXP * _TEMP119
        let _TEMP121 = YP + _TEMP120
        let _TEMP122 = _TEMP121 - YC
        Y = _TEMP122
        
        let _TEMP123 = X ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP124 = Y ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP125 = _TEMP123 + _TEMP124
        let _TEMP126 = SDAI.SQRT(_TEMP125)
        R1 = _TEMP126
        
        let _TEMP127 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
        let _TEMP128 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
        let _TEMP129 = _TEMP127 && _TEMP128
        IN1 = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP129)
        
        let _TEMP130 = R1 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP130 ) {
          
          let _TEMP131 = ATAN2(Y: Y, 
                               X: X)
          A1 = _TEMP131
        }
        
        let _TEMP132 = AITP?.MAX
        let _TEMP133 = SDAI.COS(_TEMP132)
        let _TEMP134 = RMNP * _TEMP133
        let _TEMP135 = XP + _TEMP134
        let _TEMP136 = _TEMP135 - XC
        X = _TEMP136
        
        let _TEMP137 = AITP?.MAX
        let _TEMP138 = SDAI.SIN(_TEMP137)
        let _TEMP139 = RMNP * _TEMP138
        let _TEMP140 = YP + _TEMP139
        let _TEMP141 = _TEMP140 - YC
        Y = _TEMP141
        
        let _TEMP142 = X ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP143 = Y ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP144 = _TEMP142 + _TEMP143
        let _TEMP145 = SDAI.SQRT(_TEMP144)
        R2 = _TEMP145
        
        let _TEMP146 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
        let _TEMP147 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
        let _TEMP148 = _TEMP146 && _TEMP147
        IN2 = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP148)
        
        let _TEMP149 = R2 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP149 ) {
          
          let _TEMP150 = ATAN2(Y: Y, 
                               X: X)
          A2 = _TEMP150
        }
        else {
          A2 = A1
          IN2 = IN1
        }
        
        let _TEMP151 = R1 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP151 ) {
          A1 = A2
          IN1 = IN2
        }
        
        let _TEMP152 = AITP?.MIN
        let _TEMP153 = SDAI.COS(_TEMP152)
        let _TEMP154 = RMNP * _TEMP153
        let _TEMP155 = XP + _TEMP154
        let _TEMP156 = _TEMP155 - XC
        X = _TEMP156
        
        let _TEMP157 = AITP?.MIN
        let _TEMP158 = SDAI.SIN(_TEMP157)
        let _TEMP159 = RMNP * _TEMP158
        let _TEMP160 = YP + _TEMP159
        let _TEMP161 = _TEMP160 - YC
        Y = _TEMP161
        
        let _TEMP162 = X ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP163 = Y ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP164 = _TEMP162 + _TEMP163
        let _TEMP165 = SDAI.SQRT(_TEMP164)
        R3 = _TEMP165
        
        let _TEMP166 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
        let _TEMP167 = MIN_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
        let _TEMP168 = _TEMP166 && _TEMP167
        IN3 = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP168)
        
        let _TEMP169 = R3 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP169 ) {
          
          let _TEMP170 = ATAN2(Y: Y, 
                               X: X)
          A3 = _TEMP170
        }
        else {
          A3 = A0
          IN3 = IN0
        }
        
        let _TEMP171 = R0 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP171 ) {
          A0 = A3
          IN0 = IN3
        }
        
        let _TEMP172 = RMNP .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP172 ) {
          
          let _TEMP173 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
          IN2 = _TEMP173
          IN3 = IN2
        }
        
        let _TEMP174 = AITP?.MIN
        let _TEMP175 = ANGLE(_TEMP174)
        let _TEMP176 = APC .==. _TEMP175
        let _TEMP177 = AITP?.MIN
        let _TEMP178 = ANGLE(_TEMP177)
        let _TEMP179 = ACP .==. _TEMP178
        let _TEMP180 = _TEMP176 || _TEMP179
        if SDAI.IS_TRUE( _TEMP180 ) {
          
          let _TEMP181 = MIN_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
          IN0 = _TEMP181
          IN3 = IN0
        }
        else {
          
          let _TEMP182 = AITP?.MAX
          let _TEMP183 = ANGLE(_TEMP182)
          let _TEMP184 = APC .==. _TEMP183
          let _TEMP185 = AITP?.MAX
          let _TEMP186 = ANGLE(_TEMP185)
          let _TEMP187 = ACP .==. _TEMP186
          let _TEMP188 = _TEMP184 || _TEMP187
          if SDAI.IS_TRUE( _TEMP188 ) {
            
            let _TEMP189 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
            IN1 = _TEMP189
            IN2 = IN1
          }
        }
        
        let _TEMP190 = STRICTLY_IN(A: ACP, 
                                   AITV: AITP)
        if SDAI.IS_TRUE( _TEMP190 ) {
          
          let _TEMP191 = RC + RMXP
          RMAX = _TEMP191
          
          let _TEMP192 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
          RMAX_IN = _TEMP192
        }
        else {
          RMAX = R0
          RMAX_IN = IN0
          
          let _TEMP193 = RMAX .==. R1
          if SDAI.IS_TRUE( _TEMP193 ) {
            
            let _TEMP194 = RMAX_IN || IN1
            RMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP194)
          }
          
          let _TEMP195 = RMAX < R1
          if SDAI.IS_TRUE( _TEMP195 ) {
            RMAX = R1
            RMAX_IN = IN1
          }
          
          let _TEMP196 = RMAX .==. R2
          if SDAI.IS_TRUE( _TEMP196 ) {
            
            let _TEMP197 = RMAX_IN || IN2
            RMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP197)
          }
          
          let _TEMP198 = RMAX < R2
          if SDAI.IS_TRUE( _TEMP198 ) {
            RMAX = R2
            RMAX_IN = IN2
          }
          
          let _TEMP199 = RMAX .==. R3
          if SDAI.IS_TRUE( _TEMP199 ) {
            
            let _TEMP200 = RMAX_IN || IN3
            RMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP200)
          }
          
          let _TEMP201 = RMAX < R3
          if SDAI.IS_TRUE( _TEMP201 ) {
            RMAX = R3
            RMAX_IN = IN3
          }
        }
        
        let _TEMP202 = STRICTLY_IN(A: APC, 
                                   AITV: AITP)
        if SDAI.IS_TRUE( _TEMP202 ) {
          
          let _TEMP203 = RC >= RMXP
          if SDAI.IS_TRUE( _TEMP203 ) {
            
            let _TEMP204 = RC - RMXP
            RMIN = _TEMP204
            
            let _TEMP205 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
            RMIN_IN = _TEMP205
          }
          else {
            
            let _TEMP206 = RC <= RMNP
            if SDAI.IS_TRUE( _TEMP206 ) {
              
              let _TEMP207 = RMNP - RC
              RMIN = _TEMP207
              
              let _TEMP208 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
              RMIN_IN = _TEMP208
            }
            else {
              RMIN = SDAI.REAL(0)
              RMIN_IN = SDAI.BOOLEAN(SDAI.TRUE)
            }
          }
        }
        else {
          RMIN = R0
          RMIN_IN = IN0
          
          let _TEMP209 = AITP?.MIN
          let _TEMP210 = APC - _TEMP209
          A = _TEMP210
          
          let _TEMP211 = SDAI.COS(A)
          let _TEMP212 = RC * _TEMP211
          R = _TEMP212
          
          let _TEMP213 = RMNP < R
          let _TEMP214 = R < RMXP
          let _TEMP215 = _TEMP213 && _TEMP214
          if SDAI.IS_TRUE( _TEMP215 ) {
            
            let _TEMP216 = SDAI.ABS(A)
            let _TEMP217 = SDAI.SIN(_TEMP216)
            let _TEMP218 = RC * _TEMP217
            RMIN = _TEMP218
            
            let _TEMP219 = MIN_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
            RMIN_IN = _TEMP219
          }
          
          let _TEMP220 = AITP?.MAX
          let _TEMP221 = APC - _TEMP220
          A = _TEMP221
          
          let _TEMP222 = SDAI.COS(A)
          let _TEMP223 = RC * _TEMP222
          R = _TEMP223
          
          let _TEMP224 = RMNP < R
          let _TEMP225 = R < RMXP
          let _TEMP226 = _TEMP224 && _TEMP225
          if SDAI.IS_TRUE( _TEMP226 ) {
            
            let _TEMP227 = SDAI.ABS(A)
            let _TEMP228 = SDAI.SIN(_TEMP227)
            let _TEMP229 = RC * _TEMP228
            R = _TEMP229
            
            let _TEMP230 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
            INN = _TEMP230
            
            let _TEMP231 = R .==. RMIN
            if SDAI.IS_TRUE( _TEMP231 ) {
              
              let _TEMP232 = RMIN_IN || INN
              RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP232)
            }
            
            let _TEMP233 = R < RMIN
            if SDAI.IS_TRUE( _TEMP233 ) {
              RMIN = R
              RMIN_IN = INN
            }
          }
          
          let _TEMP234 = R1 .==. RMIN
          if SDAI.IS_TRUE( _TEMP234 ) {
            
            let _TEMP235 = RMIN_IN || IN1
            RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP235)
          }
          
          let _TEMP236 = R1 < RMIN
          if SDAI.IS_TRUE( _TEMP236 ) {
            RMIN = R1
            RMIN_IN = IN1
          }
          
          let _TEMP237 = R2 .==. RMIN
          if SDAI.IS_TRUE( _TEMP237 ) {
            
            let _TEMP238 = RMIN_IN || IN2
            RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP238)
          }
          
          let _TEMP239 = R2 < RMIN
          if SDAI.IS_TRUE( _TEMP239 ) {
            RMIN = R2
            RMIN_IN = IN2
          }
          
          let _TEMP240 = R3 .==. RMIN
          if SDAI.IS_TRUE( _TEMP240 ) {
            
            let _TEMP241 = RMIN_IN || IN3
            RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP241)
          }
          
          let _TEMP242 = R3 < RMIN
          if SDAI.IS_TRUE( _TEMP242 ) {
            RMIN = R3
            RMIN_IN = IN3
          }
        }
        
        let _TEMP243 = RC >= RMXP
        if SDAI.IS_TRUE( _TEMP243 ) {
          AB = ACP
          FIND_AMINMAX( AB: AB, A0: A0, A1: A1, A2: A2, A3: A3, IN0: IN0, 
            IN1: IN1, IN2: IN2, IN3: IN3, AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, 
            AMAX_IN: &AMAX_IN )
          
          let _TEMP244 = RMXP / RC
          let _TEMP245 = SDAI.ACOS(_TEMP244)
          A = _TEMP245
          
          let _TEMP246 = APC - A
          let _TEMP247 = STRICTLY_IN(
            A: _TEMP246, AITV: AITP)
          if SDAI.IS_TRUE( _TEMP247 ) {
            
            let _TEMP248 = RMXP / RC
            let _TEMP249 = SDAI.ASIN(_TEMP248)
            let _TEMP250 = AB - _TEMP249
            AMIN = _TEMP250
            
            let _TEMP251 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
            AMIN_IN = _TEMP251
          }
          
          let _TEMP252 = APC + A
          let _TEMP253 = STRICTLY_IN(
            A: _TEMP252, AITV: AITP)
          if SDAI.IS_TRUE( _TEMP253 ) {
            
            let _TEMP254 = RMXP / RC
            let _TEMP255 = SDAI.ASIN(_TEMP254)
            let _TEMP256 = AB + _TEMP255
            AMAX = _TEMP256
            
            let _TEMP257 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
            AMAX_IN = _TEMP257
          }
          ANGLE_RANGE( AMIN: &AMIN, AMAX: &AMAX )
        }
        else {
          
          let _TEMP258 = RC > RMNP
          if SDAI.IS_TRUE( _TEMP258 ) {
            
            let _TEMP259 = AITP?.MIN
            let _TEMP260 = AITP?.MAX
            let _TEMP261 = _TEMP259 + _TEMP260
            let _TEMP262 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP261
            let _TEMP263 = ANGLE(_TEMP262)
            AB = _TEMP263
            FIND_AMINMAX( AB: AB, A0: A0, A1: A1, A2: A2, A3: A3, IN0: IN0, 
              IN1: IN1, IN2: IN2, IN3: IN3, AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, 
              AMAX_IN: &AMAX_IN )
          }
          else {
            
            let _TEMP264 = AITP?.MIN
            let _TEMP265 = AITP?.MAX
            let _TEMP266 = _TEMP264 + _TEMP265
            let _TEMP267 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP266
            let _TEMP268 = ANGLE(_TEMP267)
            AB = _TEMP268
            
            let _TEMP269 = A0 - AB
            let _TEMP270 = ANGLE(_TEMP269)
            A0 = _TEMP270
            
            let _TEMP271 = A1 - AB
            let _TEMP272 = ANGLE(_TEMP271)
            A1 = _TEMP272
            
            let _TEMP273 = A2 - AB
            let _TEMP274 = ANGLE(_TEMP273)
            A2 = _TEMP274
            
            let _TEMP275 = A3 - AB
            let _TEMP276 = ANGLE(_TEMP275)
            A3 = _TEMP276
            
            let _TEMP277 = A3 > A2
            if SDAI.IS_TRUE( _TEMP277 ) {
              
              let _TEMP278 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
              let _TEMP279 = A2 + SDAI.FORCE_OPTIONAL(_TEMP278)
              A2 = _TEMP279
            }
            
            let _TEMP280 = A0 > A1
            if SDAI.IS_TRUE( _TEMP280 ) {
              
              let _TEMP281 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
              let _TEMP282 = A0 + SDAI.FORCE_OPTIONAL(_TEMP281)
              A0 = _TEMP282
            }
            
            let _TEMP283 = A3 < A0
            if SDAI.IS_TRUE( _TEMP283 ) {
              AMIN = A3
              AMIN_IN = IN3
            }
            else {
              AMIN = A0
              AMIN_IN = IN0
            }
            
            let _TEMP284 = A2 > A1
            if SDAI.IS_TRUE( _TEMP284 ) {
              AMAX = A2
              AMAX_IN = IN2
            }
            else {
              AMAX = A1
              AMAX_IN = IN1
            }
            
            let _TEMP285 = AMAX - AMIN
            let _TEMP286 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
            let _TEMP287 = _TEMP285 > SDAI.FORCE_OPTIONAL(_TEMP286)
            let _TEMP288 = AMAX - AMIN
            let _TEMP289 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
            let _TEMP290 = _TEMP288 .==. SDAI.FORCE_OPTIONAL(_TEMP289)
            let _TEMP291 = AMIN_IN || AMAX_IN
            let _TEMP292 = _TEMP290 && _TEMP291
            let _TEMP293 = _TEMP287 || _TEMP292
            if SDAI.IS_TRUE( _TEMP293 ) {
              AMIN = SDAI.REAL( -SDAI.PI)
              AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
              AMAX = SDAI.REAL(SDAI.PI)
              AMAX_IN = SDAI.BOOLEAN(SDAI.TRUE)
            }
            else {
              
              let _TEMP294 = AMIN + AB
              AMIN = _TEMP294
              
              let _TEMP295 = AMAX + AB
              AMAX = _TEMP295
              ANGLE_RANGE( AMIN: &AMIN, AMAX: &AMAX )
            }
          }
        }
      }
      if SDAI.IS_TRUE( RMIN_IN ) {
        MINCLO = CLOSED
      }
      if SDAI.IS_TRUE( RMAX_IN ) {
        MAXCLO = CLOSED
      }
      
      let _TEMP296 = MAKE_FINITE_REAL_INTERVAL(
        MIN: RMIN, MINCLO: MINCLO, MAX: RMAX, 
        MAXCLO: MAXCLO)
      RITV = sREAL_INTERVAL(/*eFINITE_REAL_INTERVAL*/_TEMP296)
    }
    else {
      
      let _TEMP297 = RC > RMNP
      let _TEMP298 = STRICTLY_IN(A: APC, 
                                 AITV: AITP)
      let _TEMP299 = _TEMP297 && _TEMP298
      if SDAI.IS_TRUE( _TEMP299 ) {
        return _enclose_pregion_in_pregion__cache.updateCache(params: _params, value: (nil as 
          ePOLAR_COMPLEX_NUMBER_REGION?))
      }
      
      let _TEMP300 = AITP?.MAX
      let _TEMP301 = AITP?.MIN
      let _TEMP302 = _TEMP300 - _TEMP301
      let _TEMP303 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
      let _TEMP304 = _TEMP302 .==. SDAI.FORCE_OPTIONAL(_TEMP303)
      if SDAI.IS_TRUE( _TEMP304 ) {
        
        let _TEMP305 = AITP?.MIN
        let _TEMP306 = ANGLE(_TEMP305)
        A = _TEMP306
        
        let _TEMP307 = RC > RMNP
        if SDAI.IS_TRUE( _TEMP307 ) {
          
          let _TEMP308 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
          if SDAI.IS_TRUE( _TEMP308 ) {
            return _enclose_pregion_in_pregion__cache.updateCache(params: _params, value: (nil as 
              ePOLAR_COMPLEX_NUMBER_REGION?))
          }
          RMIN = SDAI.REAL(0)
          RMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
          
          let _TEMP309 = AITP?.MIN
          AMIN = _TEMP309
          AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
          
          let _TEMP310 = AITP?.MAX
          AMAX = _TEMP310
          AMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
        }
        else {
          
          let _TEMP311 = RMNP - RC
          RMIN = _TEMP311
          
          let _TEMP312 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
          RMIN_IN = _TEMP312
          AMIN = SDAI.REAL( -SDAI.PI)
          AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
          AMAX = SDAI.REAL(SDAI.PI)
          AMAX_IN = SDAI.BOOLEAN(SDAI.TRUE)
          
          let _TEMP313 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
          let _TEMP314 =  !_TEMP313
          if SDAI.IS_TRUE( _TEMP314 ) {
            
            let _TEMP315 = APC .==. A
            if SDAI.IS_TRUE( _TEMP315 ) {
              RMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
              
              let _TEMP316 = AITP?.MIN
              AMIN = _TEMP316
              AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
              
              let _TEMP317 = AITP?.MAX
              AMAX = _TEMP317
              AMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
            }
            else {
              
              let _TEMP318 = ACP .==. A
              if SDAI.IS_TRUE( _TEMP318 ) {
                
                let _TEMP319 = AITP?.MIN
                AMIN = _TEMP319
                AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
                
                let _TEMP320 = AITP?.MAX
                AMAX = _TEMP320
                AMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
              }
            }
          }
        }
      }
      else {
        
        let _TEMP321 = AITP?.MIN
        let _TEMP322 = ANGLE(_TEMP321)
        A0 = _TEMP322
        IN0 = SDAI.BOOLEAN(SDAI.FALSE)
        
        let _TEMP323 = AITP?.MAX
        let _TEMP324 = ANGLE(_TEMP323)
        A1 = _TEMP324
        IN1 = SDAI.BOOLEAN(SDAI.FALSE)
        
        let _TEMP325 = AITP?.MAX
        let _TEMP326 = SDAI.COS(_TEMP325)
        let _TEMP327 = RMNP * _TEMP326
        let _TEMP328 = XP + _TEMP327
        let _TEMP329 = _TEMP328 - XC
        X = _TEMP329
        
        let _TEMP330 = AITP?.MAX
        let _TEMP331 = SDAI.SIN(_TEMP330)
        let _TEMP332 = RMNP * _TEMP331
        let _TEMP333 = YP + _TEMP332
        let _TEMP334 = _TEMP333 - YC
        Y = _TEMP334
        
        let _TEMP335 = X ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP336 = Y ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP337 = _TEMP335 + _TEMP336
        let _TEMP338 = SDAI.SQRT(_TEMP337)
        R2 = _TEMP338
        
        let _TEMP339 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
        let _TEMP340 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
        let _TEMP341 = _TEMP339 && _TEMP340
        IN2 = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP341)
        
        let _TEMP342 = R2 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP342 ) {
          
          let _TEMP343 = ATAN2(Y: Y, 
                               X: X)
          A2 = _TEMP343
        }
        else {
          A2 = A1
          IN2 = IN1
        }
        
        let _TEMP344 = AITP?.MIN
        let _TEMP345 = SDAI.COS(_TEMP344)
        let _TEMP346 = RMNP * _TEMP345
        let _TEMP347 = XP + _TEMP346
        let _TEMP348 = _TEMP347 - XC
        X = _TEMP348
        
        let _TEMP349 = AITP?.MIN
        let _TEMP350 = SDAI.SIN(_TEMP349)
        let _TEMP351 = RMNP * _TEMP350
        let _TEMP352 = YP + _TEMP351
        let _TEMP353 = _TEMP352 - YC
        Y = _TEMP353
        
        let _TEMP354 = X ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP355 = Y ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP356 = _TEMP354 + _TEMP355
        let _TEMP357 = SDAI.SQRT(_TEMP356)
        R3 = _TEMP357
        
        let _TEMP358 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
        let _TEMP359 = MIN_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
        let _TEMP360 = _TEMP358 && _TEMP359
        IN3 = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP360)
        
        let _TEMP361 = R3 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP361 ) {
          
          let _TEMP362 = ATAN2(Y: Y, 
                               X: X)
          A3 = _TEMP362
        }
        else {
          A3 = A0
          IN3 = IN0
        }
        
        let _TEMP363 = RMNP .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP363 ) {
          
          let _TEMP364 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
          IN2 = _TEMP364
          IN3 = IN2
        }
        
        let _TEMP365 = AITP?.MIN
        let _TEMP366 = ANGLE(_TEMP365)
        let _TEMP367 = APC .==. _TEMP366
        let _TEMP368 = AITP?.MIN
        let _TEMP369 = ANGLE(_TEMP368)
        let _TEMP370 = ACP .==. _TEMP369
        let _TEMP371 = _TEMP367 || _TEMP370
        if SDAI.IS_TRUE( _TEMP371 ) {
          
          let _TEMP372 = MIN_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
          IN0 = _TEMP372
          IN3 = IN0
        }
        else {
          
          let _TEMP373 = AITP?.MAX
          let _TEMP374 = ANGLE(_TEMP373)
          let _TEMP375 = APC .==. _TEMP374
          let _TEMP376 = AITP?.MAX
          let _TEMP377 = ANGLE(_TEMP376)
          let _TEMP378 = ACP .==. _TEMP377
          let _TEMP379 = _TEMP375 || _TEMP378
          if SDAI.IS_TRUE( _TEMP379 ) {
            
            let _TEMP380 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
            IN1 = _TEMP380
            IN2 = IN1
          }
        }
        
        let _TEMP381 = STRICTLY_IN(A: APC, 
                                   AITV: AITP)
        if SDAI.IS_TRUE( _TEMP381 ) {
          
          let _TEMP382 = RMNP - RC
          RMIN = _TEMP382
          
          let _TEMP383 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITP))
          RMIN_IN = _TEMP383
        }
        else {
          RMIN = R2
          RMIN_IN = IN2
          
          let _TEMP384 = AITP?.MIN
          let _TEMP385 = APC - _TEMP384
          A = _TEMP385
          
          let _TEMP386 = SDAI.COS(A)
          let _TEMP387 = RC * _TEMP386
          R = _TEMP387
          
          let _TEMP388 = RMNP < R
          if SDAI.IS_TRUE( _TEMP388 ) {
            
            let _TEMP389 = SDAI.ABS(A)
            let _TEMP390 = SDAI.SIN(_TEMP389)
            let _TEMP391 = RC * _TEMP390
            RMIN = _TEMP391
            
            let _TEMP392 = MIN_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
            RMIN_IN = _TEMP392
          }
          
          let _TEMP393 = AITP?.MAX
          let _TEMP394 = APC - _TEMP393
          A = _TEMP394
          
          let _TEMP395 = SDAI.COS(A)
          let _TEMP396 = RC * _TEMP395
          R = _TEMP396
          
          let _TEMP397 = RMNP < R
          if SDAI.IS_TRUE( _TEMP397 ) {
            
            let _TEMP398 = SDAI.ABS(A)
            let _TEMP399 = SDAI.SIN(_TEMP398)
            let _TEMP400 = RC * _TEMP399
            R = _TEMP400
            
            let _TEMP401 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITP))
            INN = _TEMP401
            
            let _TEMP402 = R .==. RMIN
            if SDAI.IS_TRUE( _TEMP402 ) {
              
              let _TEMP403 = RMIN_IN || INN
              RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP403)
            }
            
            let _TEMP404 = R < RMIN
            if SDAI.IS_TRUE( _TEMP404 ) {
              RMIN = R
              RMIN_IN = INN
            }
          }
          
          let _TEMP405 = R3 .==. RMIN
          if SDAI.IS_TRUE( _TEMP405 ) {
            
            let _TEMP406 = RMIN_IN || IN3
            RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP406)
          }
          
          let _TEMP407 = R3 < RMIN
          if SDAI.IS_TRUE( _TEMP407 ) {
            RMIN = R3
            RMIN_IN = IN3
          }
        }
        
        let _TEMP408 = AITP?.MIN
        let _TEMP409 = AITP?.MAX
        let _TEMP410 = _TEMP408 + _TEMP409
        let _TEMP411 = SDAI.FORCE_OPTIONAL(SDAI.REAL(5.0000000000e-01)) * _TEMP410
        let _TEMP412 = ANGLE(_TEMP411)
        AB = _TEMP412
        
        let _TEMP413 = RC > RMNP
        if SDAI.IS_TRUE( _TEMP413 ) {
          FIND_AMINMAX( AB: AB, A0: A0, A1: A1, A2: A2, A3: A3, IN0: IN0, 
            IN1: IN1, IN2: IN2, IN3: IN3, AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, 
            AMAX_IN: &AMAX_IN )
        }
        else {
          
          let _TEMP414 = A0 - AB
          let _TEMP415 = ANGLE(_TEMP414)
          A0 = _TEMP415
          
          let _TEMP416 = A1 - AB
          let _TEMP417 = ANGLE(_TEMP416)
          A1 = _TEMP417
          
          let _TEMP418 = A2 - AB
          let _TEMP419 = ANGLE(_TEMP418)
          A2 = _TEMP419
          
          let _TEMP420 = A3 - AB
          let _TEMP421 = ANGLE(_TEMP420)
          A3 = _TEMP421
          
          let _TEMP422 = A3 > A2
          if SDAI.IS_TRUE( _TEMP422 ) {
            
            let _TEMP423 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
            let _TEMP424 = A2 + SDAI.FORCE_OPTIONAL(_TEMP423)
            A2 = _TEMP424
          }
          
          let _TEMP425 = A0 > A1
          if SDAI.IS_TRUE( _TEMP425 ) {
            
            let _TEMP426 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
            let _TEMP427 = A0 + SDAI.FORCE_OPTIONAL(_TEMP426)
            A0 = _TEMP427
          }
          
          let _TEMP428 = A3 < A0
          if SDAI.IS_TRUE( _TEMP428 ) {
            AMIN = A3
            AMIN_IN = IN3
          }
          else {
            AMIN = A0
            AMIN_IN = IN0
          }
          
          let _TEMP429 = A2 > A1
          if SDAI.IS_TRUE( _TEMP429 ) {
            AMAX = A2
            AMAX_IN = IN2
          }
          else {
            AMAX = A1
            AMAX_IN = IN1
          }
          
          let _TEMP430 = AMAX - AMIN
          let _TEMP431 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
          let _TEMP432 = _TEMP430 > SDAI.FORCE_OPTIONAL(_TEMP431)
          let _TEMP433 = AMAX - AMIN
          let _TEMP434 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
          let _TEMP435 = _TEMP433 .==. SDAI.FORCE_OPTIONAL(_TEMP434)
          let _TEMP436 = AMIN_IN || AMAX_IN
          let _TEMP437 = _TEMP435 && _TEMP436
          let _TEMP438 = _TEMP432 || _TEMP437
          if SDAI.IS_TRUE( _TEMP438 ) {
            AMIN = SDAI.REAL( -SDAI.PI)
            AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
            AMAX = SDAI.REAL(SDAI.PI)
            AMAX_IN = SDAI.BOOLEAN(SDAI.TRUE)
            
            let _TEMP439 = RMIN .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
            let _TEMP440 = _TEMP439 && RMIN_IN
            if SDAI.IS_TRUE( _TEMP440 ) {
              return _enclose_pregion_in_pregion__cache.updateCache(params: _params, value: (nil as 
                ePOLAR_COMPLEX_NUMBER_REGION?))
            }
          }
          else {
            
            let _TEMP441 = AMIN + AB
            AMIN = _TEMP441
            
            let _TEMP442 = AMAX + AB
            AMAX = _TEMP442
            ANGLE_RANGE( AMIN: &AMIN, AMAX: &AMAX )
          }
        }
      }
      if SDAI.IS_TRUE( RMIN_IN ) {
        MINCLO = CLOSED
      }
      
      let _TEMP443 = MAKE_REAL_INTERVAL_FROM_MIN(
        MIN: RMIN, MINCLO: MINCLO)
      RITV = sREAL_INTERVAL(/*eREAL_INTERVAL_FROM_MIN*/_TEMP443)
    }
    MINCLO = OPEN
    MAXCLO = OPEN
    if SDAI.IS_TRUE( AMIN_IN ) {
      MINCLO = CLOSED
    }
    if SDAI.IS_TRUE( AMAX_IN ) {
      MAXCLO = CLOSED
    }
    
    let _TEMP444 = MAKE_FINITE_REAL_INTERVAL(
      MIN: AMIN, MINCLO: MINCLO, MAX: AMAX, 
      MAXCLO: MAXCLO)
    AITV = _TEMP444
    
    let _TEMP445 = MAKE_POLAR_COMPLEX_NUMBER_REGION(
      CENTRE: CENTRE, DIS_CONSTRAINT: RITV, 
      DIR_CONSTRAINT: AITV)
    return _enclose_pregion_in_pregion__cache.updateCache(params: _params, value: _TEMP445)
  }

}

//MARK: - function result cache
private var _enclose_pregion_in_pregion__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

