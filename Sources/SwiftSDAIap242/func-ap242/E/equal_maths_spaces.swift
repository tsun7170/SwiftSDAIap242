/* file: equal_maths_spaces.swift 	 generated: Tue Nov 16 05:35:44 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION equal_maths_spaces(
               spc1, spc2 : maths_space
           ) : LOGICAL;

    LOCAL
      spc1types : SET OF STRING := stripped_typeof( spc1 );
      spc2types : SET OF STRING := stripped_typeof( spc2 );
      set1      : SET OF maths_value;
      set2      : SET OF maths_value;
      cum       : LOGICAL := TRUE;
      base      : maths_space;
      expnt     : INTEGER;
      factors   : LIST OF maths_space;
      factors2  : LIST OF maths_space;
      fs1       : function_space;
      fs2       : function_space;
    END_LOCAL;
    IF spc1 = spc2 THEN
      RETURN( TRUE );
    END_IF;
    IF 'FINITE_SPACE' IN spc1types THEN
      set1 := spc1\finite_space.members;
      IF 'FINITE_SPACE' IN spc2types THEN
        set2 := spc2\finite_space.members;
        REPEAT i := 1 TO SIZEOF( set1 ) BY 1;
          cum := cum AND member_of( set1[i], spc2 );
          IF cum = FALSE THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        IF cum = TRUE THEN
          REPEAT i := 1 TO SIZEOF( set2 ) BY 1;
            cum := cum AND member_of( set2[i], spc1 );
            IF cum = FALSE THEN
              RETURN( FALSE );
            END_IF;
          END_REPEAT;
        END_IF;
        RETURN( cum );
      END_IF;
      IF 'FINITE_INTEGER_INTERVAL' IN spc2types THEN
        set2 := [];
        REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max BY 1;
          set2 := set2 + [i];
        END_REPEAT;
        RETURN( equal_maths_spaces( spc1, make_finite_space( set2 ) ) );
      END_IF;
    END_IF;
    IF ( 'FINITE_INTEGER_INTERVAL' IN spc1types ) AND ( 'FINITE_SPACE' IN spc2types ) THEN
      set1 := [];
      REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max BY 1;
        set1 := set1 + [i];
      END_REPEAT;
      RETURN( equal_maths_spaces( make_finite_space( set1 ), spc2 ) );
    END_IF;
    IF ( 'CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types ) AND ( 'POLAR_COMPLEX_NUMBER_REGION' IN spc2types )
        THEN
      RETURN( equal_cregion_pregion( spc1, spc2 ) );
    END_IF;
    IF ( 'POLAR_COMPLEX_NUMBER_REGION' IN spc1types ) AND ( 'CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types )
        THEN
      RETURN( equal_cregion_pregion( spc2, spc1 ) );
    END_IF;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc1types THEN
      base := spc1\uniform_product_space.base;
      expnt := spc1\uniform_product_space.exponent;
      IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
        IF expnt <> spc2\uniform_product_space.exponent THEN
          RETURN( FALSE );
        END_IF;
        RETURN( equal_maths_spaces( base, spc2\uniform_product_space.base ) );
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
        factors := spc2\listed_product_space.factors;
        IF expnt <> SIZEOF( factors ) THEN
          RETURN( FALSE );
        END_IF;
        REPEAT i := 1 TO SIZEOF( factors ) BY 1;
          cum := cum AND equal_maths_spaces( base, factors[i] );
          IF cum = FALSE THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        RETURN( cum );
      END_IF;
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc1types THEN
      factors := spc1\listed_product_space.factors;
      IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
        IF spc2\uniform_product_space.exponent <> SIZEOF( factors ) THEN
          RETURN( FALSE );
        END_IF;
        base := spc2\uniform_product_space.base;
        REPEAT i := 1 TO SIZEOF( factors ) BY 1;
          cum := cum AND equal_maths_spaces( base, factors[i] );
          IF cum = FALSE THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        RETURN( cum );
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
        factors2 := spc2\listed_product_space.factors;
        IF SIZEOF( factors ) <> SIZEOF( factors2 ) THEN
          RETURN( FALSE );
        END_IF;
        REPEAT i := 1 TO SIZEOF( factors ) BY 1;
          cum := cum AND equal_maths_spaces( factors[i], factors2[i] );
          IF cum = FALSE THEN
            RETURN( FALSE );
          END_IF;
        END_REPEAT;
        RETURN( cum );
      END_IF;
    END_IF;
    IF ( 'EXTENDED_TUPLE_SPACE' IN spc1types ) AND ( 'EXTENDED_TUPLE_SPACE' IN spc2types ) THEN
      RETURN( equal_maths_spaces( spc1\extended_tuple_space.extender, spc2\extended_tuple_space.extender ) 
          AND equal_maths_spaces( spc1\extended_tuple_space.base, spc2\extended_tuple_space.base ) );
    END_IF;
    IF ( 'FUNCTION_SPACE' IN spc1types ) AND ( 'FUNCTION_SPACE' IN spc2types ) THEN
      fs1 := spc1;
      fs2 := spc2;
      IF fs1.domain_constraint <> fs2.domain_constraint THEN
        IF ( fs1.domain_constraint = sc_equal ) OR ( fs2.domain_constraint = sc_equal ) THEN
          RETURN( FALSE );
        END_IF;
        IF fs1.domain_constraint <> sc_subspace THEN
          fs1 := spc2;
          fs2 := spc1;
        END_IF;
        IF ( fs1.domain_constraint <> sc_subspace ) OR ( fs2.domain_constraint <> sc_member ) THEN
          RETURN( UNKNOWN );
        END_IF;
        IF any_space_satisfies( fs1.domain_constraint, fs1.domain_argument ) <> any_space_satisfies( fs2.
            domain_constraint, fs2.domain_argument ) THEN
          RETURN( FALSE );
        END_IF;
        IF NOT ( 'FINITE_SPACE' IN stripped_typeof( fs2.domain_argument ) ) THEN
          RETURN( FALSE );
        END_IF;
        IF SIZEOF( [ 'FINITE_SPACE', 'FINITE_INTEGER_INTERVAL'] * stripped_typeof( fs1.domain_argument ) ) = 
            0 THEN
          RETURN( FALSE );
        END_IF;
        RETURN( UNKNOWN );
      END_IF;
      cum := equal_maths_spaces( fs1.domain_argument, fs2.domain_argument );
      IF cum = FALSE THEN
        RETURN( FALSE );
      END_IF;
      IF fs1.range_constraint <> fs2.range_constraint THEN
        IF ( fs1.range_constraint = sc_equal ) OR ( fs2.range_constraint = sc_equal ) THEN
          RETURN( FALSE );
        END_IF;
        IF fs1.range_constraint <> sc_subspace THEN
          fs1 := spc2;
          fs2 := spc1;
        END_IF;
        IF ( fs1.range_constraint <> sc_subspace ) OR ( fs2.range_constraint <> sc_member ) THEN
          RETURN( UNKNOWN );
        END_IF;
        IF any_space_satisfies( fs1.range_constraint, fs1.range_argument ) <> any_space_satisfies( fs2.
            range_constraint, fs2.range_argument ) THEN
          RETURN( FALSE );
        END_IF;
        IF NOT ( 'FINITE_SPACE' IN stripped_typeof( fs2.range_argument ) ) THEN
          RETURN( FALSE );
        END_IF;
        IF SIZEOF( [ 'FINITE_SPACE', 'FINITE_INTEGER_INTERVAL'] * stripped_typeof( fs1.range_argument ) ) = 0
            THEN
          RETURN( FALSE );
        END_IF;
        RETURN( UNKNOWN );
      END_IF;
      cum := cum AND equal_maths_spaces( fs1.range_argument, fs2.range_argument );
      RETURN( cum );
    END_IF;
    RETURN( FALSE );

  END_FUNCTION; -- equal_maths_spaces (line:40194 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func EQUAL_MATHS_SPACES(SPC1: eMATHS_SPACE? , SPC2: eMATHS_SPACE? ) 
    -> SDAI.LOGICAL {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( SPC1, SPC2 )
    if case .available(let _cached_value) = _equal_maths_spaces__cache.cachedValue(params: _params) {
      return _cached_value as! SDAI.LOGICAL
    }

    var SPC1 = SPC1; SDAI.TOUCH(var: &SPC1)
    var SPC2 = SPC2; SDAI.TOUCH(var: &SPC2)

    //LOCAL
    var SPC1TYPES: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(SPC1); SDAI.TOUCH(var: &SPC1TYPES)
    var SPC2TYPES: SDAI.SET<SDAI.STRING>?  = STRIPPED_TYPEOF(SPC2); SDAI.TOUCH(var: &SPC2TYPES)
    var SET1: SDAI.SET<sMATHS_VALUE>? 
    var SET2: SDAI.SET<sMATHS_VALUE>? 
    var CUM: SDAI.LOGICAL = SDAI.LOGICAL(SDAI.TRUE); SDAI.TOUCH(var: &CUM)
    var BASE: eMATHS_SPACE? 
    var EXPNT: SDAI.INTEGER? 
    var FACTORS: SDAI.LIST<eMATHS_SPACE>? 
    var FACTORS2: SDAI.LIST<eMATHS_SPACE>? 
    var FS1: eFUNCTION_SPACE? 
    var FS2: eFUNCTION_SPACE? 
    //END_LOCAL

    
    let _TEMP1 = SPC1 .==. SPC2
    if SDAI.IS_TRUE( _TEMP1 ) {
      return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
        SDAI.TRUE)))
    }
    
    let _TEMP2 = SDAI.aggregate(SPC1TYPES, contains: SDAI.STRING("FINITE_SPACE"))
    if SDAI.IS_TRUE( _TEMP2 ) {
      
      let _TEMP3 = SPC1?.GROUP_REF(eFINITE_SPACE.self)
      let _TEMP4 = _TEMP3?.MEMBERS
      SET1 = _TEMP4
      
      let _TEMP5 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("FINITE_SPACE"))
      if SDAI.IS_TRUE( _TEMP5 ) {
        
        let _TEMP6 = SPC2?.GROUP_REF(eFINITE_SPACE.self)
        let _TEMP7 = _TEMP6?.MEMBERS
        SET2 = _TEMP7
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
          SDAI.SIZEOF(SET1)) {
          for I in incrementControl {
            
            let _TEMP8 = SET1?[I]
            let _TEMP9 = MEMBER_OF(VAL: _TEMP8, 
                                   SPC: SPC2)
            let _TEMP10 = CUM && _TEMP9
            CUM = SDAI.UNWRAP(_TEMP10)
            
            let _TEMP11 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
            if SDAI.IS_TRUE( _TEMP11 ) {
              return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                SDAI.FALSE)))
            }
          }
        }
        
        let _TEMP12 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.TRUE))
        if SDAI.IS_TRUE( _TEMP12 ) {
          if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
            SDAI.SIZEOF(SET2)) {
            for I in incrementControl {
              
              let _TEMP13 = SET2?[I]
              let _TEMP14 = MEMBER_OF(
                VAL: _TEMP13, SPC: SPC1)
              let _TEMP15 = CUM && _TEMP14
              CUM = SDAI.UNWRAP(_TEMP15)
              
              let _TEMP16 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
              if SDAI.IS_TRUE( _TEMP16 ) {
                return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                  SDAI.FALSE)))
              }
            }
          }
        }
        return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
      }
      
      let _TEMP17 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("FINITE_INTEGER_INTERVAL"))
      if SDAI.IS_TRUE( _TEMP17 ) {
        
        let _TEMP18 = SDAI.SET<sMATHS_VALUE>(SDAI.EMPLY_AGGREGATE)
        SET2 = _TEMP18
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SPC2?.GROUP_REF(
          eFINITE_INTEGER_INTERVAL.self)?.MIN, TO:/*SDAI.INTEGER*/SPC2?.GROUP_REF(eFINITE_INTEGER_INTERVAL.self)?
          .MAX) {
          for I in incrementControl {
            
            let _TEMP19 = ([SDAI.AIE(I)] as [SDAI.AggregationInitializerElement<SDAI.INTEGER>])
            let _TEMP20 = SDAI.SET<SDAI.INTEGER>(/*SDAI.SET<sMATHS_VALUE>*/SET2) + SDAI.FORCE_OPTIONAL(
              _TEMP19)
            SET2 = SDAI.SET<sMATHS_VALUE>(/*SDAI.SET<SDAI.INTEGER>*/_TEMP20)
          }
        }
        
        let _TEMP21 = MAKE_FINITE_SPACE(SET2)
        let _TEMP22 = EQUAL_MATHS_SPACES(
          SPC1: SPC1, SPC2: eMATHS_SPACE(/*eFINITE_SPACE*/_TEMP21))
        return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP22))
      }
    }
    
    let _TEMP23 = SDAI.aggregate(SPC1TYPES, contains: SDAI.STRING("FINITE_INTEGER_INTERVAL"))
    let _TEMP24 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("FINITE_SPACE"))
    let _TEMP25 = _TEMP23 && _TEMP24
    if SDAI.IS_TRUE( _TEMP25 ) {
      
      let _TEMP26 = SDAI.SET<sMATHS_VALUE>(SDAI.EMPLY_AGGREGATE)
      SET1 = _TEMP26
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/SPC1?.GROUP_REF(
        eFINITE_INTEGER_INTERVAL.self)?.MIN, TO:/*SDAI.INTEGER*/SPC1?.GROUP_REF(eFINITE_INTEGER_INTERVAL.self)?
        .MAX) {
        for I in incrementControl {
          
          let _TEMP27 = ([SDAI.AIE(I)] as [SDAI.AggregationInitializerElement<SDAI.INTEGER>])
          let _TEMP28 = SDAI.SET<SDAI.INTEGER>(/*SDAI.SET<sMATHS_VALUE>*/SET1) + SDAI.FORCE_OPTIONAL(_TEMP27)
          SET1 = SDAI.SET<sMATHS_VALUE>(/*SDAI.SET<SDAI.INTEGER>*/_TEMP28)
        }
      }
      
      let _TEMP29 = MAKE_FINITE_SPACE(SET1)
      let _TEMP30 = EQUAL_MATHS_SPACES(
        SPC1: eMATHS_SPACE(/*eFINITE_SPACE*/_TEMP29), 
        SPC2: SPC2)
      return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP30))
    }
    
    let _TEMP31 = SDAI.aggregate(SPC1TYPES, contains: SDAI.STRING("CARTESIAN_COMPLEX_NUMBER_REGION"))
    let _TEMP32 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("POLAR_COMPLEX_NUMBER_REGION"))
    let _TEMP33 = _TEMP31 && _TEMP32
    if SDAI.IS_TRUE( _TEMP33 ) {
      
      let _TEMP34 = EQUAL_CREGION_PREGION(
        CRGN: eCARTESIAN_COMPLEX_NUMBER_REGION(/*eMATHS_SPACE*/SPC1), 
        PRGN: ePOLAR_COMPLEX_NUMBER_REGION(/*eMATHS_SPACE*/SPC2))
      return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP34))
    }
    
    let _TEMP35 = SDAI.aggregate(SPC1TYPES, contains: SDAI.STRING("POLAR_COMPLEX_NUMBER_REGION"))
    let _TEMP36 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("CARTESIAN_COMPLEX_NUMBER_REGION"))
    let _TEMP37 = _TEMP35 && _TEMP36
    if SDAI.IS_TRUE( _TEMP37 ) {
      
      let _TEMP38 = EQUAL_CREGION_PREGION(
        CRGN: eCARTESIAN_COMPLEX_NUMBER_REGION(/*eMATHS_SPACE*/SPC2), 
        PRGN: ePOLAR_COMPLEX_NUMBER_REGION(/*eMATHS_SPACE*/SPC1))
      return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP38))
    }
    
    let _TEMP39 = SDAI.aggregate(SPC1TYPES, contains: SDAI.STRING("UNIFORM_PRODUCT_SPACE"))
    if SDAI.IS_TRUE( _TEMP39 ) {
      
      let _TEMP40 = SPC1?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
      let _TEMP41 = _TEMP40?.BASE
      BASE = _TEMP41
      
      let _TEMP42 = SPC1?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
      let _TEMP43 = _TEMP42?.EXPONENT
      EXPNT = SDAI.INTEGER(/*tPOSITIVE_INTEGER*/_TEMP43)
      
      let _TEMP44 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("UNIFORM_PRODUCT_SPACE"))
      if SDAI.IS_TRUE( _TEMP44 ) {
        
        let _TEMP45 = SPC2?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP46 = _TEMP45?.EXPONENT
        let _TEMP47 = EXPNT .!=. _TEMP46
        if SDAI.IS_TRUE( _TEMP47 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        
        let _TEMP48 = SPC2?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP49 = _TEMP48?.BASE
        let _TEMP50 = EQUAL_MATHS_SPACES(
          SPC1: BASE, SPC2: _TEMP49)
        return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP50))
      }
      
      let _TEMP51 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("LISTED_PRODUCT_SPACE"))
      if SDAI.IS_TRUE( _TEMP51 ) {
        
        let _TEMP52 = SPC2?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
        let _TEMP53 = _TEMP52?.FACTORS
        FACTORS = _TEMP53
        
        let _TEMP54 = SDAI.SIZEOF(FACTORS)
        let _TEMP55 = EXPNT .!=. _TEMP54
        if SDAI.IS_TRUE( _TEMP55 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
          SDAI.SIZEOF(FACTORS)) {
          for I in incrementControl {
            
            let _TEMP56 = FACTORS?[I]
            let _TEMP57 = EQUAL_MATHS_SPACES(
              SPC1: BASE, SPC2: _TEMP56)
            let _TEMP58 = CUM && _TEMP57
            CUM = SDAI.UNWRAP(_TEMP58)
            
            let _TEMP59 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
            if SDAI.IS_TRUE( _TEMP59 ) {
              return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                SDAI.FALSE)))
            }
          }
        }
        return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
      }
    }
    
    let _TEMP60 = SDAI.aggregate(SPC1TYPES, contains: SDAI.STRING("LISTED_PRODUCT_SPACE"))
    if SDAI.IS_TRUE( _TEMP60 ) {
      
      let _TEMP61 = SPC1?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
      let _TEMP62 = _TEMP61?.FACTORS
      FACTORS = _TEMP62
      
      let _TEMP63 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("UNIFORM_PRODUCT_SPACE"))
      if SDAI.IS_TRUE( _TEMP63 ) {
        
        let _TEMP64 = SPC2?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP65 = _TEMP64?.EXPONENT
        let _TEMP66 = SDAI.SIZEOF(FACTORS)
        let _TEMP67 = _TEMP65 .!=. _TEMP66
        if SDAI.IS_TRUE( _TEMP67 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        
        let _TEMP68 = SPC2?.GROUP_REF(eUNIFORM_PRODUCT_SPACE.self)
        let _TEMP69 = _TEMP68?.BASE
        BASE = _TEMP69
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
          SDAI.SIZEOF(FACTORS)) {
          for I in incrementControl {
            
            let _TEMP70 = FACTORS?[I]
            let _TEMP71 = EQUAL_MATHS_SPACES(
              SPC1: BASE, SPC2: _TEMP70)
            let _TEMP72 = CUM && _TEMP71
            CUM = SDAI.UNWRAP(_TEMP72)
            
            let _TEMP73 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
            if SDAI.IS_TRUE( _TEMP73 ) {
              return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                SDAI.FALSE)))
            }
          }
        }
        return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
      }
      
      let _TEMP74 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("LISTED_PRODUCT_SPACE"))
      if SDAI.IS_TRUE( _TEMP74 ) {
        
        let _TEMP75 = SPC2?.GROUP_REF(eLISTED_PRODUCT_SPACE.self)
        let _TEMP76 = _TEMP75?.FACTORS
        FACTORS2 = _TEMP76
        
        let _TEMP77 = SDAI.SIZEOF(FACTORS)
        let _TEMP78 = SDAI.SIZEOF(FACTORS2)
        let _TEMP79 = _TEMP77 .!=. _TEMP78
        if SDAI.IS_TRUE( _TEMP79 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
          SDAI.SIZEOF(FACTORS)) {
          for I in incrementControl {
            
            let _TEMP80 = FACTORS?[I]
            let _TEMP81 = FACTORS2?[I]
            let _TEMP82 = EQUAL_MATHS_SPACES(
              SPC1: _TEMP80, SPC2: _TEMP81)
            let _TEMP83 = CUM && _TEMP82
            CUM = SDAI.UNWRAP(_TEMP83)
            
            let _TEMP84 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
            if SDAI.IS_TRUE( _TEMP84 ) {
              return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
                SDAI.FALSE)))
            }
          }
        }
        return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
      }
    }
    
    let _TEMP85 = SDAI.aggregate(SPC1TYPES, contains: SDAI.STRING("EXTENDED_TUPLE_SPACE"))
    let _TEMP86 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("EXTENDED_TUPLE_SPACE"))
    let _TEMP87 = _TEMP85 && _TEMP86
    if SDAI.IS_TRUE( _TEMP87 ) {
      
      let _TEMP88 = SPC1?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
      let _TEMP89 = _TEMP88?.EXTENDER
      let _TEMP90 = SPC2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
      let _TEMP91 = _TEMP90?.EXTENDER
      let _TEMP92 = EQUAL_MATHS_SPACES(
        SPC1: _TEMP89, SPC2: _TEMP91)
      let _TEMP93 = SPC1?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
      let _TEMP94 = _TEMP93?.BASE
      let _TEMP95 = SPC2?.GROUP_REF(eEXTENDED_TUPLE_SPACE.self)
      let _TEMP96 = _TEMP95?.BASE
      let _TEMP97 = EQUAL_MATHS_SPACES(
        SPC1: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP94), 
        SPC2: eMATHS_SPACE(/*sTUPLE_SPACE*/_TEMP96))
      let _TEMP98 = _TEMP92 && _TEMP97
      return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP98))
    }
    
    let _TEMP99 = SDAI.aggregate(SPC1TYPES, contains: SDAI.STRING("FUNCTION_SPACE"))
    let _TEMP100 = SDAI.aggregate(SPC2TYPES, contains: SDAI.STRING("FUNCTION_SPACE"))
    let _TEMP101 = _TEMP99 && _TEMP100
    if SDAI.IS_TRUE( _TEMP101 ) {
      FS1 = eFUNCTION_SPACE(/*eMATHS_SPACE*/SPC1)
      FS2 = eFUNCTION_SPACE(/*eMATHS_SPACE*/SPC2)
      
      let _TEMP102 = FS1?.DOMAIN_CONSTRAINT
      let _TEMP103 = FS2?.DOMAIN_CONSTRAINT
      let _TEMP104 = _TEMP102 .!=. _TEMP103
      if SDAI.IS_TRUE( _TEMP104 ) {
        
        let _TEMP105 = FS1?.DOMAIN_CONSTRAINT
        let _TEMP106 = _TEMP105 .==. SDAI.FORCE_OPTIONAL(SC_EQUAL)
        let _TEMP107 = FS2?.DOMAIN_CONSTRAINT
        let _TEMP108 = _TEMP107 .==. SDAI.FORCE_OPTIONAL(SC_EQUAL)
        let _TEMP109 = _TEMP106 || _TEMP108
        if SDAI.IS_TRUE( _TEMP109 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        
        let _TEMP110 = FS1?.DOMAIN_CONSTRAINT
        let _TEMP111 = _TEMP110 .!=. SDAI.FORCE_OPTIONAL(SC_SUBSPACE)
        if SDAI.IS_TRUE( _TEMP111 ) {
          FS1 = eFUNCTION_SPACE(/*eMATHS_SPACE*/SPC2)
          FS2 = eFUNCTION_SPACE(/*eMATHS_SPACE*/SPC1)
        }
        
        let _TEMP112 = FS1?.DOMAIN_CONSTRAINT
        let _TEMP113 = _TEMP112 .!=. SDAI.FORCE_OPTIONAL(SC_SUBSPACE)
        let _TEMP114 = FS2?.DOMAIN_CONSTRAINT
        let _TEMP115 = _TEMP114 .!=. SDAI.FORCE_OPTIONAL(SC_MEMBER)
        let _TEMP116 = _TEMP113 || _TEMP115
        if SDAI.IS_TRUE( _TEMP116 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.UNKNOWN)))
        }
        
        let _TEMP117 = FS1?.DOMAIN_CONSTRAINT
        let _TEMP118 = FS1?.DOMAIN_ARGUMENT
        let _TEMP119 = ANY_SPACE_SATISFIES(
          SC: _TEMP117, SPC: _TEMP118)
        let _TEMP120 = FS2?.DOMAIN_CONSTRAINT
        let _TEMP121 = FS2?.DOMAIN_ARGUMENT
        let _TEMP122 = ANY_SPACE_SATISFIES(
          SC: _TEMP120, SPC: _TEMP121)
        let _TEMP123 = _TEMP119 .!=. _TEMP122
        if SDAI.IS_TRUE( _TEMP123 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        
        let _TEMP124 = FS2?.DOMAIN_ARGUMENT
        let _TEMP125 = STRIPPED_TYPEOF(_TEMP124)
        let _TEMP126 = SDAI.aggregate(_TEMP125, contains: SDAI.STRING("FINITE_SPACE"))
        let _TEMP127 =  !_TEMP126
        if SDAI.IS_TRUE( _TEMP127 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        
        let _TEMP128 = ([SDAI.AIE(SDAI.STRING("FINITE_SPACE")), 
          SDAI.AIE(SDAI.STRING("FINITE_INTEGER_INTERVAL"))] as [SDAI.AggregationInitializerElement<SDAI.STRING>])
        let _TEMP129 = FS1?.DOMAIN_ARGUMENT
        let _TEMP130 = STRIPPED_TYPEOF(_TEMP129)
        let _TEMP131 = SDAI.FORCE_OPTIONAL(_TEMP128) * _TEMP130
        let _TEMP132 = SDAI.SIZEOF(_TEMP131)
        let _TEMP133 = _TEMP132 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP133 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
          SDAI.UNKNOWN)))
      }
      
      let _TEMP134 = FS1?.DOMAIN_ARGUMENT
      let _TEMP135 = FS2?.DOMAIN_ARGUMENT
      let _TEMP136 = EQUAL_MATHS_SPACES(
        SPC1: _TEMP134, SPC2: _TEMP135)
      CUM = SDAI.UNWRAP(_TEMP136)
      
      let _TEMP137 = SDAI.FORCE_OPTIONAL(CUM) .==. SDAI.FORCE_OPTIONAL(SDAI.LOGICAL(SDAI.FALSE))
      if SDAI.IS_TRUE( _TEMP137 ) {
        return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
          SDAI.FALSE)))
      }
      
      let _TEMP138 = FS1?.RANGE_CONSTRAINT
      let _TEMP139 = FS2?.RANGE_CONSTRAINT
      let _TEMP140 = _TEMP138 .!=. _TEMP139
      if SDAI.IS_TRUE( _TEMP140 ) {
        
        let _TEMP141 = FS1?.RANGE_CONSTRAINT
        let _TEMP142 = _TEMP141 .==. SDAI.FORCE_OPTIONAL(SC_EQUAL)
        let _TEMP143 = FS2?.RANGE_CONSTRAINT
        let _TEMP144 = _TEMP143 .==. SDAI.FORCE_OPTIONAL(SC_EQUAL)
        let _TEMP145 = _TEMP142 || _TEMP144
        if SDAI.IS_TRUE( _TEMP145 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        
        let _TEMP146 = FS1?.RANGE_CONSTRAINT
        let _TEMP147 = _TEMP146 .!=. SDAI.FORCE_OPTIONAL(SC_SUBSPACE)
        if SDAI.IS_TRUE( _TEMP147 ) {
          FS1 = eFUNCTION_SPACE(/*eMATHS_SPACE*/SPC2)
          FS2 = eFUNCTION_SPACE(/*eMATHS_SPACE*/SPC1)
        }
        
        let _TEMP148 = FS1?.RANGE_CONSTRAINT
        let _TEMP149 = _TEMP148 .!=. SDAI.FORCE_OPTIONAL(SC_SUBSPACE)
        let _TEMP150 = FS2?.RANGE_CONSTRAINT
        let _TEMP151 = _TEMP150 .!=. SDAI.FORCE_OPTIONAL(SC_MEMBER)
        let _TEMP152 = _TEMP149 || _TEMP151
        if SDAI.IS_TRUE( _TEMP152 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.UNKNOWN)))
        }
        
        let _TEMP153 = FS1?.RANGE_CONSTRAINT
        let _TEMP154 = FS1?.RANGE_ARGUMENT
        let _TEMP155 = ANY_SPACE_SATISFIES(
          SC: _TEMP153, SPC: _TEMP154)
        let _TEMP156 = FS2?.RANGE_CONSTRAINT
        let _TEMP157 = FS2?.RANGE_ARGUMENT
        let _TEMP158 = ANY_SPACE_SATISFIES(
          SC: _TEMP156, SPC: _TEMP157)
        let _TEMP159 = _TEMP155 .!=. _TEMP158
        if SDAI.IS_TRUE( _TEMP159 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        
        let _TEMP160 = FS2?.RANGE_ARGUMENT
        let _TEMP161 = STRIPPED_TYPEOF(_TEMP160)
        let _TEMP162 = SDAI.aggregate(_TEMP161, contains: SDAI.STRING("FINITE_SPACE"))
        let _TEMP163 =  !_TEMP162
        if SDAI.IS_TRUE( _TEMP163 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        
        let _TEMP164 = ([SDAI.AIE(SDAI.STRING("FINITE_SPACE")), 
          SDAI.AIE(SDAI.STRING("FINITE_INTEGER_INTERVAL"))] as [SDAI.AggregationInitializerElement<SDAI.STRING>])
        let _TEMP165 = FS1?.RANGE_ARGUMENT
        let _TEMP166 = STRIPPED_TYPEOF(_TEMP165)
        let _TEMP167 = SDAI.FORCE_OPTIONAL(_TEMP164) * _TEMP166
        let _TEMP168 = SDAI.SIZEOF(_TEMP167)
        let _TEMP169 = _TEMP168 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
        if SDAI.IS_TRUE( _TEMP169 ) {
          return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
            SDAI.FALSE)))
        }
        return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
          SDAI.UNKNOWN)))
      }
      
      let _TEMP170 = FS1?.RANGE_ARGUMENT
      let _TEMP171 = FS2?.RANGE_ARGUMENT
      let _TEMP172 = EQUAL_MATHS_SPACES(
        SPC1: _TEMP170, SPC2: _TEMP171)
      let _TEMP173 = CUM && _TEMP172
      CUM = SDAI.UNWRAP(_TEMP173)
      return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(CUM))
    }
    return _equal_maths_spaces__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(SDAI.FALSE)))
  }

}

//MARK: - function result cache
private var _equal_maths_spaces__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

