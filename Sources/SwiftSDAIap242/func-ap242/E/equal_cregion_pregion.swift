/* file: equal_cregion_pregion.swift 	 generated: Sun Oct 31 15:32:10 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION equal_cregion_pregion(
               crgn : cartesian_complex_number_region;
               prgn : polar_complex_number_region
           ) : LOGICAL;

    LOCAL
      arng : REAL;
      amin : REAL;
      xc   : REAL;
      yc   : REAL;
      aitv : real_interval;
      xitv : real_interval;
      yitv : real_interval;
      c_in : BOOLEAN;
    END_LOCAL;
    IF ( NOT EXISTS( crgn ) ) OR ( NOT EXISTS( prgn ) ) THEN
      RETURN( FALSE );
    END_IF;
    IF max_exists( prgn.distance_constraint ) THEN
      RETURN( FALSE );
    END_IF;
    IF real_min( prgn.distance_constraint ) <> 0 THEN
      RETURN( FALSE );
    END_IF;
    c_in := min_included( prgn.distance_constraint );
    aitv := prgn.direction_constraint;
    amin := aitv.min;
    arng := aitv.max - amin;
    xc := prgn.centre.real_part;
    yc := prgn.centre.imag_part;
    xitv := crgn.real_constraint;
    yitv := crgn.imag_constraint;
    IF arng = ( 0.5 * PI ) THEN
      IF amin = 0 THEN
        RETURN( ( NOT max_exists( xitv ) ) AND ( NOT max_exists( yitv ) ) AND min_exists( xitv ) AND 
            min_exists( yitv ) AND ( real_min( xitv ) = xc ) AND ( real_min( yitv ) = yc ) AND ( ( c_in AND 
            min_included( aitv ) AND max_included( aitv ) AND min_included( xitv ) AND min_included( yitv ) ) 
            OR ( ( NOT c_in ) AND ( NOT min_included( aitv ) ) AND max_included( aitv ) AND min_included( 
            xitv ) AND ( NOT min_included( yitv ) ) ) OR ( ( NOT c_in ) AND min_included( aitv ) AND ( NOT 
            max_included( aitv ) ) AND ( NOT min_included( xitv ) ) AND min_included( yitv ) ) OR ( ( NOT 
            c_in ) AND ( NOT min_included( aitv ) ) AND ( NOT max_included( aitv ) ) AND ( NOT min_included( 
            xitv ) ) AND ( NOT min_included( yitv ) ) ) ) );
      END_IF;
      IF amin = ( 0.5 * PI ) THEN
        RETURN( max_exists( xitv ) AND ( NOT max_exists( yitv ) ) AND ( NOT min_exists( xitv ) ) AND 
            min_exists( yitv ) AND ( real_max( xitv ) = xc ) AND ( real_min( yitv ) = yc ) AND ( ( c_in AND 
            min_included( aitv ) AND max_included( aitv ) AND max_included( xitv ) AND min_included( yitv ) ) 
            OR ( ( NOT c_in ) AND ( NOT min_included( aitv ) ) AND max_included( aitv ) AND max_included( 
            xitv ) AND ( NOT min_included( yitv ) ) ) OR ( ( NOT c_in ) AND min_included( aitv ) AND ( NOT 
            max_included( aitv ) ) AND ( NOT max_included( xitv ) ) AND min_included( yitv ) ) OR ( ( NOT 
            c_in ) AND ( NOT min_included( aitv ) ) AND ( NOT max_included( aitv ) ) AND ( NOT max_included( 
            xitv ) ) AND ( NOT min_included( yitv ) ) ) ) );
      END_IF;
      IF amin = ( -PI ) THEN
        RETURN( max_exists( xitv ) AND max_exists( yitv ) AND ( NOT min_exists( xitv ) ) AND ( NOT 
            min_exists( yitv ) ) AND ( real_max( xitv ) = xc ) AND ( real_max( yitv ) = yc ) AND ( ( c_in AND
            min_included( aitv ) AND max_included( aitv ) AND max_included( xitv ) AND max_included( yitv ) ) 
            OR ( ( NOT c_in ) AND ( NOT min_included( aitv ) ) AND max_included( aitv ) AND max_included( 
            xitv ) AND ( NOT max_included( yitv ) ) ) OR ( ( NOT c_in ) AND min_included( aitv ) AND ( NOT 
            max_included( aitv ) ) AND ( NOT max_included( xitv ) ) AND max_included( yitv ) ) OR ( ( NOT 
            c_in ) AND ( NOT min_included( aitv ) ) AND ( NOT max_included( aitv ) ) AND ( NOT max_included( 
            xitv ) ) AND ( NOT max_included( yitv ) ) ) ) );
      END_IF;
      IF amin = ( ( -0.5 ) * PI ) THEN
        RETURN( ( NOT max_exists( xitv ) ) AND max_exists( yitv ) AND min_exists( xitv ) AND ( NOT 
            min_exists( yitv ) ) AND ( real_min( xitv ) = xc ) AND ( real_max( yitv ) = yc ) AND ( ( c_in AND
            min_included( aitv ) AND max_included( aitv ) AND min_included( xitv ) AND max_included( yitv ) ) 
            OR ( ( NOT c_in ) AND ( NOT min_included( aitv ) ) AND max_included( aitv ) AND min_included( 
            xitv ) AND ( NOT max_included( yitv ) ) ) OR ( ( NOT c_in ) AND min_included( aitv ) AND ( NOT 
            max_included( aitv ) ) AND ( NOT min_included( xitv ) ) AND max_included( yitv ) ) OR ( ( NOT 
            c_in ) AND ( NOT min_included( aitv ) ) AND ( NOT max_included( aitv ) ) AND ( NOT min_included( 
            xitv ) ) AND ( NOT max_included( yitv ) ) ) ) );
      END_IF;
    END_IF;
    IF arng = PI THEN
      IF amin = 0 THEN
        RETURN( ( NOT max_exists( xitv ) ) AND ( NOT max_exists( yitv ) ) AND ( NOT min_exists( xitv ) ) AND 
            min_exists( yitv ) AND ( real_min( yitv ) = yc ) AND ( ( c_in AND min_included( aitv ) AND 
            max_included( aitv ) AND min_included( yitv ) ) OR ( ( NOT c_in ) AND ( NOT min_included( aitv ) ) 
            AND ( NOT max_included( aitv ) ) AND ( NOT min_included( yitv ) ) ) ) );
      END_IF;
      IF amin = ( 0.5 * PI ) THEN
        RETURN( max_exists( xitv ) AND ( NOT max_exists( yitv ) ) AND ( NOT min_exists( xitv ) ) AND ( NOT 
            min_exists( yitv ) ) AND ( real_max( xitv ) = xc ) AND ( ( c_in AND min_included( aitv ) AND 
            max_included( aitv ) AND max_included( xitv ) ) OR ( ( NOT c_in ) AND ( NOT min_included( aitv ) ) 
            AND ( NOT max_included( aitv ) ) AND ( NOT max_included( xitv ) ) ) ) );
      END_IF;
      IF amin = ( -PI ) THEN
        RETURN( ( NOT max_exists( xitv ) ) AND max_exists( yitv ) AND ( NOT min_exists( xitv ) ) AND ( NOT 
            min_exists( yitv ) ) AND ( real_max( yitv ) = yc ) AND ( ( c_in AND min_included( aitv ) AND 
            max_included( aitv ) AND max_included( yitv ) ) OR ( ( NOT c_in ) AND ( NOT min_included( aitv ) ) 
            AND ( NOT max_included( aitv ) ) AND ( NOT max_included( yitv ) ) ) ) );
      END_IF;
      IF amin = ( ( -0.5 ) * PI ) THEN
        RETURN( ( NOT max_exists( xitv ) ) AND ( NOT max_exists( yitv ) ) AND min_exists( xitv ) AND ( NOT 
            min_exists( yitv ) ) AND ( real_min( xitv ) = xc ) AND ( ( c_in AND min_included( aitv ) AND 
            max_included( aitv ) AND min_included( xitv ) ) OR ( ( NOT c_in ) AND ( NOT min_included( aitv ) ) 
            AND ( NOT max_included( aitv ) ) AND ( NOT min_included( xitv ) ) ) ) );
      END_IF;
    END_IF;
    RETURN( FALSE );

  END_FUNCTION; -- equal_cregion_pregion (line:40021 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func EQUAL_CREGION_PREGION(CRGN: eCARTESIAN_COMPLEX_NUMBER_REGION? , PRGN: ePOLAR_COMPLEX_NUMBER_REGION? ) 
    -> SDAI.LOGICAL {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( CRGN, PRGN )
    if case .available(let _cached_value) = _equal_cregion_pregion__cache.cachedValue(params: _params) {
      return _cached_value as! SDAI.LOGICAL
    }

    var CRGN = CRGN; SDAI.TOUCH(var: &CRGN)
    var PRGN = PRGN; SDAI.TOUCH(var: &PRGN)

    //LOCAL
    var ARNG: SDAI.REAL? 
    var AMIN: SDAI.REAL? 
    var XC: SDAI.REAL? 
    var YC: SDAI.REAL? 
    var AITV: sREAL_INTERVAL? 
    var XITV: sREAL_INTERVAL? 
    var YITV: sREAL_INTERVAL? 
    var C_IN: SDAI.BOOLEAN? 
    //END_LOCAL

    
    let _TEMP1 = SDAI.EXISTS(CRGN)
    let _TEMP2 =  !_TEMP1
    let _TEMP3 = SDAI.EXISTS(PRGN)
    let _TEMP4 =  !_TEMP3
    let _TEMP5 = _TEMP2 || _TEMP4
    if SDAI.IS_TRUE( _TEMP5 ) {
      return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
        SDAI.FALSE)))
    }
    
    let _TEMP6 = PRGN?.DISTANCE_CONSTRAINT
    let _TEMP7 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP6))
    if SDAI.IS_TRUE( _TEMP7 ) {
      return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
        SDAI.FALSE)))
    }
    
    let _TEMP8 = PRGN?.DISTANCE_CONSTRAINT
    let _TEMP9 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP8))
    let _TEMP10 = _TEMP9 .!=. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    if SDAI.IS_TRUE( _TEMP10 ) {
      return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
        SDAI.FALSE)))
    }
    
    let _TEMP11 = PRGN?.DISTANCE_CONSTRAINT
    let _TEMP12 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/_TEMP11))
    C_IN = _TEMP12
    
    let _TEMP13 = PRGN?.DIRECTION_CONSTRAINT
    AITV = sREAL_INTERVAL(/*eFINITE_REAL_INTERVAL*/_TEMP13)
    
    let _TEMP14 = /*runtime*/AITV?.MIN
    AMIN = SDAI.REAL(fromGeneric: /*/*runtime*/SDAI.GENERIC*/_TEMP14)
    
    let _TEMP15 = /*runtime*/AITV?.MAX
    let _TEMP16 = /*runtime*/_TEMP15 - AMIN
    ARNG = _TEMP16
    
    let _TEMP17 = PRGN?.CENTRE
    let _TEMP18 = _TEMP17?.REAL_PART
    XC = _TEMP18
    
    let _TEMP19 = PRGN?.CENTRE
    let _TEMP20 = _TEMP19?.IMAG_PART
    YC = _TEMP20
    
    let _TEMP21 = CRGN?.REAL_CONSTRAINT
    XITV = _TEMP21
    
    let _TEMP22 = CRGN?.IMAG_CONSTRAINT
    YITV = _TEMP22
    
    let _TEMP23 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
    let _TEMP24 = ARNG .==. SDAI.FORCE_OPTIONAL(_TEMP23)
    if SDAI.IS_TRUE( _TEMP24 ) {
      
      let _TEMP25 = AMIN .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP25 ) {
        
        let _TEMP26 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP27 =  !_TEMP26
        let _TEMP28 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP29 =  !_TEMP28
        let _TEMP30 = _TEMP27 && _TEMP29
        let _TEMP31 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP32 = _TEMP30 && _TEMP31
        let _TEMP33 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP34 = _TEMP32 && _TEMP33
        let _TEMP35 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP36 = _TEMP35 .==. XC
        let _TEMP37 = _TEMP34 && _TEMP36
        let _TEMP38 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP39 = _TEMP38 .==. YC
        let _TEMP40 = _TEMP37 && _TEMP39
        let _TEMP41 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP42 = C_IN && _TEMP41
        let _TEMP43 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP44 = _TEMP42 && _TEMP43
        let _TEMP45 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP46 = _TEMP44 && _TEMP45
        let _TEMP47 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP48 = _TEMP46 && _TEMP47
        let _TEMP49 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP50 =  !_TEMP49
        let _TEMP51 = (  !C_IN ) && _TEMP50
        let _TEMP52 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP53 = _TEMP51 && _TEMP52
        let _TEMP54 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP55 = _TEMP53 && _TEMP54
        let _TEMP56 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP57 =  !_TEMP56
        let _TEMP58 = _TEMP55 && _TEMP57
        let _TEMP59 = _TEMP48 || _TEMP58
        let _TEMP60 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP61 = (  !C_IN ) && _TEMP60
        let _TEMP62 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP63 =  !_TEMP62
        let _TEMP64 = _TEMP61 && _TEMP63
        let _TEMP65 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP66 =  !_TEMP65
        let _TEMP67 = _TEMP64 && _TEMP66
        let _TEMP68 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP69 = _TEMP67 && _TEMP68
        let _TEMP70 = _TEMP59 || _TEMP69
        let _TEMP71 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP72 =  !_TEMP71
        let _TEMP73 = (  !C_IN ) && _TEMP72
        let _TEMP74 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP75 =  !_TEMP74
        let _TEMP76 = _TEMP73 && _TEMP75
        let _TEMP77 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP78 =  !_TEMP77
        let _TEMP79 = _TEMP76 && _TEMP78
        let _TEMP80 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP81 =  !_TEMP80
        let _TEMP82 = _TEMP79 && _TEMP81
        let _TEMP83 = _TEMP70 || _TEMP82
        let _TEMP84 = _TEMP40 && _TEMP83
        return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP84))
      }
      
      let _TEMP85 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
      let _TEMP86 = AMIN .==. SDAI.FORCE_OPTIONAL(_TEMP85)
      if SDAI.IS_TRUE( _TEMP86 ) {
        
        let _TEMP87 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP88 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP89 =  !_TEMP88
        let _TEMP90 = _TEMP87 && _TEMP89
        let _TEMP91 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP92 =  !_TEMP91
        let _TEMP93 = _TEMP90 && _TEMP92
        let _TEMP94 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP95 = _TEMP93 && _TEMP94
        let _TEMP96 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP97 = _TEMP96 .==. XC
        let _TEMP98 = _TEMP95 && _TEMP97
        let _TEMP99 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP100 = _TEMP99 .==. YC
        let _TEMP101 = _TEMP98 && _TEMP100
        let _TEMP102 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP103 = C_IN && _TEMP102
        let _TEMP104 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP105 = _TEMP103 && _TEMP104
        let _TEMP106 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP107 = _TEMP105 && _TEMP106
        let _TEMP108 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP109 = _TEMP107 && _TEMP108
        let _TEMP110 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP111 =  !_TEMP110
        let _TEMP112 = (  !C_IN ) && _TEMP111
        let _TEMP113 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP114 = _TEMP112 && _TEMP113
        let _TEMP115 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP116 = _TEMP114 && _TEMP115
        let _TEMP117 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP118 =  !_TEMP117
        let _TEMP119 = _TEMP116 && _TEMP118
        let _TEMP120 = _TEMP109 || _TEMP119
        let _TEMP121 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP122 = (  !C_IN ) && _TEMP121
        let _TEMP123 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP124 =  !_TEMP123
        let _TEMP125 = _TEMP122 && _TEMP124
        let _TEMP126 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP127 =  !_TEMP126
        let _TEMP128 = _TEMP125 && _TEMP127
        let _TEMP129 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP130 = _TEMP128 && _TEMP129
        let _TEMP131 = _TEMP120 || _TEMP130
        let _TEMP132 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP133 =  !_TEMP132
        let _TEMP134 = (  !C_IN ) && _TEMP133
        let _TEMP135 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP136 =  !_TEMP135
        let _TEMP137 = _TEMP134 && _TEMP136
        let _TEMP138 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP139 =  !_TEMP138
        let _TEMP140 = _TEMP137 && _TEMP139
        let _TEMP141 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP142 =  !_TEMP141
        let _TEMP143 = _TEMP140 && _TEMP142
        let _TEMP144 = _TEMP131 || _TEMP143
        let _TEMP145 = _TEMP101 && _TEMP144
        return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP145))
      }
      
      let _TEMP146 = AMIN .==. SDAI.FORCE_OPTIONAL(SDAI.REAL( -SDAI.PI))
      if SDAI.IS_TRUE( _TEMP146 ) {
        
        let _TEMP147 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP148 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP149 = _TEMP147 && _TEMP148
        let _TEMP150 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP151 =  !_TEMP150
        let _TEMP152 = _TEMP149 && _TEMP151
        let _TEMP153 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP154 =  !_TEMP153
        let _TEMP155 = _TEMP152 && _TEMP154
        let _TEMP156 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP157 = _TEMP156 .==. XC
        let _TEMP158 = _TEMP155 && _TEMP157
        let _TEMP159 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP160 = _TEMP159 .==. YC
        let _TEMP161 = _TEMP158 && _TEMP160
        let _TEMP162 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP163 = C_IN && _TEMP162
        let _TEMP164 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP165 = _TEMP163 && _TEMP164
        let _TEMP166 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP167 = _TEMP165 && _TEMP166
        let _TEMP168 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP169 = _TEMP167 && _TEMP168
        let _TEMP170 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP171 =  !_TEMP170
        let _TEMP172 = (  !C_IN ) && _TEMP171
        let _TEMP173 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP174 = _TEMP172 && _TEMP173
        let _TEMP175 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP176 = _TEMP174 && _TEMP175
        let _TEMP177 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP178 =  !_TEMP177
        let _TEMP179 = _TEMP176 && _TEMP178
        let _TEMP180 = _TEMP169 || _TEMP179
        let _TEMP181 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP182 = (  !C_IN ) && _TEMP181
        let _TEMP183 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP184 =  !_TEMP183
        let _TEMP185 = _TEMP182 && _TEMP184
        let _TEMP186 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP187 =  !_TEMP186
        let _TEMP188 = _TEMP185 && _TEMP187
        let _TEMP189 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP190 = _TEMP188 && _TEMP189
        let _TEMP191 = _TEMP180 || _TEMP190
        let _TEMP192 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP193 =  !_TEMP192
        let _TEMP194 = (  !C_IN ) && _TEMP193
        let _TEMP195 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP196 =  !_TEMP195
        let _TEMP197 = _TEMP194 && _TEMP196
        let _TEMP198 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP199 =  !_TEMP198
        let _TEMP200 = _TEMP197 && _TEMP199
        let _TEMP201 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP202 =  !_TEMP201
        let _TEMP203 = _TEMP200 && _TEMP202
        let _TEMP204 = _TEMP191 || _TEMP203
        let _TEMP205 = _TEMP161 && _TEMP204
        return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP205))
      }
      
      let _TEMP206 = SDAI.REAL( -5.0000000000e-01) * SDAI.REAL(SDAI.PI)
      let _TEMP207 = AMIN .==. SDAI.FORCE_OPTIONAL(_TEMP206)
      if SDAI.IS_TRUE( _TEMP207 ) {
        
        let _TEMP208 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP209 =  !_TEMP208
        let _TEMP210 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP211 = _TEMP209 && _TEMP210
        let _TEMP212 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP213 = _TEMP211 && _TEMP212
        let _TEMP214 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP215 =  !_TEMP214
        let _TEMP216 = _TEMP213 && _TEMP215
        let _TEMP217 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP218 = _TEMP217 .==. XC
        let _TEMP219 = _TEMP216 && _TEMP218
        let _TEMP220 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP221 = _TEMP220 .==. YC
        let _TEMP222 = _TEMP219 && _TEMP221
        let _TEMP223 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP224 = C_IN && _TEMP223
        let _TEMP225 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP226 = _TEMP224 && _TEMP225
        let _TEMP227 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP228 = _TEMP226 && _TEMP227
        let _TEMP229 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP230 = _TEMP228 && _TEMP229
        let _TEMP231 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP232 =  !_TEMP231
        let _TEMP233 = (  !C_IN ) && _TEMP232
        let _TEMP234 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP235 = _TEMP233 && _TEMP234
        let _TEMP236 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP237 = _TEMP235 && _TEMP236
        let _TEMP238 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP239 =  !_TEMP238
        let _TEMP240 = _TEMP237 && _TEMP239
        let _TEMP241 = _TEMP230 || _TEMP240
        let _TEMP242 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP243 = (  !C_IN ) && _TEMP242
        let _TEMP244 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP245 =  !_TEMP244
        let _TEMP246 = _TEMP243 && _TEMP245
        let _TEMP247 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP248 =  !_TEMP247
        let _TEMP249 = _TEMP246 && _TEMP248
        let _TEMP250 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP251 = _TEMP249 && _TEMP250
        let _TEMP252 = _TEMP241 || _TEMP251
        let _TEMP253 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP254 =  !_TEMP253
        let _TEMP255 = (  !C_IN ) && _TEMP254
        let _TEMP256 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP257 =  !_TEMP256
        let _TEMP258 = _TEMP255 && _TEMP257
        let _TEMP259 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP260 =  !_TEMP259
        let _TEMP261 = _TEMP258 && _TEMP260
        let _TEMP262 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP263 =  !_TEMP262
        let _TEMP264 = _TEMP261 && _TEMP263
        let _TEMP265 = _TEMP252 || _TEMP264
        let _TEMP266 = _TEMP222 && _TEMP265
        return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP266))
      }
    }
    
    let _TEMP267 = ARNG .==. SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
    if SDAI.IS_TRUE( _TEMP267 ) {
      
      let _TEMP268 = AMIN .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      if SDAI.IS_TRUE( _TEMP268 ) {
        
        let _TEMP269 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP270 =  !_TEMP269
        let _TEMP271 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP272 =  !_TEMP271
        let _TEMP273 = _TEMP270 && _TEMP272
        let _TEMP274 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP275 =  !_TEMP274
        let _TEMP276 = _TEMP273 && _TEMP275
        let _TEMP277 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP278 = _TEMP276 && _TEMP277
        let _TEMP279 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP280 = _TEMP279 .==. YC
        let _TEMP281 = _TEMP278 && _TEMP280
        let _TEMP282 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP283 = C_IN && _TEMP282
        let _TEMP284 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP285 = _TEMP283 && _TEMP284
        let _TEMP286 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP287 = _TEMP285 && _TEMP286
        let _TEMP288 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP289 =  !_TEMP288
        let _TEMP290 = (  !C_IN ) && _TEMP289
        let _TEMP291 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP292 =  !_TEMP291
        let _TEMP293 = _TEMP290 && _TEMP292
        let _TEMP294 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP295 =  !_TEMP294
        let _TEMP296 = _TEMP293 && _TEMP295
        let _TEMP297 = _TEMP287 || _TEMP296
        let _TEMP298 = _TEMP281 && _TEMP297
        return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP298))
      }
      
      let _TEMP299 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
      let _TEMP300 = AMIN .==. SDAI.FORCE_OPTIONAL(_TEMP299)
      if SDAI.IS_TRUE( _TEMP300 ) {
        
        let _TEMP301 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP302 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP303 =  !_TEMP302
        let _TEMP304 = _TEMP301 && _TEMP303
        let _TEMP305 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP306 =  !_TEMP305
        let _TEMP307 = _TEMP304 && _TEMP306
        let _TEMP308 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP309 =  !_TEMP308
        let _TEMP310 = _TEMP307 && _TEMP309
        let _TEMP311 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP312 = _TEMP311 .==. XC
        let _TEMP313 = _TEMP310 && _TEMP312
        let _TEMP314 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP315 = C_IN && _TEMP314
        let _TEMP316 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP317 = _TEMP315 && _TEMP316
        let _TEMP318 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP319 = _TEMP317 && _TEMP318
        let _TEMP320 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP321 =  !_TEMP320
        let _TEMP322 = (  !C_IN ) && _TEMP321
        let _TEMP323 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP324 =  !_TEMP323
        let _TEMP325 = _TEMP322 && _TEMP324
        let _TEMP326 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP327 =  !_TEMP326
        let _TEMP328 = _TEMP325 && _TEMP327
        let _TEMP329 = _TEMP319 || _TEMP328
        let _TEMP330 = _TEMP313 && _TEMP329
        return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP330))
      }
      
      let _TEMP331 = AMIN .==. SDAI.FORCE_OPTIONAL(SDAI.REAL( -SDAI.PI))
      if SDAI.IS_TRUE( _TEMP331 ) {
        
        let _TEMP332 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP333 =  !_TEMP332
        let _TEMP334 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP335 = _TEMP333 && _TEMP334
        let _TEMP336 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP337 =  !_TEMP336
        let _TEMP338 = _TEMP335 && _TEMP337
        let _TEMP339 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP340 =  !_TEMP339
        let _TEMP341 = _TEMP338 && _TEMP340
        let _TEMP342 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP343 = _TEMP342 .==. YC
        let _TEMP344 = _TEMP341 && _TEMP343
        let _TEMP345 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP346 = C_IN && _TEMP345
        let _TEMP347 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP348 = _TEMP346 && _TEMP347
        let _TEMP349 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP350 = _TEMP348 && _TEMP349
        let _TEMP351 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP352 =  !_TEMP351
        let _TEMP353 = (  !C_IN ) && _TEMP352
        let _TEMP354 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP355 =  !_TEMP354
        let _TEMP356 = _TEMP353 && _TEMP355
        let _TEMP357 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP358 =  !_TEMP357
        let _TEMP359 = _TEMP356 && _TEMP358
        let _TEMP360 = _TEMP350 || _TEMP359
        let _TEMP361 = _TEMP344 && _TEMP360
        return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP361))
      }
      
      let _TEMP362 = SDAI.REAL( -5.0000000000e-01) * SDAI.REAL(SDAI.PI)
      let _TEMP363 = AMIN .==. SDAI.FORCE_OPTIONAL(_TEMP362)
      if SDAI.IS_TRUE( _TEMP363 ) {
        
        let _TEMP364 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP365 =  !_TEMP364
        let _TEMP366 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP367 =  !_TEMP366
        let _TEMP368 = _TEMP365 && _TEMP367
        let _TEMP369 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP370 = _TEMP368 && _TEMP369
        let _TEMP371 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
        let _TEMP372 =  !_TEMP371
        let _TEMP373 = _TEMP370 && _TEMP372
        let _TEMP374 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP375 = _TEMP374 .==. XC
        let _TEMP376 = _TEMP373 && _TEMP375
        let _TEMP377 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP378 = C_IN && _TEMP377
        let _TEMP379 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP380 = _TEMP378 && _TEMP379
        let _TEMP381 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP382 = _TEMP380 && _TEMP381
        let _TEMP383 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP384 =  !_TEMP383
        let _TEMP385 = (  !C_IN ) && _TEMP384
        let _TEMP386 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/AITV))
        let _TEMP387 =  !_TEMP386
        let _TEMP388 = _TEMP385 && _TEMP387
        let _TEMP389 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
        let _TEMP390 =  !_TEMP389
        let _TEMP391 = _TEMP388 && _TEMP390
        let _TEMP392 = _TEMP382 || _TEMP391
        let _TEMP393 = _TEMP376 && _TEMP392
        return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(_TEMP393))
      }
    }
    return _equal_cregion_pregion__cache.updateCache(params: _params, value: SDAI.UNWRAP(SDAI.LOGICAL(
      SDAI.FALSE)))
  }

}

//MARK: - function result cache
private var _equal_cregion_pregion__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

