/* file: enclose_cregion_in_pregion.swift 	 generated: Sun Oct 31 15:32:10 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION enclose_cregion_in_pregion(
               crgn : cartesian_complex_number_region;
               centre : complex_number_literal
           ) : polar_complex_number_region;

    FUNCTION angle(
                 a : REAL
             ) : REAL;
      REPEAT WHILE a > PI;
        a := a - ( 2 * PI );
      END_REPEAT;
      REPEAT WHILE a <= ( -PI );
        a := a + ( 2 * PI );
      END_REPEAT;
      RETURN( a );

    END_FUNCTION; -- angle (line:38688 file:ap242ed2_mim_lf_v1.101.TY.exp)

    FUNCTION strictly_in(
                 z : REAL;
                 zitv : real_interval
             ) : LOGICAL;
      RETURN( ( ( NOT min_exists( zitv ) ) OR ( z > real_min( zitv ) ) ) AND ( ( NOT max_exists( zitv ) ) OR 
          ( z < real_max( zitv ) ) ) );

    END_FUNCTION; -- strictly_in (line:38697 file:ap242ed2_mim_lf_v1.101.TY.exp)

    PROCEDURE angle_minmax(
                  ab : REAL;
                  a : REAL;
                  a_in : BOOLEAN;
                  VAR amin : REAL;
                  VAR amax : REAL;
                  VAR amin_in : BOOLEAN;
                  VAR amax_in : BOOLEAN      );
      a := angle( a - ab );
      IF amin = a THEN
        amin_in := amin_in OR a_in;
      END_IF;
      IF amin > a THEN
        amin := a;
        amin_in := a_in;
      END_IF;
      IF amax = a THEN
        amax_in := amax_in OR a_in;
      END_IF;
      IF amax < a THEN
        amax := a;
        amax_in := a_in;
      END_IF;

    END_PROCEDURE; -- angle_minmax (line:38701 file:ap242ed2_mim_lf_v1.101.TY.exp)

    PROCEDURE range_max(
                  r : REAL;
                  incl : BOOLEAN;
                  VAR rmax : REAL;
                  VAR rmax_in : BOOLEAN      );
      IF rmax = r THEN
        rmax_in := rmax_in OR incl;
      END_IF;
      IF rmax < r THEN
        rmax := r;
        rmax_in := incl;
      END_IF;

    END_PROCEDURE; -- range_max (line:38723 file:ap242ed2_mim_lf_v1.101.TY.exp)

    PROCEDURE range_min(
                  r : REAL;
                  incl : BOOLEAN;
                  VAR rmin : REAL;
                  VAR rmin_in : BOOLEAN      );
      IF rmin = r THEN
        rmin_in := rmin_in OR incl;
      END_IF;
      IF ( rmin < 0 ) OR ( rmin > r ) THEN
        rmin := r;
        rmin_in := incl;
      END_IF;

    END_PROCEDURE; -- range_min (line:38734 file:ap242ed2_mim_lf_v1.101.TY.exp)

    LOCAL
      xitv        : real_interval;
      yitv        : real_interval;
      is_xmin     : BOOLEAN;
      is_xmax     : BOOLEAN;
      is_ymin     : BOOLEAN;
      is_ymax     : BOOLEAN;
      xmin        : REAL := 0;
      xmax        : REAL := 0;
      ymin        : REAL := 0;
      ymax        : REAL := 0;
      xc          : REAL := 0;
      yc          : REAL := 0;
      xmin_in     : BOOLEAN := FALSE;
      xmax_in     : BOOLEAN := FALSE;
      ymin_in     : BOOLEAN := FALSE;
      ymax_in     : BOOLEAN := FALSE;
      rmin        : REAL := -1;
      rmax        : REAL := -1;
      amin        : REAL := 4;
      amax        : REAL := -4;
      rmax_exists : BOOLEAN := TRUE;
      outside     : BOOLEAN := TRUE;
      rmin_in     : BOOLEAN := FALSE;
      rmax_in     : BOOLEAN := FALSE;
      amin_in     : BOOLEAN := FALSE;
      amax_in     : BOOLEAN := FALSE;
      ab          : REAL := 0;
      a           : REAL := 0;
      r           : REAL := 0;
      incl        : BOOLEAN;
      ritv        : real_interval;
      aitv        : finite_real_interval;
      minclo      : open_closed := open;
      maxclo      : open_closed := open;
    END_LOCAL;
    IF ( NOT EXISTS( crgn ) ) OR ( NOT EXISTS( centre ) ) THEN
      RETURN( ? );
    END_IF;
    xitv := crgn.real_constraint;
    yitv := crgn.imag_constraint;
    xc := centre.real_part;
    yc := centre.imag_part;
    is_xmin := min_exists( xitv );
    is_xmax := max_exists( xitv );
    is_ymin := min_exists( yitv );
    is_ymax := max_exists( yitv );
    IF is_xmin THEN
      xmin := real_min( xitv );
      xmin_in := min_included( xitv );
    END_IF;
    IF is_xmax THEN
      xmax := real_max( xitv );
      xmax_in := max_included( xitv );
    END_IF;
    IF is_ymin THEN
      ymin := real_min( yitv );
      ymin_in := min_included( yitv );
    END_IF;
    IF is_ymax THEN
      ymax := real_max( yitv );
      ymax_in := max_included( yitv );
    END_IF;
    rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
    IF is_xmin AND ( xc <= xmin ) THEN
      ab := 0;
    ELSE
      IF is_ymin AND ( yc <= ymin ) THEN
        ab := 0.5 * PI;
      ELSE
        IF is_ymax AND ( yc >= ymax ) THEN
          ab := ( -0.5 ) * PI;
        ELSE
          IF is_xmax AND ( xc >= xmax ) THEN
            ab := PI;
          ELSE
            outside := FALSE;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    IF ( NOT outside ) AND ( NOT rmax_exists ) THEN
      RETURN( ? );
    END_IF;
    IF is_xmin AND ( xc <= xmin ) AND strictly_in( yc, yitv ) THEN
      rmin := xmin - xc;
      rmin_in := xmin_in;
    ELSE
      IF is_ymin AND ( yc <= ymin ) AND strictly_in( xc, xitv ) THEN
        rmin := ymin - yc;
        rmin_in := ymin_in;
      ELSE
        IF is_ymax AND ( yc >= ymax ) AND strictly_in( xc, xitv ) THEN
          rmin := yc - ymax;
          rmin_in := ymax_in;
        ELSE
          IF is_xmax AND ( xc >= xmax ) AND strictly_in( yc, yitv ) THEN
            rmin := xc - xmax;
            rmin_in := xmax_in;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    IF is_xmin THEN
      IF is_ymin THEN
        r := SQRT( ( ( xmin - xc ) ** 2 ) + ( ( ymin - yc ) ** 2 ) );
        incl := xmin_in AND ymin_in;
        IF rmax_exists THEN
          range_max( r, incl, rmax, rmax_in );
        END_IF;
        IF outside THEN
          IF r > 0 THEN
            range_min( r, incl, rmin, rmin_in );
            a := angle( atan2( ymin - yc, xmin - xc ) - ab );
            IF xc = xmin THEN
              incl := xmin_in;
            END_IF;
            IF yc = ymin THEN
              incl := ymin_in;
            END_IF;
            angle_minmax( ab, a, incl, amin, amax, amin_in, amax_in );
          ELSE
            rmin := 0;
            rmin_in := xmin_in AND ymin_in;
            amin := angle( 0 - ab );
            amin_in := ymin_in;
            amax := angle( ( 0.5 * PI ) - ab );
            amax_in := xmin_in;
          END_IF;
        END_IF;
      ELSE
        IF xc <= xmin THEN
          angle_minmax( ab, ( -0.5 ) * PI, ( xc = xmin ) AND xmin_in, amin, amax, amin_in, amax_in );
        END_IF;
      END_IF;
      IF ( NOT is_ymax ) AND ( xc <= xmin ) THEN
        angle_minmax( ab, 0.5 * PI, ( xc = xmin ) AND xmin_in, amin, amax, amin_in, amax_in );
      END_IF;
    END_IF;
    IF is_ymin THEN
      IF is_xmax THEN
        r := SQRT( ( ( xmax - xc ) ** 2 ) + ( ( ymin - yc ) ** 2 ) );
        incl := xmax_in AND ymin_in;
        IF rmax_exists THEN
          range_max( r, incl, rmax, rmax_in );
        END_IF;
        IF outside THEN
          IF r > 0 THEN
            range_min( r, incl, rmin, rmin_in );
            a := angle( atan2( ymin - yc, xmax - xc ) - ab );
            IF xc = xmax THEN
              incl := xmax_in;
            END_IF;
            IF yc = ymin THEN
              incl := ymin_in;
            END_IF;
            angle_minmax( ab, a, incl, amin, amax, amin_in, amax_in );
          ELSE
            rmin := 0;
            rmin_in := xmax_in AND ymin_in;
            amin := angle( ( 0.5 * PI ) - ab );
            amin_in := ymin_in;
            amax := angle( PI - ab );
            amax_in := xmax_in;
          END_IF;
        END_IF;
      ELSE
        IF yc <= ymin THEN
          angle_minmax( ab, 0, ( yc = ymin ) AND ymin_in, amin, amax, amin_in, amax_in );
        END_IF;
      END_IF;
      IF ( NOT is_xmin ) AND ( yc <= ymin ) THEN
        angle_minmax( ab, PI, ( yc = ymin ) AND ymin_in, amin, amax, amin_in, amax_in );
      END_IF;
    END_IF;
    IF is_xmax THEN
      IF is_ymax THEN
        r := SQRT( ( ( xmax - xc ) ** 2 ) + ( ( ymax - yc ) ** 2 ) );
        incl := xmax_in AND ymax_in;
        IF rmax_exists THEN
          range_max( r, incl, rmax, rmax_in );
        END_IF;
        IF outside THEN
          IF r > 0 THEN
            range_min( r, incl, rmin, rmin_in );
            a := angle( atan2( ymax - yc, xmax - xc ) - ab );
            IF xc = xmax THEN
              incl := xmax_in;
            END_IF;
            IF yc = ymax THEN
              incl := ymax_in;
            END_IF;
            angle_minmax( ab, a, incl, amin, amax, amin_in, amax_in );
          ELSE
            rmin := 0;
            rmin_in := xmax_in AND ymax_in;
            amin := angle( ( -PI ) - ab );
            amin_in := ymax_in;
            amax := angle( ( ( -0.5 ) * PI ) - ab );
            amax_in := xmax_in;
          END_IF;
        END_IF;
      ELSE
        IF xc >= xmax THEN
          angle_minmax( ab, 0.5 * PI, ( xc = xmax ) AND xmax_in, amin, amax, amin_in, amax_in );
        END_IF;
      END_IF;
      IF ( NOT is_ymin ) AND ( xc >= xmax ) THEN
        angle_minmax( ab, ( -0.5 ) * PI, ( xc = xmax ) AND xmax_in, amin, amax, amin_in, amax_in );
      END_IF;
    END_IF;
    IF is_ymax THEN
      IF is_xmin THEN
        r := SQRT( ( ( xmin - xc ) ** 2 ) + ( ( ymax - yc ) ** 2 ) );
        incl := xmin_in AND ymax_in;
        IF rmax_exists THEN
          range_max( r, incl, rmax, rmax_in );
        END_IF;
        IF outside THEN
          IF r > 0 THEN
            range_min( r, incl, rmin, rmin_in );
            a := angle( atan2( ymax - yc, xmin - xc ) - ab );
            IF xc = xmin THEN
              incl := xmin_in;
            END_IF;
            IF yc = ymax THEN
              incl := ymax_in;
            END_IF;
            angle_minmax( ab, a, incl, amin, amax, amin_in, amax_in );
          ELSE
            rmin := 0;
            rmin_in := xmin_in AND ymax_in;
            amin := angle( ( 0.5 * PI ) - ab );
            amin_in := ymax_in;
            amax := angle( PI - ab );
            amax_in := xmin_in;
          END_IF;
        END_IF;
      ELSE
        IF yc >= ymax THEN
          angle_minmax( ab, PI, ( yc = ymax ) AND ymax_in, amin, amax, amin_in, amax_in );
        END_IF;
      END_IF;
      IF ( NOT is_xmax ) AND ( yc >= ymax ) THEN
        angle_minmax( ab, 0, ( yc = ymax ) AND ymax_in, amin, amax, amin_in, amax_in );
      END_IF;
    END_IF;
    IF outside THEN
      amin := angle( amin + ab );
      IF amin = PI THEN
        amin := -PI;
      END_IF;
      amax := angle( amax + ab );
      IF amax <= amin THEN
        amax := amax + ( 2 * PI );
      END_IF;
    ELSE
      amin := -PI;
      amin_in := FALSE;
      amax := PI;
      amax_in := FALSE;
    END_IF;
    IF amin_in THEN
      minclo := closed;
    END_IF;
    IF amax_in THEN
      maxclo := closed;
    END_IF;
    aitv := make_finite_real_interval( amin, minclo, amax, maxclo );
    minclo := open;
    IF rmin_in THEN
      minclo := closed;
    END_IF;
    IF rmax_exists THEN
      maxclo := open;
      IF rmax_in THEN
        maxclo := closed;
      END_IF;
      ritv := make_finite_real_interval( rmin, minclo, rmax, maxclo );
    ELSE
      ritv := make_real_interval_from_min( rmin, minclo );
    END_IF;
    RETURN( make_polar_complex_number_region( centre, ritv, aitv ) );

  END_FUNCTION; -- enclose_cregion_in_pregion (line:38685 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func ENCLOSE_CREGION_IN_PREGION(CRGN: eCARTESIAN_COMPLEX_NUMBER_REGION? , 
                                  CENTRE: eCOMPLEX_NUMBER_LITERAL? ) 
    -> ePOLAR_COMPLEX_NUMBER_REGION? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( CRGN, CENTRE )
    if case .available(let _cached_value) = _enclose_cregion_in_pregion__cache.cachedValue(params: _params) {
      return _cached_value as? ePOLAR_COMPLEX_NUMBER_REGION
    }

    var CRGN = CRGN; SDAI.TOUCH(var: &CRGN)
    var CENTRE = CENTRE; SDAI.TOUCH(var: &CENTRE)

    //NESTED FUNCTION
    func ANGLE(_ A: SDAI.REAL? ) -> SDAI.REAL? {

      var A = A; SDAI.TOUCH(var: &A)

      while !SDAI.IS_TRUE(( A > SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI)) )) {
        
        let _TEMP1 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP2 = A - SDAI.FORCE_OPTIONAL(_TEMP1)
        A = _TEMP2
      }
      while !SDAI.IS_TRUE(( A <= SDAI.FORCE_OPTIONAL(SDAI.REAL( -SDAI.PI)) )) {
        
        let _TEMP3 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP4 = A + SDAI.FORCE_OPTIONAL(_TEMP3)
        A = _TEMP4
      }
      return A
    } //END FUNCTION ANGLE

    //NESTED FUNCTION
    func STRICTLY_IN(Z: SDAI.REAL? , ZITV: sREAL_INTERVAL? ) 
      -> SDAI.LOGICAL {

      var Z = Z; SDAI.TOUCH(var: &Z)
      var ZITV = ZITV; SDAI.TOUCH(var: &ZITV)

      
      let _TEMP1 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/ZITV))
      let _TEMP2 =  !_TEMP1
      let _TEMP3 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/ZITV))
      let _TEMP4 = Z > _TEMP3
      let _TEMP5 = _TEMP2 || _TEMP4
      let _TEMP6 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/ZITV))
      let _TEMP7 =  !_TEMP6
      let _TEMP8 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/ZITV))
      let _TEMP9 = Z < _TEMP8
      let _TEMP10 = _TEMP7 || _TEMP9
      let _TEMP11 = _TEMP5 && _TEMP10
      return SDAI.UNWRAP(_TEMP11)
    } //END FUNCTION STRICTLY_IN

    //NESTED PROCEDURE
    func ANGLE_MINMAX(AB: SDAI.REAL? , A: SDAI.REAL? , A_IN: SDAI.BOOLEAN? , 
                      AMIN: inout SDAI.REAL? , AMAX: inout SDAI.REAL? , AMIN_IN: inout SDAI.BOOLEAN? , 
                      AMAX_IN: inout SDAI.BOOLEAN? ) {

      var AB = AB; SDAI.TOUCH(var: &AB)
      var A = A; SDAI.TOUCH(var: &A)
      var A_IN = A_IN; SDAI.TOUCH(var: &A_IN)

      
      let _TEMP1 = A - AB
      let _TEMP2 = ANGLE(_TEMP1)
      A = _TEMP2
      
      let _TEMP3 = AMIN .==. A
      if SDAI.IS_TRUE( _TEMP3 ) {
        
        let _TEMP4 = AMIN_IN || A_IN
        AMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP4)
      }
      
      let _TEMP5 = AMIN > A
      if SDAI.IS_TRUE( _TEMP5 ) {
        AMIN = A
        AMIN_IN = A_IN
      }
      
      let _TEMP6 = AMAX .==. A
      if SDAI.IS_TRUE( _TEMP6 ) {
        
        let _TEMP7 = AMAX_IN || A_IN
        AMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP7)
      }
      
      let _TEMP8 = AMAX < A
      if SDAI.IS_TRUE( _TEMP8 ) {
        AMAX = A
        AMAX_IN = A_IN
      }
    } //END PROCEDURE ANGLE_MINMAX

    //NESTED PROCEDURE
    func RANGE_MAX(R: SDAI.REAL? , INCL: SDAI.BOOLEAN? , RMAX: inout SDAI.REAL? , 
                   RMAX_IN: inout SDAI.BOOLEAN? ) {

      var R = R; SDAI.TOUCH(var: &R)
      var INCL = INCL; SDAI.TOUCH(var: &INCL)

      
      let _TEMP1 = RMAX .==. R
      if SDAI.IS_TRUE( _TEMP1 ) {
        
        let _TEMP2 = RMAX_IN || INCL
        RMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP2)
      }
      
      let _TEMP3 = RMAX < R
      if SDAI.IS_TRUE( _TEMP3 ) {
        RMAX = R
        RMAX_IN = INCL
      }
    } //END PROCEDURE RANGE_MAX

    //NESTED PROCEDURE
    func RANGE_MIN(R: SDAI.REAL? , INCL: SDAI.BOOLEAN? , RMIN: inout SDAI.REAL? , 
                   RMIN_IN: inout SDAI.BOOLEAN? ) {

      var R = R; SDAI.TOUCH(var: &R)
      var INCL = INCL; SDAI.TOUCH(var: &INCL)

      
      let _TEMP1 = RMIN .==. R
      if SDAI.IS_TRUE( _TEMP1 ) {
        
        let _TEMP2 = RMIN_IN || INCL
        RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP2)
      }
      
      let _TEMP3 = RMIN < SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      let _TEMP4 = RMIN > R
      let _TEMP5 = _TEMP3 || _TEMP4
      if SDAI.IS_TRUE( _TEMP5 ) {
        RMIN = R
        RMIN_IN = INCL
      }
    } //END PROCEDURE RANGE_MIN

    //LOCAL
    var XITV: sREAL_INTERVAL? 
    var YITV: sREAL_INTERVAL? 
    var IS_XMIN: SDAI.BOOLEAN? 
    var IS_XMAX: SDAI.BOOLEAN? 
    var IS_YMIN: SDAI.BOOLEAN? 
    var IS_YMAX: SDAI.BOOLEAN? 
    var XMIN: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &XMIN)
    var XMAX: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &XMAX)
    var YMIN: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &YMIN)
    var YMAX: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &YMAX)
    var XC: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &XC)
    var YC: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &YC)
    var XMIN_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &XMIN_IN)
    var XMAX_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &XMAX_IN)
    var YMIN_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &YMIN_IN)
    var YMAX_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &YMAX_IN)
    var RMIN: SDAI.REAL?  = SDAI.REAL( -1.0000000000e+00); SDAI.TOUCH(var: &RMIN)
    var RMAX: SDAI.REAL?  = SDAI.REAL( -1.0000000000e+00); SDAI.TOUCH(var: &RMAX)
    var AMIN: SDAI.REAL?  = SDAI.REAL(4.0000000000e+00); SDAI.TOUCH(var: &AMIN)
    var AMAX: SDAI.REAL?  = SDAI.REAL( -4.0000000000e+00); SDAI.TOUCH(var: &AMAX)
    var RMAX_EXISTS: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.TRUE); SDAI.TOUCH(var: &RMAX_EXISTS)
    var OUTSIDE: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.TRUE); SDAI.TOUCH(var: &OUTSIDE)
    var RMIN_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &RMIN_IN)
    var RMAX_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &RMAX_IN)
    var AMIN_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &AMIN_IN)
    var AMAX_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &AMAX_IN)
    var AB: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &AB)
    var A: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &A)
    var R: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &R)
    var INCL: SDAI.BOOLEAN? 
    var RITV: sREAL_INTERVAL? 
    var AITV: eFINITE_REAL_INTERVAL? 
    var MINCLO: nOPEN_CLOSED?  = OPEN; SDAI.TOUCH(var: &MINCLO)
    var MAXCLO: nOPEN_CLOSED?  = OPEN; SDAI.TOUCH(var: &MAXCLO)
    //END_LOCAL

    
    let _TEMP1 = SDAI.EXISTS(CRGN)
    let _TEMP2 =  !_TEMP1
    let _TEMP3 = SDAI.EXISTS(CENTRE)
    let _TEMP4 =  !_TEMP3
    let _TEMP5 = _TEMP2 || _TEMP4
    if SDAI.IS_TRUE( _TEMP5 ) {
      return _enclose_cregion_in_pregion__cache.updateCache(params: _params, value: (nil as 
        ePOLAR_COMPLEX_NUMBER_REGION?))
    }
    
    let _TEMP6 = CRGN?.REAL_CONSTRAINT
    XITV = _TEMP6
    
    let _TEMP7 = CRGN?.IMAG_CONSTRAINT
    YITV = _TEMP7
    
    let _TEMP8 = CENTRE?.REAL_PART
    XC = _TEMP8
    
    let _TEMP9 = CENTRE?.IMAG_PART
    YC = _TEMP9
    
    let _TEMP10 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
    IS_XMIN = _TEMP10
    
    let _TEMP11 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
    IS_XMAX = _TEMP11
    
    let _TEMP12 = MIN_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
    IS_YMIN = _TEMP12
    
    let _TEMP13 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
    IS_YMAX = _TEMP13
    if SDAI.IS_TRUE( IS_XMIN ) {
      
      let _TEMP14 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
      XMIN = _TEMP14
      
      let _TEMP15 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
      XMIN_IN = _TEMP15
    }
    if SDAI.IS_TRUE( IS_XMAX ) {
      
      let _TEMP16 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
      XMAX = _TEMP16
      
      let _TEMP17 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/XITV))
      XMAX_IN = _TEMP17
    }
    if SDAI.IS_TRUE( IS_YMIN ) {
      
      let _TEMP18 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
      YMIN = _TEMP18
      
      let _TEMP19 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
      YMIN_IN = _TEMP19
    }
    if SDAI.IS_TRUE( IS_YMAX ) {
      
      let _TEMP20 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
      YMAX = _TEMP20
      
      let _TEMP21 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/YITV))
      YMAX_IN = _TEMP21
    }
    
    let _TEMP22 = IS_XMIN && IS_XMAX
    let _TEMP23 = _TEMP22 && IS_YMIN
    let _TEMP24 = _TEMP23 && IS_YMAX
    RMAX_EXISTS = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP24)
    
    let _TEMP25 = XC <= XMIN
    let _TEMP26 = IS_XMIN && _TEMP25
    if SDAI.IS_TRUE( _TEMP26 ) {
      AB = SDAI.REAL(0)
    }
    else {
      
      let _TEMP27 = YC <= YMIN
      let _TEMP28 = IS_YMIN && _TEMP27
      if SDAI.IS_TRUE( _TEMP28 ) {
        
        let _TEMP29 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
        AB = _TEMP29
      }
      else {
        
        let _TEMP30 = YC >= YMAX
        let _TEMP31 = IS_YMAX && _TEMP30
        if SDAI.IS_TRUE( _TEMP31 ) {
          
          let _TEMP32 = SDAI.REAL( -5.0000000000e-01) * SDAI.REAL(SDAI.PI)
          AB = _TEMP32
        }
        else {
          
          let _TEMP33 = XC >= XMAX
          let _TEMP34 = IS_XMAX && _TEMP33
          if SDAI.IS_TRUE( _TEMP34 ) {
            AB = SDAI.REAL(SDAI.PI)
          }
          else {
            OUTSIDE = SDAI.BOOLEAN(SDAI.FALSE)
          }
        }
      }
    }
    
    let _TEMP35 = (  !OUTSIDE ) && (  !RMAX_EXISTS )
    if SDAI.IS_TRUE( _TEMP35 ) {
      return _enclose_cregion_in_pregion__cache.updateCache(params: _params, value: (nil as 
        ePOLAR_COMPLEX_NUMBER_REGION?))
    }
    
    let _TEMP36 = XC <= XMIN
    let _TEMP37 = IS_XMIN && _TEMP36
    let _TEMP38 = STRICTLY_IN(Z: YC, 
                              ZITV: YITV)
    let _TEMP39 = _TEMP37 && _TEMP38
    if SDAI.IS_TRUE( _TEMP39 ) {
      
      let _TEMP40 = XMIN - XC
      RMIN = _TEMP40
      RMIN_IN = XMIN_IN
    }
    else {
      
      let _TEMP41 = YC <= YMIN
      let _TEMP42 = IS_YMIN && _TEMP41
      let _TEMP43 = STRICTLY_IN(Z: XC, 
                                ZITV: XITV)
      let _TEMP44 = _TEMP42 && _TEMP43
      if SDAI.IS_TRUE( _TEMP44 ) {
        
        let _TEMP45 = YMIN - YC
        RMIN = _TEMP45
        RMIN_IN = YMIN_IN
      }
      else {
        
        let _TEMP46 = YC >= YMAX
        let _TEMP47 = IS_YMAX && _TEMP46
        let _TEMP48 = STRICTLY_IN(Z: XC, 
                                  ZITV: XITV)
        let _TEMP49 = _TEMP47 && _TEMP48
        if SDAI.IS_TRUE( _TEMP49 ) {
          
          let _TEMP50 = YC - YMAX
          RMIN = _TEMP50
          RMIN_IN = YMAX_IN
        }
        else {
          
          let _TEMP51 = XC >= XMAX
          let _TEMP52 = IS_XMAX && _TEMP51
          let _TEMP53 = STRICTLY_IN(
            Z: YC, ZITV: YITV)
          let _TEMP54 = _TEMP52 && _TEMP53
          if SDAI.IS_TRUE( _TEMP54 ) {
            
            let _TEMP55 = XC - XMAX
            RMIN = _TEMP55
            RMIN_IN = XMAX_IN
          }
        }
      }
    }
    if SDAI.IS_TRUE( IS_XMIN ) {
      if SDAI.IS_TRUE( IS_YMIN ) {
        
        let _TEMP56 = XMIN - XC
        let _TEMP57 = _TEMP56 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP58 = YMIN - YC
        let _TEMP59 = _TEMP58 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP60 = _TEMP57 + _TEMP59
        let _TEMP61 = SDAI.SQRT(_TEMP60)
        R = _TEMP61
        
        let _TEMP62 = XMIN_IN && YMIN_IN
        INCL = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP62)
        if SDAI.IS_TRUE( RMAX_EXISTS ) {
          RANGE_MAX( R: R, INCL: INCL, RMAX: &RMAX, RMAX_IN: &RMAX_IN )
        }
        if SDAI.IS_TRUE( OUTSIDE ) {
          
          let _TEMP63 = R > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP63 ) {
            RANGE_MIN( R: R, INCL: INCL, RMIN: &RMIN, RMIN_IN: &RMIN_IN )
            
            let _TEMP64 = YMIN - YC
            let _TEMP65 = XMIN - XC
            let _TEMP66 = ATAN2(Y: _TEMP64, 
                                X: _TEMP65)
            let _TEMP67 = _TEMP66 - AB
            let _TEMP68 = ANGLE(_TEMP67)
            A = _TEMP68
            
            let _TEMP69 = XC .==. XMIN
            if SDAI.IS_TRUE( _TEMP69 ) {
              INCL = XMIN_IN
            }
            
            let _TEMP70 = YC .==. YMIN
            if SDAI.IS_TRUE( _TEMP70 ) {
              INCL = YMIN_IN
            }
            ANGLE_MINMAX( AB: AB, A: A, A_IN: INCL, AMIN: &AMIN, AMAX: &AMAX, 
              AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
          }
          else {
            RMIN = SDAI.REAL(0)
            
            let _TEMP71 = XMIN_IN && YMIN_IN
            RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP71)
            
            let _TEMP72 = SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0)) - AB
            let _TEMP73 = ANGLE(_TEMP72)
            AMIN = _TEMP73
            AMIN_IN = YMIN_IN
            
            let _TEMP74 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
            let _TEMP75 = SDAI.FORCE_OPTIONAL(_TEMP74) - AB
            let _TEMP76 = ANGLE(_TEMP75)
            AMAX = _TEMP76
            AMAX_IN = XMIN_IN
          }
        }
      }
      else {
        
        let _TEMP77 = XC <= XMIN
        if SDAI.IS_TRUE( _TEMP77 ) {
          ANGLE_MINMAX( AB: AB, A: SDAI.REAL( -5.0000000000e-01) * SDAI.REAL(SDAI.PI), 
            A_IN: SDAI.BOOLEAN(/*SDAI.LOGICAL*/( XC .==. XMIN ) && XMIN_IN), 
            AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
        }
      }
      
      let _TEMP78 = XC <= XMIN
      let _TEMP79 = (  !IS_YMAX ) && _TEMP78
      if SDAI.IS_TRUE( _TEMP79 ) {
        ANGLE_MINMAX( AB: AB, A: SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI), 
          A_IN: SDAI.BOOLEAN(/*SDAI.LOGICAL*/( XC .==. XMIN ) && XMIN_IN), 
          AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
      }
    }
    if SDAI.IS_TRUE( IS_YMIN ) {
      if SDAI.IS_TRUE( IS_XMAX ) {
        
        let _TEMP80 = XMAX - XC
        let _TEMP81 = _TEMP80 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP82 = YMIN - YC
        let _TEMP83 = _TEMP82 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP84 = _TEMP81 + _TEMP83
        let _TEMP85 = SDAI.SQRT(_TEMP84)
        R = _TEMP85
        
        let _TEMP86 = XMAX_IN && YMIN_IN
        INCL = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP86)
        if SDAI.IS_TRUE( RMAX_EXISTS ) {
          RANGE_MAX( R: R, INCL: INCL, RMAX: &RMAX, RMAX_IN: &RMAX_IN )
        }
        if SDAI.IS_TRUE( OUTSIDE ) {
          
          let _TEMP87 = R > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP87 ) {
            RANGE_MIN( R: R, INCL: INCL, RMIN: &RMIN, RMIN_IN: &RMIN_IN )
            
            let _TEMP88 = YMIN - YC
            let _TEMP89 = XMAX - XC
            let _TEMP90 = ATAN2(Y: _TEMP88, 
                                X: _TEMP89)
            let _TEMP91 = _TEMP90 - AB
            let _TEMP92 = ANGLE(_TEMP91)
            A = _TEMP92
            
            let _TEMP93 = XC .==. XMAX
            if SDAI.IS_TRUE( _TEMP93 ) {
              INCL = XMAX_IN
            }
            
            let _TEMP94 = YC .==. YMIN
            if SDAI.IS_TRUE( _TEMP94 ) {
              INCL = YMIN_IN
            }
            ANGLE_MINMAX( AB: AB, A: A, A_IN: INCL, AMIN: &AMIN, AMAX: &AMAX, 
              AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
          }
          else {
            RMIN = SDAI.REAL(0)
            
            let _TEMP95 = XMAX_IN && YMIN_IN
            RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP95)
            
            let _TEMP96 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
            let _TEMP97 = SDAI.FORCE_OPTIONAL(_TEMP96) - AB
            let _TEMP98 = ANGLE(_TEMP97)
            AMIN = _TEMP98
            AMIN_IN = YMIN_IN
            
            let _TEMP99 = SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI)) - AB
            let _TEMP100 = ANGLE(_TEMP99)
            AMAX = _TEMP100
            AMAX_IN = XMAX_IN
          }
        }
      }
      else {
        
        let _TEMP101 = YC <= YMIN
        if SDAI.IS_TRUE( _TEMP101 ) {
          ANGLE_MINMAX( AB: AB, A: SDAI.REAL(0), A_IN: SDAI.BOOLEAN(/*SDAI.LOGICAL*/( YC .==. YMIN ) && 
            YMIN_IN), AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
        }
      }
      
      let _TEMP102 = YC <= YMIN
      let _TEMP103 = (  !IS_XMIN ) && _TEMP102
      if SDAI.IS_TRUE( _TEMP103 ) {
        ANGLE_MINMAX( AB: AB, A: SDAI.REAL(SDAI.PI), A_IN: SDAI.BOOLEAN(/*SDAI.LOGICAL*/( YC .==. YMIN ) && 
          YMIN_IN), AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
      }
    }
    if SDAI.IS_TRUE( IS_XMAX ) {
      if SDAI.IS_TRUE( IS_YMAX ) {
        
        let _TEMP104 = XMAX - XC
        let _TEMP105 = _TEMP104 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP106 = YMAX - YC
        let _TEMP107 = _TEMP106 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP108 = _TEMP105 + _TEMP107
        let _TEMP109 = SDAI.SQRT(_TEMP108)
        R = _TEMP109
        
        let _TEMP110 = XMAX_IN && YMAX_IN
        INCL = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP110)
        if SDAI.IS_TRUE( RMAX_EXISTS ) {
          RANGE_MAX( R: R, INCL: INCL, RMAX: &RMAX, RMAX_IN: &RMAX_IN )
        }
        if SDAI.IS_TRUE( OUTSIDE ) {
          
          let _TEMP111 = R > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP111 ) {
            RANGE_MIN( R: R, INCL: INCL, RMIN: &RMIN, RMIN_IN: &RMIN_IN )
            
            let _TEMP112 = YMAX - YC
            let _TEMP113 = XMAX - XC
            let _TEMP114 = ATAN2(Y: _TEMP112, 
                                 X: _TEMP113)
            let _TEMP115 = _TEMP114 - AB
            let _TEMP116 = ANGLE(_TEMP115)
            A = _TEMP116
            
            let _TEMP117 = XC .==. XMAX
            if SDAI.IS_TRUE( _TEMP117 ) {
              INCL = XMAX_IN
            }
            
            let _TEMP118 = YC .==. YMAX
            if SDAI.IS_TRUE( _TEMP118 ) {
              INCL = YMAX_IN
            }
            ANGLE_MINMAX( AB: AB, A: A, A_IN: INCL, AMIN: &AMIN, AMAX: &AMAX, 
              AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
          }
          else {
            RMIN = SDAI.REAL(0)
            
            let _TEMP119 = XMAX_IN && YMAX_IN
            RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP119)
            
            let _TEMP120 = SDAI.FORCE_OPTIONAL(SDAI.REAL( -SDAI.PI)) - AB
            let _TEMP121 = ANGLE(_TEMP120)
            AMIN = _TEMP121
            AMIN_IN = YMAX_IN
            
            let _TEMP122 = SDAI.REAL( -5.0000000000e-01) * SDAI.REAL(SDAI.PI)
            let _TEMP123 = SDAI.FORCE_OPTIONAL(_TEMP122) - AB
            let _TEMP124 = ANGLE(_TEMP123)
            AMAX = _TEMP124
            AMAX_IN = XMAX_IN
          }
        }
      }
      else {
        
        let _TEMP125 = XC >= XMAX
        if SDAI.IS_TRUE( _TEMP125 ) {
          ANGLE_MINMAX( AB: AB, A: SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI), 
            A_IN: SDAI.BOOLEAN(/*SDAI.LOGICAL*/( XC .==. XMAX ) && XMAX_IN), 
            AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
        }
      }
      
      let _TEMP126 = XC >= XMAX
      let _TEMP127 = (  !IS_YMIN ) && _TEMP126
      if SDAI.IS_TRUE( _TEMP127 ) {
        ANGLE_MINMAX( AB: AB, A: SDAI.REAL( -5.0000000000e-01) * SDAI.REAL(SDAI.PI), 
          A_IN: SDAI.BOOLEAN(/*SDAI.LOGICAL*/( XC .==. XMAX ) && XMAX_IN), 
          AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
      }
    }
    if SDAI.IS_TRUE( IS_YMAX ) {
      if SDAI.IS_TRUE( IS_XMIN ) {
        
        let _TEMP128 = XMIN - XC
        let _TEMP129 = _TEMP128 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP130 = YMAX - YC
        let _TEMP131 = _TEMP130 ** SDAI.FORCE_OPTIONAL(SDAI.INTEGER(2))
        let _TEMP132 = _TEMP129 + _TEMP131
        let _TEMP133 = SDAI.SQRT(_TEMP132)
        R = _TEMP133
        
        let _TEMP134 = XMIN_IN && YMAX_IN
        INCL = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP134)
        if SDAI.IS_TRUE( RMAX_EXISTS ) {
          RANGE_MAX( R: R, INCL: INCL, RMAX: &RMAX, RMAX_IN: &RMAX_IN )
        }
        if SDAI.IS_TRUE( OUTSIDE ) {
          
          let _TEMP135 = R > SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP135 ) {
            RANGE_MIN( R: R, INCL: INCL, RMIN: &RMIN, RMIN_IN: &RMIN_IN )
            
            let _TEMP136 = YMAX - YC
            let _TEMP137 = XMIN - XC
            let _TEMP138 = ATAN2(Y: _TEMP136, 
                                 X: _TEMP137)
            let _TEMP139 = _TEMP138 - AB
            let _TEMP140 = ANGLE(_TEMP139)
            A = _TEMP140
            
            let _TEMP141 = XC .==. XMIN
            if SDAI.IS_TRUE( _TEMP141 ) {
              INCL = XMIN_IN
            }
            
            let _TEMP142 = YC .==. YMAX
            if SDAI.IS_TRUE( _TEMP142 ) {
              INCL = YMAX_IN
            }
            ANGLE_MINMAX( AB: AB, A: A, A_IN: INCL, AMIN: &AMIN, AMAX: &AMAX, 
              AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
          }
          else {
            RMIN = SDAI.REAL(0)
            
            let _TEMP143 = XMIN_IN && YMAX_IN
            RMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP143)
            
            let _TEMP144 = SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI)
            let _TEMP145 = SDAI.FORCE_OPTIONAL(_TEMP144) - AB
            let _TEMP146 = ANGLE(_TEMP145)
            AMIN = _TEMP146
            AMIN_IN = YMAX_IN
            
            let _TEMP147 = SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI)) - AB
            let _TEMP148 = ANGLE(_TEMP147)
            AMAX = _TEMP148
            AMAX_IN = XMIN_IN
          }
        }
      }
      else {
        
        let _TEMP149 = YC >= YMAX
        if SDAI.IS_TRUE( _TEMP149 ) {
          ANGLE_MINMAX( AB: AB, A: SDAI.REAL(SDAI.PI), A_IN: SDAI.BOOLEAN(/*SDAI.LOGICAL*/( YC .==. YMAX )
            && YMAX_IN), AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
        }
      }
      
      let _TEMP150 = YC >= YMAX
      let _TEMP151 = (  !IS_XMAX ) && _TEMP150
      if SDAI.IS_TRUE( _TEMP151 ) {
        ANGLE_MINMAX( AB: AB, A: SDAI.REAL(0), A_IN: SDAI.BOOLEAN(/*SDAI.LOGICAL*/( YC .==. YMAX ) && 
          YMAX_IN), AMIN: &AMIN, AMAX: &AMAX, AMIN_IN: &AMIN_IN, AMAX_IN: &AMAX_IN )
      }
    }
    if SDAI.IS_TRUE( OUTSIDE ) {
      
      let _TEMP152 = AMIN + AB
      let _TEMP153 = ANGLE(_TEMP152)
      AMIN = _TEMP153
      
      let _TEMP154 = AMIN .==. SDAI.FORCE_OPTIONAL(SDAI.REAL(SDAI.PI))
      if SDAI.IS_TRUE( _TEMP154 ) {
        AMIN = SDAI.REAL( -SDAI.PI)
      }
      
      let _TEMP155 = AMAX + AB
      let _TEMP156 = ANGLE(_TEMP155)
      AMAX = _TEMP156
      
      let _TEMP157 = AMAX <= AMIN
      if SDAI.IS_TRUE( _TEMP157 ) {
        
        let _TEMP158 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP159 = AMAX + SDAI.FORCE_OPTIONAL(_TEMP158)
        AMAX = _TEMP159
      }
    }
    else {
      AMIN = SDAI.REAL( -SDAI.PI)
      AMIN_IN = SDAI.BOOLEAN(SDAI.FALSE)
      AMAX = SDAI.REAL(SDAI.PI)
      AMAX_IN = SDAI.BOOLEAN(SDAI.FALSE)
    }
    if SDAI.IS_TRUE( AMIN_IN ) {
      MINCLO = CLOSED
    }
    if SDAI.IS_TRUE( AMAX_IN ) {
      MAXCLO = CLOSED
    }
    
    let _TEMP160 = MAKE_FINITE_REAL_INTERVAL(
      MIN: AMIN, MINCLO: MINCLO, MAX: AMAX, 
      MAXCLO: MAXCLO)
    AITV = _TEMP160
    MINCLO = OPEN
    if SDAI.IS_TRUE( RMIN_IN ) {
      MINCLO = CLOSED
    }
    if SDAI.IS_TRUE( RMAX_EXISTS ) {
      MAXCLO = OPEN
      if SDAI.IS_TRUE( RMAX_IN ) {
        MAXCLO = CLOSED
      }
      
      let _TEMP161 = MAKE_FINITE_REAL_INTERVAL(
        MIN: RMIN, MINCLO: MINCLO, MAX: RMAX, 
        MAXCLO: MAXCLO)
      RITV = sREAL_INTERVAL(/*eFINITE_REAL_INTERVAL*/_TEMP161)
    }
    else {
      
      let _TEMP162 = MAKE_REAL_INTERVAL_FROM_MIN(
        MIN: RMIN, MINCLO: MINCLO)
      RITV = sREAL_INTERVAL(/*eREAL_INTERVAL_FROM_MIN*/_TEMP162)
    }
    
    let _TEMP163 = MAKE_POLAR_COMPLEX_NUMBER_REGION(
      CENTRE: CENTRE, DIS_CONSTRAINT: RITV, 
      DIR_CONSTRAINT: AITV)
    return _enclose_cregion_in_pregion__cache.updateCache(params: _params, value: _TEMP163)
  }

}

//MARK: - function result cache
private var _enclose_cregion_in_pregion__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

