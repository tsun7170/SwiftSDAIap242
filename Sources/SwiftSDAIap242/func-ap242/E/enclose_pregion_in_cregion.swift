/* file: enclose_pregion_in_cregion.swift 	 generated: Sat Aug 14 13:46:02 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION enclose_pregion_in_cregion(
               prgn : polar_complex_number_region
           ) : cartesian_complex_number_region;

    PROCEDURE nearest_good_direction(
                  acart : REAL;
                  aitv : finite_real_interval;
                  VAR a : REAL;
                  VAR a_in : BOOLEAN      );
      a := acart;
      a_in := TRUE;
      IF a < aitv.min THEN
        IF ( a + ( 2 * PI ) ) < aitv.max THEN
          RETURN;
        END_IF;
        IF ( a + ( 2 * PI ) ) = aitv.max THEN
          a_in := max_included( aitv );
          RETURN;
        END_IF;
      ELSE
        IF a = aitv.min THEN
          a_in := min_included( aitv );
          RETURN;
        ELSE
          IF a < aitv.max THEN
            RETURN;
          ELSE
            IF a = aitv.max THEN
              a_in := max_included( aitv );
              RETURN;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
      IF COS( acart - aitv.max ) >= COS( acart - aitv.min ) THEN
        a := aitv.max;
        a_in := max_included( aitv );
      ELSE
        a := aitv.min;
        a_in := min_included( aitv );
      END_IF;

    END_PROCEDURE; -- nearest_good_direction (line:39089 file:ap242ed2_mim_lf_v1.101.TY.exp)

    LOCAL
      xc          : REAL := 0;
      yc          : REAL := 0;
      xmin        : REAL := 0;
      xmax        : REAL := 0;
      ymin        : REAL := 0;
      ymax        : REAL := 0;
      ritv        : real_interval;
      xitv        : real_interval;
      yitv        : real_interval;
      aitv        : finite_real_interval;
      xmin_exists : BOOLEAN;
      xmax_exists : BOOLEAN;
      ymin_exists : BOOLEAN;
      ymax_exists : BOOLEAN;
      xmin_in     : BOOLEAN := FALSE;
      xmax_in     : BOOLEAN := FALSE;
      ymin_in     : BOOLEAN := FALSE;
      ymax_in     : BOOLEAN := FALSE;
      a           : REAL := 0;
      r           : REAL := 0;
      a_in        : BOOLEAN := FALSE;
      min_clo     : open_closed := open;
      max_clo     : open_closed := open;
    END_LOCAL;
    IF NOT EXISTS( prgn ) THEN
      RETURN( ? );
    END_IF;
    xc := prgn.centre.real_part;
    yc := prgn.centre.imag_part;
    ritv := prgn.distance_constraint;
    aitv := prgn.direction_constraint;
    nearest_good_direction( PI, aitv, a, a_in );
    IF COS( a ) >= 0 THEN
      xmin_exists := TRUE;
      xmin := xc + ( real_min( ritv ) * COS( a ) );
      xmin_in := a_in AND ( min_included( ritv ) OR ( COS( a ) = 0 ) );
    ELSE
      IF max_exists( ritv ) THEN
        xmin_exists := TRUE;
        xmin := xc + ( real_max( ritv ) * COS( a ) );
        xmin_in := a_in AND max_included( ritv );
      ELSE
        xmin_exists := FALSE;
      END_IF;
    END_IF;
    nearest_good_direction( 0, aitv, a, a_in );
    IF COS( a ) <= 0 THEN
      xmax_exists := TRUE;
      xmax := xc + ( real_min( ritv ) * COS( a ) );
      xmax_in := a_in AND ( min_included( ritv ) OR ( COS( a ) = 0 ) );
    ELSE
      IF max_exists( ritv ) THEN
        xmax_exists := TRUE;
        xmax := xc + ( real_max( ritv ) * COS( a ) );
        xmax_in := a_in AND max_included( ritv );
      ELSE
        xmax_exists := FALSE;
      END_IF;
    END_IF;
    nearest_good_direction( ( -0.5 ) * PI, aitv, a, a_in );
    IF SIN( a ) >= 0 THEN
      ymin_exists := TRUE;
      ymin := yc + ( real_min( ritv ) * SIN( a ) );
      ymin_in := a_in AND ( min_included( ritv ) OR ( SIN( a ) = 0 ) );
    ELSE
      IF max_exists( ritv ) THEN
        ymin_exists := TRUE;
        ymin := yc + ( real_max( ritv ) * SIN( a ) );
        ymin_in := a_in AND max_included( ritv );
      ELSE
        ymin_exists := FALSE;
      END_IF;
    END_IF;
    nearest_good_direction( 0.5 * PI, aitv, a, a_in );
    IF SIN( a ) <= 0 THEN
      ymax_exists := TRUE;
      ymax := yc + ( real_min( ritv ) * SIN( a ) );
      ymax_in := a_in AND ( min_included( ritv ) OR ( SIN( a ) = 0 ) );
    ELSE
      IF max_exists( ritv ) THEN
        ymax_exists := TRUE;
        ymax := yc + ( real_max( ritv ) * SIN( a ) );
        ymax_in := a_in AND max_included( ritv );
      ELSE
        ymax_exists := FALSE;
      END_IF;
    END_IF;
    IF NOT ( xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists ) THEN
      RETURN( ? );
    END_IF;
    IF xmin_exists THEN
      IF xmin_in THEN
        min_clo := closed;
      ELSE
        min_clo := open;
      END_IF;
      IF xmax_exists THEN
        IF xmax_in THEN
          max_clo := closed;
        ELSE
          max_clo := open;
        END_IF;
        xitv := make_finite_real_interval( xmin, min_clo, xmax, max_clo );
      ELSE
        xitv := make_real_interval_from_min( xmin, min_clo );
      END_IF;
    ELSE
      IF xmax_exists THEN
        IF xmax_in THEN
          max_clo := closed;
        ELSE
          max_clo := open;
        END_IF;
        xitv := make_real_interval_to_max( xmax, max_clo );
      ELSE
        xitv := the_reals;
      END_IF;
    END_IF;
    IF ymin_exists THEN
      IF ymin_in THEN
        min_clo := closed;
      ELSE
        min_clo := open;
      END_IF;
      IF ymax_exists THEN
        IF ymax_in THEN
          max_clo := closed;
        ELSE
          max_clo := open;
        END_IF;
        yitv := make_finite_real_interval( ymin, min_clo, ymax, max_clo );
      ELSE
        yitv := make_real_interval_from_min( ymin, min_clo );
      END_IF;
    ELSE
      IF ymax_exists THEN
        IF ymax_in THEN
          max_clo := closed;
        ELSE
          max_clo := open;
        END_IF;
        yitv := make_real_interval_to_max( ymax, max_clo );
      ELSE
        yitv := the_reals;
      END_IF;
    END_IF;
    RETURN( make_cartesian_complex_number_region( xitv, yitv ) );

  END_FUNCTION; -- enclose_pregion_in_cregion (line:39088 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func ENCLOSE_PREGION_IN_CREGION(_ PRGN: ePOLAR_COMPLEX_NUMBER_REGION? ) 
    -> eCARTESIAN_COMPLEX_NUMBER_REGION? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( PRGN )
    if case .available(let _cached_value) = _enclose_pregion_in_cregion__cache.cachedValue(params: _params) {
      return _cached_value as? eCARTESIAN_COMPLEX_NUMBER_REGION
    }

    var PRGN = PRGN; SDAI.TOUCH(var: &PRGN)

    //NESTED PROCEDURE
    func NEAREST_GOOD_DIRECTION(ACART: SDAI.REAL? , AITV: eFINITE_REAL_INTERVAL? , 
                                A: inout SDAI.REAL? , A_IN: inout SDAI.BOOLEAN? ) {

      var ACART = ACART; SDAI.TOUCH(var: &ACART)
      var AITV = AITV; SDAI.TOUCH(var: &AITV)

      A = ACART
      A_IN = SDAI.BOOLEAN(SDAI.TRUE)
      
      let _TEMP1 = AITV?.MIN
      let _TEMP2 = A < _TEMP1
      if SDAI.IS_TRUE( _TEMP2 ) {
        
        let _TEMP3 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP4 = A + SDAI.FORCE_OPTIONAL(_TEMP3)
        let _TEMP5 = AITV?.MAX
        let _TEMP6 = _TEMP4 < _TEMP5
        if SDAI.IS_TRUE( _TEMP6 ) {
          return
        }
        
        let _TEMP7 = SDAI.REAL(2.0000000000e+00) * SDAI.REAL(SDAI.PI)
        let _TEMP8 = A + SDAI.FORCE_OPTIONAL(_TEMP7)
        let _TEMP9 = AITV?.MAX
        let _TEMP10 = _TEMP8 .==. _TEMP9
        if SDAI.IS_TRUE( _TEMP10 ) {
          
          let _TEMP11 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITV))
          A_IN = _TEMP11
          return
        }
      }
      else {
        
        let _TEMP12 = AITV?.MIN
        let _TEMP13 = A .==. _TEMP12
        if SDAI.IS_TRUE( _TEMP13 ) {
          
          let _TEMP14 = MIN_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITV))
          A_IN = _TEMP14
          return
        }
        else {
          
          let _TEMP15 = AITV?.MAX
          let _TEMP16 = A < _TEMP15
          if SDAI.IS_TRUE( _TEMP16 ) {
            return
          }
          else {
            
            let _TEMP17 = AITV?.MAX
            let _TEMP18 = A .==. _TEMP17
            if SDAI.IS_TRUE( _TEMP18 ) {
              
              let _TEMP19 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITV))
              A_IN = _TEMP19
              return
            }
          }
        }
      }
      
      let _TEMP20 = AITV?.MAX
      let _TEMP21 = ACART - _TEMP20
      let _TEMP22 = SDAI.COS(_TEMP21)
      let _TEMP23 = AITV?.MIN
      let _TEMP24 = ACART - _TEMP23
      let _TEMP25 = SDAI.COS(_TEMP24)
      let _TEMP26 = _TEMP22 >= _TEMP25
      if SDAI.IS_TRUE( _TEMP26 ) {
        
        let _TEMP27 = AITV?.MAX
        A = _TEMP27
        
        let _TEMP28 = MAX_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITV))
        A_IN = _TEMP28
      }
      else {
        
        let _TEMP29 = AITV?.MIN
        A = _TEMP29
        
        let _TEMP30 = MIN_INCLUDED(eMATHS_SPACE(/*eFINITE_REAL_INTERVAL*/AITV))
        A_IN = _TEMP30
      }
    } //END PROCEDURE NEAREST_GOOD_DIRECTION

    //LOCAL
    var XC: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &XC)
    var YC: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &YC)
    var XMIN: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &XMIN)
    var XMAX: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &XMAX)
    var YMIN: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &YMIN)
    var YMAX: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &YMAX)
    var RITV: sREAL_INTERVAL? 
    var XITV: sREAL_INTERVAL? 
    var YITV: sREAL_INTERVAL? 
    var AITV: eFINITE_REAL_INTERVAL? 
    var XMIN_EXISTS: SDAI.BOOLEAN? 
    var XMAX_EXISTS: SDAI.BOOLEAN? 
    var YMIN_EXISTS: SDAI.BOOLEAN? 
    var YMAX_EXISTS: SDAI.BOOLEAN? 
    var XMIN_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &XMIN_IN)
    var XMAX_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &XMAX_IN)
    var YMIN_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &YMIN_IN)
    var YMAX_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &YMAX_IN)
    var A: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &A)
    var R: SDAI.REAL?  = SDAI.REAL(0); SDAI.TOUCH(var: &R)
    var A_IN: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.FALSE); SDAI.TOUCH(var: &A_IN)
    var MIN_CLO: nOPEN_CLOSED?  = OPEN; SDAI.TOUCH(var: &MIN_CLO)
    var MAX_CLO: nOPEN_CLOSED?  = OPEN; SDAI.TOUCH(var: &MAX_CLO)
    //END_LOCAL

    
    let _TEMP1 = SDAI.EXISTS(PRGN)
    let _TEMP2 =  !_TEMP1
    if SDAI.IS_TRUE( _TEMP2 ) {
      return _enclose_pregion_in_cregion__cache.updateCache(params: _params, value: (nil as 
        eCARTESIAN_COMPLEX_NUMBER_REGION?))
    }
    
    let _TEMP3 = PRGN?.CENTRE
    let _TEMP4 = _TEMP3?.REAL_PART
    XC = _TEMP4
    
    let _TEMP5 = PRGN?.CENTRE
    let _TEMP6 = _TEMP5?.IMAG_PART
    YC = _TEMP6
    
    let _TEMP7 = PRGN?.DISTANCE_CONSTRAINT
    RITV = _TEMP7
    
    let _TEMP8 = PRGN?.DIRECTION_CONSTRAINT
    AITV = _TEMP8
    NEAREST_GOOD_DIRECTION( ACART: SDAI.REAL(SDAI.PI), AITV: AITV, A: &A, 
      A_IN: &A_IN )
    
    let _TEMP9 = SDAI.COS(A)
    let _TEMP10 = _TEMP9 >= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    if SDAI.IS_TRUE( _TEMP10 ) {
      XMIN_EXISTS = SDAI.BOOLEAN(SDAI.TRUE)
      
      let _TEMP11 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      let _TEMP12 = SDAI.COS(A)
      let _TEMP13 = _TEMP11 * _TEMP12
      let _TEMP14 = XC + _TEMP13
      XMIN = _TEMP14
      
      let _TEMP15 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      let _TEMP16 = SDAI.COS(A)
      let _TEMP17 = _TEMP16 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      let _TEMP18 = _TEMP15 || _TEMP17
      let _TEMP19 = A_IN && _TEMP18
      XMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP19)
    }
    else {
      
      let _TEMP20 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      if SDAI.IS_TRUE( _TEMP20 ) {
        XMIN_EXISTS = SDAI.BOOLEAN(SDAI.TRUE)
        
        let _TEMP21 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
        let _TEMP22 = SDAI.COS(A)
        let _TEMP23 = _TEMP21 * _TEMP22
        let _TEMP24 = XC + _TEMP23
        XMIN = _TEMP24
        
        let _TEMP25 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
        let _TEMP26 = A_IN && _TEMP25
        XMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP26)
      }
      else {
        XMIN_EXISTS = SDAI.BOOLEAN(SDAI.FALSE)
      }
    }
    NEAREST_GOOD_DIRECTION( ACART: SDAI.REAL(0), AITV: AITV, A: &A, A_IN: &A_IN )
    
    let _TEMP27 = SDAI.COS(A)
    let _TEMP28 = _TEMP27 <= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    if SDAI.IS_TRUE( _TEMP28 ) {
      XMAX_EXISTS = SDAI.BOOLEAN(SDAI.TRUE)
      
      let _TEMP29 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      let _TEMP30 = SDAI.COS(A)
      let _TEMP31 = _TEMP29 * _TEMP30
      let _TEMP32 = XC + _TEMP31
      XMAX = _TEMP32
      
      let _TEMP33 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      let _TEMP34 = SDAI.COS(A)
      let _TEMP35 = _TEMP34 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      let _TEMP36 = _TEMP33 || _TEMP35
      let _TEMP37 = A_IN && _TEMP36
      XMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP37)
    }
    else {
      
      let _TEMP38 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      if SDAI.IS_TRUE( _TEMP38 ) {
        XMAX_EXISTS = SDAI.BOOLEAN(SDAI.TRUE)
        
        let _TEMP39 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
        let _TEMP40 = SDAI.COS(A)
        let _TEMP41 = _TEMP39 * _TEMP40
        let _TEMP42 = XC + _TEMP41
        XMAX = _TEMP42
        
        let _TEMP43 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
        let _TEMP44 = A_IN && _TEMP43
        XMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP44)
      }
      else {
        XMAX_EXISTS = SDAI.BOOLEAN(SDAI.FALSE)
      }
    }
    NEAREST_GOOD_DIRECTION( ACART: SDAI.REAL( -5.0000000000e-01) * SDAI.REAL(SDAI.PI), 
      AITV: AITV, A: &A, A_IN: &A_IN )
    
    let _TEMP45 = SDAI.SIN(A)
    let _TEMP46 = _TEMP45 >= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    if SDAI.IS_TRUE( _TEMP46 ) {
      YMIN_EXISTS = SDAI.BOOLEAN(SDAI.TRUE)
      
      let _TEMP47 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      let _TEMP48 = SDAI.SIN(A)
      let _TEMP49 = _TEMP47 * _TEMP48
      let _TEMP50 = YC + _TEMP49
      YMIN = _TEMP50
      
      let _TEMP51 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      let _TEMP52 = SDAI.SIN(A)
      let _TEMP53 = _TEMP52 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      let _TEMP54 = _TEMP51 || _TEMP53
      let _TEMP55 = A_IN && _TEMP54
      YMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP55)
    }
    else {
      
      let _TEMP56 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      if SDAI.IS_TRUE( _TEMP56 ) {
        YMIN_EXISTS = SDAI.BOOLEAN(SDAI.TRUE)
        
        let _TEMP57 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
        let _TEMP58 = SDAI.SIN(A)
        let _TEMP59 = _TEMP57 * _TEMP58
        let _TEMP60 = YC + _TEMP59
        YMIN = _TEMP60
        
        let _TEMP61 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
        let _TEMP62 = A_IN && _TEMP61
        YMIN_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP62)
      }
      else {
        YMIN_EXISTS = SDAI.BOOLEAN(SDAI.FALSE)
      }
    }
    NEAREST_GOOD_DIRECTION( ACART: SDAI.REAL(5.0000000000e-01) * SDAI.REAL(SDAI.PI), 
      AITV: AITV, A: &A, A_IN: &A_IN )
    
    let _TEMP63 = SDAI.SIN(A)
    let _TEMP64 = _TEMP63 <= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
    if SDAI.IS_TRUE( _TEMP64 ) {
      YMAX_EXISTS = SDAI.BOOLEAN(SDAI.TRUE)
      
      let _TEMP65 = REAL_MIN(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      let _TEMP66 = SDAI.SIN(A)
      let _TEMP67 = _TEMP65 * _TEMP66
      let _TEMP68 = YC + _TEMP67
      YMAX = _TEMP68
      
      let _TEMP69 = MIN_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      let _TEMP70 = SDAI.SIN(A)
      let _TEMP71 = _TEMP70 .==. SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
      let _TEMP72 = _TEMP69 || _TEMP71
      let _TEMP73 = A_IN && _TEMP72
      YMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP73)
    }
    else {
      
      let _TEMP74 = MAX_EXISTS(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
      if SDAI.IS_TRUE( _TEMP74 ) {
        YMAX_EXISTS = SDAI.BOOLEAN(SDAI.TRUE)
        
        let _TEMP75 = REAL_MAX(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
        let _TEMP76 = SDAI.SIN(A)
        let _TEMP77 = _TEMP75 * _TEMP76
        let _TEMP78 = YC + _TEMP77
        YMAX = _TEMP78
        
        let _TEMP79 = MAX_INCLUDED(eMATHS_SPACE(/*sREAL_INTERVAL*/RITV))
        let _TEMP80 = A_IN && _TEMP79
        YMAX_IN = SDAI.BOOLEAN(/*SDAI.LOGICAL*/_TEMP80)
      }
      else {
        YMAX_EXISTS = SDAI.BOOLEAN(SDAI.FALSE)
      }
    }
    
    let _TEMP81 = XMIN_EXISTS || XMAX_EXISTS
    let _TEMP82 = _TEMP81 || YMIN_EXISTS
    let _TEMP83 = _TEMP82 || YMAX_EXISTS
    let _TEMP84 =  !_TEMP83
    if SDAI.IS_TRUE( _TEMP84 ) {
      return _enclose_pregion_in_cregion__cache.updateCache(params: _params, value: (nil as 
        eCARTESIAN_COMPLEX_NUMBER_REGION?))
    }
    if SDAI.IS_TRUE( XMIN_EXISTS ) {
      if SDAI.IS_TRUE( XMIN_IN ) {
        MIN_CLO = CLOSED
      }
      else {
        MIN_CLO = OPEN
      }
      if SDAI.IS_TRUE( XMAX_EXISTS ) {
        if SDAI.IS_TRUE( XMAX_IN ) {
          MAX_CLO = CLOSED
        }
        else {
          MAX_CLO = OPEN
        }
        
        let _TEMP85 = MAKE_FINITE_REAL_INTERVAL(
          MIN: XMIN, MINCLO: MIN_CLO, 
          MAX: XMAX, MAXCLO: MAX_CLO)
        XITV = sREAL_INTERVAL(/*eFINITE_REAL_INTERVAL*/_TEMP85)
      }
      else {
        
        let _TEMP86 = MAKE_REAL_INTERVAL_FROM_MIN(
          MIN: XMIN, MINCLO: MIN_CLO)
        XITV = sREAL_INTERVAL(/*eREAL_INTERVAL_FROM_MIN*/_TEMP86)
      }
    }
    else {
      if SDAI.IS_TRUE( XMAX_EXISTS ) {
        if SDAI.IS_TRUE( XMAX_IN ) {
          MAX_CLO = CLOSED
        }
        else {
          MAX_CLO = OPEN
        }
        
        let _TEMP87 = MAKE_REAL_INTERVAL_TO_MAX(
          MAX: XMAX, MAXCLO: MAX_CLO)
        XITV = sREAL_INTERVAL(/*eREAL_INTERVAL_TO_MAX*/_TEMP87)
      }
      else {
        XITV = sREAL_INTERVAL(/*eELEMENTARY_SPACE*/THE_REALS)
      }
    }
    if SDAI.IS_TRUE( YMIN_EXISTS ) {
      if SDAI.IS_TRUE( YMIN_IN ) {
        MIN_CLO = CLOSED
      }
      else {
        MIN_CLO = OPEN
      }
      if SDAI.IS_TRUE( YMAX_EXISTS ) {
        if SDAI.IS_TRUE( YMAX_IN ) {
          MAX_CLO = CLOSED
        }
        else {
          MAX_CLO = OPEN
        }
        
        let _TEMP88 = MAKE_FINITE_REAL_INTERVAL(
          MIN: YMIN, MINCLO: MIN_CLO, 
          MAX: YMAX, MAXCLO: MAX_CLO)
        YITV = sREAL_INTERVAL(/*eFINITE_REAL_INTERVAL*/_TEMP88)
      }
      else {
        
        let _TEMP89 = MAKE_REAL_INTERVAL_FROM_MIN(
          MIN: YMIN, MINCLO: MIN_CLO)
        YITV = sREAL_INTERVAL(/*eREAL_INTERVAL_FROM_MIN*/_TEMP89)
      }
    }
    else {
      if SDAI.IS_TRUE( YMAX_EXISTS ) {
        if SDAI.IS_TRUE( YMAX_IN ) {
          MAX_CLO = CLOSED
        }
        else {
          MAX_CLO = OPEN
        }
        
        let _TEMP90 = MAKE_REAL_INTERVAL_TO_MAX(
          MAX: YMAX, MAXCLO: MAX_CLO)
        YITV = sREAL_INTERVAL(/*eREAL_INTERVAL_TO_MAX*/_TEMP90)
      }
      else {
        YITV = sREAL_INTERVAL(/*eELEMENTARY_SPACE*/THE_REALS)
      }
    }
    
    let _TEMP91 = MAKE_CARTESIAN_COMPLEX_NUMBER_REGION(
      REAL_CONSTRAINT: XITV, IMAG_CONSTRAINT: YITV)
    return _enclose_pregion_in_cregion__cache.updateCache(params: _params, value: _TEMP91)
  }

}

//MARK: - function result cache
private var _enclose_pregion_in_cregion__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

