/* file: extremal_position_check.swift 	 generated: Mon Jan  3 16:32:52 2022 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
  derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.1, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
  will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -FUNCTION DEFINITION in EXPRESS
/*

  FUNCTION extremal_position_check(
               fun : linearized_table_function
           ) : BOOLEAN;

    LOCAL
      source_domain   : maths_space;
      source_interval : finite_integer_interval;
      index           : INTEGER := 1;
      base            : INTEGER;
      shape           : LIST OF positive_integer;
      ndim            : positive_integer;
      slo             : INTEGER;
      shi             : INTEGER;
      sublo           : LIST OF INTEGER := [];
      subhi           : LIST OF INTEGER := [];
    END_LOCAL;
    IF NOT EXISTS( fun ) THEN
      RETURN( FALSE );
    END_IF;
    source_domain := factor1( fun.source.domain );
    IF ( schema_prefix + 'TUPLE_SPACE' ) IN TYPEOF( source_domain ) THEN
      source_domain := factor1( source_domain );
    END_IF;
    IF NOT ( ( schema_prefix + 'FINITE_INTEGER_INTERVAL' ) IN TYPEOF( source_domain ) ) THEN
      RETURN( FALSE );
    END_IF;
    source_interval := source_domain;
    base := fun\explicit_table_function.index_base;
    shape := fun\explicit_table_function.shape;
    IF ( schema_prefix + 'STANDARD_TABLE_FUNCTION' ) IN TYPEOF( fun ) THEN
      REPEAT j := 1 TO SIZEOF( shape ) BY 1;
        index := index * shape[j];
      END_REPEAT;
      index := ( fun.first + index ) - 1;
      RETURN( bool( ( source_interval.min <= index ) AND ( index <= source_interval.max ) ) );
    END_IF;
    IF ( schema_prefix + 'REGULAR_TABLE_FUNCTION' ) IN TYPEOF( fun ) THEN
      ndim := SIZEOF( fun\explicit_table_function.shape );
      REPEAT j := 1 TO ndim BY 1;
        slo := base;
        shi := ( base + shape[j] ) - 1;
        IF fun\regular_table_function.increments[j] >= 0 THEN
          INSERT( sublo, slo, j - 1 );
          INSERT( subhi, shi, j - 1 );
        ELSE
          INSERT( sublo, shi, j - 1 );
          INSERT( subhi, slo, j - 1 );
        END_IF;
      END_REPEAT;
      index := regular_indexing( sublo, base, shape, fun\regular_table_function.increments, fun.first );
      IF NOT ( ( source_interval.min <= index ) AND ( index <= source_interval.max ) ) THEN
        RETURN( FALSE );
      END_IF;
      index := regular_indexing( subhi, base, shape, fun\regular_table_function.increments, fun.first );
      IF NOT ( ( source_interval.min <= index ) AND ( index <= source_interval.max ) ) THEN
        RETURN( FALSE );
      END_IF;
      RETURN( TRUE );
    END_IF;
    RETURN( FALSE );

  END_FUNCTION; -- extremal_position_check (line:40624 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static 
  func EXTREMAL_POSITION_CHECK(_ FUN: eLINEARIZED_TABLE_FUNCTION? ) 
    -> SDAI.BOOLEAN? {

    // CACHE LOOKUP
    let _params = SDAI.ParameterList( FUN )
    if case .available(let _cached_value) = _extremal_position_check__cache.cachedValue(params: _params) {
      return _cached_value as? SDAI.BOOLEAN
    }

    var FUN = FUN; SDAI.TOUCH(var: &FUN)

    //LOCAL
    var SOURCE_DOMAIN: eMATHS_SPACE? 
    var SOURCE_INTERVAL: eFINITE_INTEGER_INTERVAL? 
    var INDEX: SDAI.INTEGER?  = SDAI.INTEGER(1); SDAI.TOUCH(var: &INDEX)
    var BASE: SDAI.INTEGER? 
    var SHAPE: SDAI.LIST<tPOSITIVE_INTEGER>? 
    var NDIM: tPOSITIVE_INTEGER? 
    var SLO: SDAI.INTEGER? 
    var SHI: SDAI.INTEGER? 
    var SUBLO: SDAI.LIST<SDAI.INTEGER>?  = SDAI.LIST<SDAI.INTEGER>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &SUBLO)
    var SUBHI: SDAI.LIST<SDAI.INTEGER>?  = SDAI.LIST<SDAI.INTEGER>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &SUBHI)
    //END_LOCAL

    
    let _TEMP1 = SDAI.EXISTS(FUN)
    let _TEMP2 =  !_TEMP1
    if SDAI.IS_TRUE( _TEMP2 ) {
      return _extremal_position_check__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    
    let _TEMP3 = FUN?.SOURCE
    let _TEMP4 = _TEMP3?.DOMAIN
    let _TEMP5 = FACTOR1(_TEMP4)
    SOURCE_DOMAIN = _TEMP5
    
    let _TEMP6 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("TUPLE_SPACE"))
    let _TEMP7 = SDAI.TYPEOF(SOURCE_DOMAIN)
    let _TEMP8 = SDAI.aggregate(_TEMP7, contains: _TEMP6)
    if SDAI.IS_TRUE( _TEMP8 ) {
      
      let _TEMP9 = FACTOR1(sTUPLE_SPACE(/*eMATHS_SPACE*/SOURCE_DOMAIN))
      SOURCE_DOMAIN = _TEMP9
    }
    
    let _TEMP10 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING(
      "FINITE_INTEGER_INTERVAL"))
    let _TEMP11 = SDAI.TYPEOF(SOURCE_DOMAIN)
    let _TEMP12 = SDAI.aggregate(_TEMP11, contains: _TEMP10)
    let _TEMP13 =  !_TEMP12
    if SDAI.IS_TRUE( _TEMP13 ) {
      return _extremal_position_check__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
    }
    SOURCE_INTERVAL = eFINITE_INTEGER_INTERVAL(/*eMATHS_SPACE*/SOURCE_DOMAIN)
    
    let _TEMP14 = FUN?.GROUP_REF(eEXPLICIT_TABLE_FUNCTION.self)
    let _TEMP15 = _TEMP14?.INDEX_BASE
    BASE = SDAI.INTEGER(/*tZERO_OR_ONE*/_TEMP15)
    
    let _TEMP16 = FUN?.GROUP_REF(eEXPLICIT_TABLE_FUNCTION.self)
    let _TEMP17 = _TEMP16?.SHAPE
    SHAPE = SDAI.LIST<tPOSITIVE_INTEGER>(/*SDAI.LIST<tPOSITIVE_INTEGER>[1:nil] */_TEMP17)
    
    let _TEMP18 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING(
      "STANDARD_TABLE_FUNCTION"))
    let _TEMP19 = SDAI.TYPEOF(FUN)
    let _TEMP20 = SDAI.aggregate(_TEMP19, contains: _TEMP18)
    if SDAI.IS_TRUE( _TEMP20 ) {
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
        SHAPE)) {
        for J in incrementControl {
          
          let _TEMP21 = SHAPE?[J]
          let _TEMP22 = INDEX * _TEMP21
          INDEX = _TEMP22
        }
      }
      
      let _TEMP23 = FUN?.FIRST
      let _TEMP24 = _TEMP23 + INDEX
      let _TEMP25 = _TEMP24 - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
      INDEX = _TEMP25
      
      let _TEMP26 = SOURCE_INTERVAL?.MIN
      let _TEMP27 = _TEMP26 <= INDEX
      let _TEMP28 = SOURCE_INTERVAL?.MAX
      let _TEMP29 = INDEX <= _TEMP28
      let _TEMP30 = _TEMP27 && _TEMP29
      let _TEMP31 = BOOL(SDAI.LOGICAL(_TEMP30))
      return _extremal_position_check__cache.updateCache(params: _params, value: _TEMP31)
    }
    
    let _TEMP32 = SDAI.FORCE_OPTIONAL(SCHEMA_PREFIX) + SDAI.FORCE_OPTIONAL(SDAI.STRING("REGULAR_TABLE_FUNCTION"))
    let _TEMP33 = SDAI.TYPEOF(FUN)
    let _TEMP34 = SDAI.aggregate(_TEMP33, contains: _TEMP32)
    if SDAI.IS_TRUE( _TEMP34 ) {
      
      let _TEMP35 = FUN?.GROUP_REF(eEXPLICIT_TABLE_FUNCTION.self)
      let _TEMP36 = _TEMP35?.SHAPE
      let _TEMP37 = SDAI.SIZEOF(_TEMP36)
      NDIM = tPOSITIVE_INTEGER(/*SDAI.INTEGER*/_TEMP37)
      if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*tPOSITIVE_INTEGER*/NDIM) {
        for J in incrementControl {
          SLO = BASE
          
          let _TEMP38 = SHAPE?[J]
          let _TEMP39 = BASE + _TEMP38
          let _TEMP40 = _TEMP39 - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1))
          SHI = _TEMP40
          
          let _TEMP41 = FUN?.GROUP_REF(eREGULAR_TABLE_FUNCTION.self)
          let _TEMP42 = _TEMP41?.INCREMENTS
          let _TEMP43 = _TEMP42?[J]
          let _TEMP44 = _TEMP43 >= SDAI.FORCE_OPTIONAL(SDAI.INTEGER(0))
          if SDAI.IS_TRUE( _TEMP44 ) {
            SDAI.INSERT( L: &SUBLO, E: SLO, P: SDAI.FORCE_OPTIONAL(J) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) )
            SDAI.INSERT( L: &SUBHI, E: SHI, P: SDAI.FORCE_OPTIONAL(J) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) )
          }
          else {
            SDAI.INSERT( L: &SUBLO, E: SHI, P: SDAI.FORCE_OPTIONAL(J) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) )
            SDAI.INSERT( L: &SUBHI, E: SLO, P: SDAI.FORCE_OPTIONAL(J) - SDAI.FORCE_OPTIONAL(SDAI.INTEGER(1)) )
          }
        }
      }
      
      let _TEMP45 = FUN?.GROUP_REF(eREGULAR_TABLE_FUNCTION.self)
      let _TEMP46 = _TEMP45?.INCREMENTS
      let _TEMP47 = FUN?.FIRST
      let _TEMP48 = REGULAR_INDEXING(
        SUB: SUBLO, BASE: tZERO_OR_ONE(/*SDAI.INTEGER*/BASE), 
        SHAPE: SDAI.LIST<tPOSITIVE_INTEGER>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), bound2: (nil as SDAI.INTEGER?), 
        /*SDAI.LIST<tPOSITIVE_INTEGER>*/SHAPE), 
        INC: _TEMP46, FIRST: _TEMP47)
      INDEX = _TEMP48
      
      let _TEMP49 = SOURCE_INTERVAL?.MIN
      let _TEMP50 = _TEMP49 <= INDEX
      let _TEMP51 = SOURCE_INTERVAL?.MAX
      let _TEMP52 = INDEX <= _TEMP51
      let _TEMP53 = _TEMP50 && _TEMP52
      let _TEMP54 =  !_TEMP53
      if SDAI.IS_TRUE( _TEMP54 ) {
        return _extremal_position_check__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
      }
      
      let _TEMP55 = FUN?.GROUP_REF(eREGULAR_TABLE_FUNCTION.self)
      let _TEMP56 = _TEMP55?.INCREMENTS
      let _TEMP57 = FUN?.FIRST
      let _TEMP58 = REGULAR_INDEXING(
        SUB: SUBHI, BASE: tZERO_OR_ONE(/*SDAI.INTEGER*/BASE), 
        SHAPE: SDAI.LIST<tPOSITIVE_INTEGER>(bound1: SDAI.UNWRAP(SDAI.INTEGER(1)), bound2: (nil as SDAI.INTEGER?), 
        /*SDAI.LIST<tPOSITIVE_INTEGER>*/SHAPE), 
        INC: _TEMP56, FIRST: _TEMP57)
      INDEX = _TEMP58
      
      let _TEMP59 = SOURCE_INTERVAL?.MIN
      let _TEMP60 = _TEMP59 <= INDEX
      let _TEMP61 = SOURCE_INTERVAL?.MAX
      let _TEMP62 = INDEX <= _TEMP61
      let _TEMP63 = _TEMP60 && _TEMP62
      let _TEMP64 =  !_TEMP63
      if SDAI.IS_TRUE( _TEMP64 ) {
        return _extremal_position_check__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
      }
      return _extremal_position_check__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.TRUE))
    }
    return _extremal_position_check__cache.updateCache(params: _params, value: SDAI.BOOLEAN(SDAI.FALSE))
  }

}

//MARK: - function result cache
private var _extremal_position_check__cache = SDAI.FunctionResultCache(
  controller: AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.schemaDefinition)

