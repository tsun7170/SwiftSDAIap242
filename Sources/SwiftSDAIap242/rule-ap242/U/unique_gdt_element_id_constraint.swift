/* file: unique_gdt_element_id_constraint.swift 	 generated: Sat Aug 14 13:46:02 2021 */

/* This file was generated by the EXPRESS to Swift translator "exp2swift", 
    derived from STEPcode (formerly NIST's SCL).
 exp2swift version: v.1.0.0, derived from stepcode v0.8 as of 2019/11/23 
 WARNING: You probably don't want to edit it since your modifications 
    will be lost if exp2swift is used to regenerate it.
 */

 
import SwiftSDAIcore

extension AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF {
//MARK: -RULE DEFINITION in EXPRESS
/*

  RULE unique_gdt_element_id_constraint FOR ( product_definition_shape, dimensional_location, 
    dimensional_size, shape_aspect, shape_aspect_relationship );

    LOCAL
      bss  : BAG OF STRING := [];
      ds   : SET OF dimensional_size := QUERY ( ds <* dimensional_size | EXISTS( ds\dimensional_size.id ) );
      sa   : SET OF shape_aspect := QUERY ( sa <* shape_aspect | EXISTS( sa\shape_aspect.id ) );
      sar  : SET OF shape_aspect_relationship := QUERY ( sar <* shape_aspect_relationship | EXISTS( sar\
              shape_aspect_relationship.id ) );
      ssa  : SET OF shape_aspect := [];
      pass : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT ii := 1 TO SIZEOF( product_definition_shape ) BY 1 WHILE pass;
      bss := [];
      ssa := bag_to_set( USEDIN( product_definition_shape[ii], 
          'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF.SHAPE_ASPECT.OF_SHAPE'  ) );
      REPEAT i := 1 TO SIZEOF( ds ) BY 1;
        IF ds[i]\dimensional_size.applies_to IN ssa THEN
          bss := bss + ds[i]\dimensional_size.id;
        END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF( sa ) BY 1;
        IF sa[i] IN ssa THEN
          bss := bss + sa[i]\shape_aspect.id;
        END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF( sar ) BY 1;
        IF sar[i]\shape_aspect_relationship.relating_shape_aspect IN ssa THEN
          bss := bss + sar[i]\shape_aspect_relationship.id;
        END_IF;
      END_REPEAT;
      IF SIZEOF( bag_to_set( bss ) ) <> SIZEOF( bss ) THEN
        pass := FALSE;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- unique_gdt_element_id_constraint (line:49933 file:ap242ed2_mim_lf_v1.101.TY.exp)

*/

  public static
  func UNIQUE_GDT_ELEMENT_ID_CONSTRAINT( 
    allComplexEntities: AnySequence<SDAI.ComplexEntity> ) -> [SDAI.WhereLabel:SDAI.LOGICAL] {

    //ENTITY REFERENCES
    let PRODUCT_DEFINITION_SHAPE = 
      SDAI.POPULATION(OF: ePRODUCT_DEFINITION_SHAPE.self, FROM: allComplexEntities)
    let DIMENSIONAL_LOCATION = SDAI.POPULATION(OF: eDIMENSIONAL_LOCATION.self, FROM: allComplexEntities)
    let DIMENSIONAL_SIZE = SDAI.POPULATION(OF: eDIMENSIONAL_SIZE.self, FROM: allComplexEntities)
    let SHAPE_ASPECT = SDAI.POPULATION(OF: eSHAPE_ASPECT.self, FROM: allComplexEntities)
    let SHAPE_ASPECT_RELATIONSHIP = 
      SDAI.POPULATION(OF: eSHAPE_ASPECT_RELATIONSHIP.self, FROM: allComplexEntities)

    //LOCAL
    var BSS: SDAI.BAG<SDAI.STRING>?  = SDAI.BAG<SDAI.STRING>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &BSS)
    var DS: SDAI.SET<eDIMENSIONAL_SIZE>?  = DIMENSIONAL_SIZE
                                            .QUERY{ DS in 

                                              let _TEMP1 = DS.GROUP_REF(eDIMENSIONAL_SIZE.self)
                                              let _TEMP2 = _TEMP1?.ID
                                              let _TEMP3 = SDAI.EXISTS(_TEMP2)
                                              return SDAI.LOGICAL(/*SDAI.BOOLEAN*/_TEMP3) }; SDAI.TOUCH(var: &DS)
    var SA: SDAI.SET<eSHAPE_ASPECT>?  = SHAPE_ASPECT
                                        .QUERY{ SA in 

                                          let _TEMP1 = SA.GROUP_REF(eSHAPE_ASPECT.self)
                                          let _TEMP2 = _TEMP1?.ID
                                          let _TEMP3 = SDAI.EXISTS(_TEMP2)
                                          return SDAI.LOGICAL(/*SDAI.BOOLEAN*/_TEMP3) }; SDAI.TOUCH(var: &SA)
    var SAR: SDAI.SET<eSHAPE_ASPECT_RELATIONSHIP>?  = SHAPE_ASPECT_RELATIONSHIP
                                                      .QUERY{ SAR in 

                                                        let _TEMP1 = SAR.GROUP_REF(eSHAPE_ASPECT_RELATIONSHIP.self)
                                                        let _TEMP2 = _TEMP1?.ID
                                                        let _TEMP3 = SDAI.EXISTS(
                                                          _TEMP2)
                                                        return SDAI.LOGICAL(/*SDAI.BOOLEAN*/_TEMP3) }; SDAI.TOUCH(var: &SAR)
    var SSA: SDAI.SET<eSHAPE_ASPECT>?  = SDAI.SET<eSHAPE_ASPECT>(SDAI.EMPLY_AGGREGATE); SDAI.TOUCH(var: &SSA)
    var PASS: SDAI.BOOLEAN?  = SDAI.BOOLEAN(SDAI.TRUE); SDAI.TOUCH(var: &PASS)
    //END_LOCAL

    if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/SDAI.SIZEOF(
      PRODUCT_DEFINITION_SHAPE)) {
      for II in incrementControl {
        if !SDAI.IS_TRUE(SDAI.LOGICAL(/*SDAI.BOOLEAN*/PASS)) { break }
        
        let _TEMP1 = SDAI.BAG<SDAI.STRING>(SDAI.EMPLY_AGGREGATE)
        BSS = _TEMP1
        
        let _TEMP2 = PRODUCT_DEFINITION_SHAPE[II]
        let _TEMP3 = SDAI.USEDIN(T: _TEMP2, ROLE: \AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM_LF
          .eSHAPE_ASPECT.OF_SHAPE)
        let _TEMP4 = BAG_TO_SET(_TEMP3)
        SSA = SDAI.SET<eSHAPE_ASPECT>(generic: /*SDAI.SET<gINTYPE>*/_TEMP4)
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
          SDAI.SIZEOF(DS)) {
          for I in incrementControl {
            
            let _TEMP5 = DS?[I]
            let _TEMP6 = _TEMP5?.GROUP_REF(eDIMENSIONAL_SIZE.self)
            let _TEMP7 = _TEMP6?.APPLIES_TO
            let _TEMP8 = SDAI.aggregate(SSA, contains: _TEMP7)
            if SDAI.IS_TRUE( _TEMP8 ) {
              
              let _TEMP9 = DS?[I]
              let _TEMP10 = _TEMP9?.GROUP_REF(eDIMENSIONAL_SIZE.self)
              let _TEMP11 = _TEMP10?.ID
              let _TEMP12 = BSS + _TEMP11
              BSS = _TEMP12
            }
          }
        }
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
          SDAI.SIZEOF(SA)) {
          for I in incrementControl {
            
            let _TEMP13 = SA?[I]
            let _TEMP14 = SDAI.aggregate(SSA, contains: _TEMP13)
            if SDAI.IS_TRUE( _TEMP14 ) {
              
              let _TEMP15 = SA?[I]
              let _TEMP16 = _TEMP15?.GROUP_REF(eSHAPE_ASPECT.self)
              let _TEMP17 = _TEMP16?.ID
              let _TEMP18 = BSS + _TEMP17
              BSS = _TEMP18
            }
          }
        }
        if let incrementControl/*SDAI.INTEGER*/ = SDAI.FROM(/*SDAI.INTEGER*/1, TO:/*SDAI.INTEGER*/
          SDAI.SIZEOF(SAR)) {
          for I in incrementControl {
            
            let _TEMP19 = SAR?[I]
            let _TEMP20 = _TEMP19?.GROUP_REF(eSHAPE_ASPECT_RELATIONSHIP.self)
            let _TEMP21 = _TEMP20?.RELATING_SHAPE_ASPECT
            let _TEMP22 = SDAI.aggregate(SSA, contains: _TEMP21)
            if SDAI.IS_TRUE( _TEMP22 ) {
              
              let _TEMP23 = SAR?[I]
              let _TEMP24 = _TEMP23?.GROUP_REF(eSHAPE_ASPECT_RELATIONSHIP.self)
              let _TEMP25 = _TEMP24?.ID
              let _TEMP26 = BSS + _TEMP25
              BSS = _TEMP26
            }
          }
        }
        
        let _TEMP27 = BAG_TO_SET(BSS)
        let _TEMP28 = SDAI.SIZEOF(_TEMP27)
        let _TEMP29 = SDAI.SIZEOF(BSS)
        let _TEMP30 = _TEMP28 .!=. _TEMP29
        if SDAI.IS_TRUE( _TEMP30 ) {
          PASS = SDAI.BOOLEAN(SDAI.FALSE)
        }
      }
    }

    //WHERE
    var _conformance: [SDAI.WhereLabel:SDAI.LOGICAL] = [:]
    let WHERE_wr1 = SDAI.LOGICAL(/*SDAI.BOOLEAN*/PASS)
    _conformance["WHERE_wr1"] = WHERE_wr1


    return _conformance
  }

}
